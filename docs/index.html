<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan Peace 2024" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Safety Plan Peace 2024">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gitbook_on":true,"repo_url":"<a href=\"https://github.com/NewGraphEnvironment/mybookdown-template/\" class=\"uri\">https://github.com/NewGraphEnvironment/mybookdown-template/</a>","report_url":"<a href=\"https://newgraphenvironment.github.io/mybookdown-template\" class=\"uri\">https://newgraphenvironment.github.io/mybookdown-template</a>","update_bib":true,"update_packages":false},"title":"Safety Plan Peace 2024"}
</script>

<title>Safety Plan Peace 2024</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
.title {
font-size: 18px;
color: Black;
text-align: center;
}
.author { 
font-size: 13px;
color: Black;
text-align: center;
}
.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan Peace 2024</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-09<br />
Date Revised: 2024-09-08</p>
</div>
<p><br></p>
<p><br></p>
<div id="safety-plan---2024-073-sern-peace-fish-passage" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2024-073-sern-peace-fish-passage</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/safety_plan_sern-peace-fish-passage.pdf">here</a>.</p>
<p><br></p>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the six permitted electrofishing sites most of the time. Additionally, we may conduct fish passage (Phase 1) and habitat confirmation (Phase 2) assessments in the Carp and Crooked watershed groups as well. A summary of the potential sites for fish passage assessments, habitat confirmation assessments, and electrofishing is provided in Table <a href="#tab:tab-electrofishing-sites">4</a>, with kml (google earth) and gpx (garmin) files downloadable <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/sites_sern-peace-fish-passage_20240908_kml_gpx.zip">here</a>.</p>
<p><br></p>
<p>Georeferenced pdf maps can be accessed and downloaded <a href="https://hillcrestgeo.ca/outgoing/fishpassage/projects/parsnip/">here</a>.</p>
<p><br></p>
<div id="new-graph-employee-information" class="section level2 unnumbered">
<h2>New Graph Employee Information</h2>
<p>Al Irvine<br />
Vehicle: 2013 Toyota Tundra black w/flatdeck and yellow can-am quad<br />
Accommodation: 3396 Rosia Road, Prince George, BC V2K 4Y5</p>
<p><br></p>
<p>Lucy Schick<br />
Vehicle: 2006 Pontiac Vibe red<br />
Accommodation: 6596 Dawson Road, Prince George, BC V2K 5Y4</p>
<p><br></p>
</div>
<div id="crew-members" class="section level2 unnumbered">
<h2>Crew Members</h2>
<p>New Graph Employees Al Irvine and Lucy Schick will be joined by crews from McLoed Lake. All crew member information and emergency contacts can be found below.</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 1: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
must be contacted by inreach first. Cannot cold call
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara@newgraphenvironment.com" class="email">tara@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
<a href="mailto:tlucoordinator@mlib.ca" class="email">tlucoordinator@mlib.ca</a>
</td>
<td style="text-align:left;">
250-617-5930
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Eran Spence
</td>
<td style="text-align:left;">
<a href="mailto:espence@mlib.ca" class="email">espence@mlib.ca</a>
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Eugenia Isadore
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Tristan Salonas
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Bianca Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
John Demont
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Lucy Schick
</td>
<td style="text-align:left;">
<a href="mailto:lucy@newgraphenvironment.com" class="email">lucy@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
604-741-2032
</td>
<td style="text-align:left;">
807-790-9843
</td>
<td style="text-align:left;">
Sa Boothroyd
</td>
<td style="text-align:left;">
<a href="mailto:saboothroyd@gmail.com" class="email">saboothroyd@gmail.com</a>
</td>
<td style="text-align:left;">
604-740-7199
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="equipment-checklists" class="section level2 unnumbered">
<h2>Equipment Checklists</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:table-equipment">Table 2: </span>Personal Equipment Checklist
</caption>
<thead>
<tr>
<th style="text-align:left;">
Personal Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
food
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
gloves work
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
glasses safety
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
hard hat
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
steel toed boots
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
field vest (surveyors)
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
Boots
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
water
</td>
<td style="text-align:left;">
range finder
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-crew">Table 3: </span>Crew Equipment Checklist
</caption>
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio handheld
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Satelite communicator
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure eslon
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br><br></p>
</div>
<div id="nearest-hospitals" class="section level2 unnumbered">
<h2>Nearest Hospitals</h2>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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" alt="University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000" width="100%" />
<p class="caption">
Figure 1: University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000
</p>
</div>
<p><br></p>
</div>
<div id="emergency-response-plan" class="section level2 unnumbered">
<h2>Emergency Response Plan</h2>
<p>New Graph’s detailed emergency response procedures can be found <a href="https://www.newgraphenvironment.com/hsp/plans-and-assessments.html#emergency-response-plan-erp-and-procedures">here</a>. These procedures should be reviewed and an emergency response plan should be completed for each job site. Our Emergency Responce Plan template can be downloaded <a href="https://github.com/NewGraphEnvironment/hsp/blob/master/data/form_templates/ERP_template.pdf">here</a>.</p>
<p><br></p>
</div>
<div id="driving" class="section level2 unnumbered">
<h2>Driving</h2>
<p>We will be driving on forest service roads where it is essential to exercise caution and adhere strictly to all radio use protocols to ensure our safety. Proper communication on these roads helps prevent accidents by keeping everyone informed about vehicle movements and road conditions. Please review the <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#resource-road-safety">resource road safety</a> and <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#radio-use">radio use</a> sections of our Health and Safety plan so that everyone stays safe.</p>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the 5 or 6 permitted electrofishing sites most of the time. In addition we may spend some time with fish passage assessments in areas of not only the Parsnip watershed group but also the Carp and Crooked watershed groups.</p>
<p>Field work methods will result in products feeding reporting formats such as <a href="https://www.newgraphenvironment.com/fish_passage_peace_2022_reporting/">here</a> for 2022 and <a href="https://www.newgraphenvironment.com/fish_passage_peace_2023_reporting/">here</a> for 2023. We generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(BC Ministry of Environment 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data, and the Field Guide to these site cards can be found <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a>.</p>
<p><br></p>
<p>We have PIT tagging equipment so we could consider <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">tagging</a> fish captured at electrofishing sites to help us better understand population sizes and fish movement upstream and downstream of sites over the years.</p>
<p><br></p>
<p>We use digital field form using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Please see our <a href="https://www.newgraphenvironment.com/fish_passage_guidebook/">Fish Passage Guidebook</a> for instructions on how to set up Mergin Maps and use our digital field forms. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) each morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2MAAADlCAYAAADeMC9RAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nOzdd1hTd/s/8HfYewkBQYaICiJOoICAKHVSxSrOKmLxi20d1eexjqd1Vdu66mOtbZU6nlpHHVVxoAwBQZaIMkVkKMoMssImJOf3hxfnRxQtaiCA9+u6uOAkJ+fcCY688/mc+8MBAIZhbgAYC0IIIYQQQgghHS2Mw+G4y0i7CkIIIYQQQgh5H1EYI4QQQgghhBApkJN2Ad1ZbW0t+Hw+qqurwefzUVlZCYZhUFlZye5TX1+PhoaGNh+vrq4OObnnvwI5OTl2W0NDA1paWtDU1IS6ujoUFBQ65fkQQgghhBBCOg+FsVYaGxvx5MkTlJSUoKioCMXFxSgpKUFhYSF4PB4KCwtRVVWFiooK8Pl8KCsrQ0NDQ+xLUVERKioq7DHV1NQgLy/f5vlqa2vR1NTEbldVVUEgELDBjs/ng8/ng8PhsMfncrngcrkwMjICl8tF7969YWBgAH19fRgZGcHQ0BAcDqfDXytCCCGEEELIu3nvwhifz0dmZiZyc3ORk5Mj9p3H48HIyIgNOL179waXy4WLiwu4XC4MDQ2hpaXFjlrJyHTOLM/Gxkbw+XxUVVWBx+OBx+OhoKAAPB4Pt2/fZkNjQUEBysvLYWZmhn79+sHc3Bz9+vVjvywsLF4ZDAkhhBBCCCGdiwP0zG6Kzc3NyMzMRFpaGpKTk5GWlobU1FQ8e/YMAwcOFAsr5ubmMDc3h7GxMWRlZaVd+jtpaGhoM2hmZ2fjyZMn6N+/P2xsbGBjY4MhQ4Zg8ODBMDY2lnbZhBBCCCGEvE/COByOe48JY0+ePEFMTAxiY2MRFxeHtLQ0mJiYiIWOIUOGoG/fvu/tNL7Gxkbcv38fqampYiG1vr4eH3zwARwcHODo6AgHBwdoaGhIu1xCCCGEEEJ6qu4dxlJTUxEaGoqYmBjExMSAYRg4OjrCyckJDg4OGDFiBJSVlaVdZrdQWlqKuLg4xMbGIiYmBnfv3oWZmRkcHR3h7OyM8ePHQ19fX9plEkIIIYQQ0lN0rzBWWlqK0NBQBAcHIzg4GCoqKhg3bhycnZ3h5OQEMzMzaZfYYzQ3NyMlJQUxMTG4efMmwsLCYGJigvHjx2P8+PFwdnaGoqKitMskhBBCCCGku+r6YSwnJwdnzpzB+fPnkZ2djTFjxrCBwNzcXNrlvTeEQiESEhIQFBSE4OBgpKWlYfTo0fDy8oKnpyc0NTWlXSIhhBBCCCHdSdcMY48ePcKZM2dw5swZFBUVYcaMGfDy8sKoUaPYNbmIdFVWVuL69es4c+YMwsLC4OrqipkzZ8LT05OuNSOEEEIIIeSfdZ0wVldXh9OnT8Pf3x+PHj3CjBkzMHPmTLi6unZa+3jydqqrq3H58mWcOXMGERERmDhxIpYsWQI3N7f3tlEKIYQQQggh/0D6YSw9PR0HDx7EyZMn4eTkhCVLlmDixIndvr38+6qqqgonTpzAwYMH0djYiCVLlmDhwoXQ0dGRdmmEEEIIIYR0JWEcDsddKsNOISEhcHNzw4QJE6CtrY179+7h0qVL8PDwoCDWjWlqauKLL75AcnIyjh49iqSkJFhYWGDJkiV49OiRtMsjhBBCCCGkS+nUMBYUFIRRo0Zh5cqV8PPzw+PHj7FlyxZadLgHcnR0xB9//IHs7Gz07t0bH3zwAXx9fZGTkyPt0gghhBBCCOkSOiWM3bx5Ew4ODli9ejVWrFiB1NRUzJs3jxpyvAd0dHSwefNmZGVlwdTUFI6OjvDx8UFBQYG0SyOEEEIIIUSqOjSMFRcXY8GCBfDx8cG///1vJCcnY/bs2dSU4z2kqamJjRs3Ijs7GyYmJhg+fDj27NmD5uZmaZdGCCGEEEKIVHRIKhIKhdi3bx+GDBkCY2NjpKenY+bMmRTCCDQ0NPDtt98iJiYGISEhGDFiBKKioqRdFiGEEEIIIZ1O4umopKQEH374IS5cuIDIyEh8//33UFFRkfRpJIbH4yE9PV0ixxIIBIiMjGz3/qWlpYiJiZHIubsbCwsLXLt2DZs2bcK8efPwzTffQCgUSrssQgghhBBCOo1Ew1hUVBRGjhyJDz74AKGhobC0tJTk4SUuKysLbm5u+PPPP9/5WDU1NVi/fj3Gjx/f7scEBwdj3bp173zu7mzGjBm4d+8e7ty5A3d3dxQXF0u7JEIIIYQQQjqFxMLY/v37MXv2bBw5cgTbt2/vFi3q+/fvDxcXF4kcS01NDT4+Pm/0mE8++eSNRtIkYefOnZ16vvbQ1dVFYGAg3NzcYG9vjzt37ki7JEIIIYQQQjqcRMLYjz/+iJ9//hnx8fFvNDLU2crLyxEeHo6srCz2Ng6HAwDg8/m4efMmysvLxR5TWVmJmJgYPHv2TOx2gUCAhIQE3Lp1q83pdRUVFcjNzUVubi5qampeWVPr9bfq6+uRn5+P6upq3Lx5E7W1ta983MOHDwEASUlJ7M8thEIh7t+/jzt37qChoYG9fcuWLTh8+DASExNRV1f3ymNLg4yMDDZv3oxffvkFU6ZMQWJiorRLIoQQQgghpEO9cxjbu3cv/P39ERYW1qXXCzt9+jROnDgBY2NjzJ49G/v27WPvS01NxdatW3HixAkMHToUfD4fAHDp0iWcOHECPB4PH3zwAa5fvw4AyMvLw+rVq6GmpoagoCC4uLhAJBKJna+hoQGLFy9GXl5emy38Kyoq8O9//xvOzs4AgPT0dFhbW2PVqlXYunUr9uzZAzc3t5ceJxAI8O9//xsjRozAjh07cOLECTg4OODGjRsAgGfPnmH27NkoKyvD48ePMWLECMTFxaGmpgY8Hg/Nzc3Izc1FU1OTRF5XSZsyZQqOHj0KDw8PJCQkSLscQgghhBBCOhbDMDeYt3DkyBGmf//+TH5+/ts8vNPk5eUxY8eOZbeDgoKYAwcOMAzDMEuWLGEWLlzIMAzDiEQiRltbm7l58yZTUVHBuLm5MTk5OUxOTg7j7e3NDB8+nGEYhpk4cSKTlZXFMAzDVFRUMH5+fkxTUxOTmprKKCoqMnl5ecyGDRuYmpqa19YVFBTEGBoasttz5sxhlixZwjAMw5SUlDAAmMLCwpcel5iYyABgKisrGYZhmIULFzIrV65kGIZhFi1axOzYsYPdd8eOHYy5uTnT3NzMHDlyhLG1tX2j105aLl++zPTu3ZvJycmRdimEEEIIIYRI2g0AeOtVl5OTk7Fu3TpERUXByMhIUrmwQ4SEhMDU1JTdfnEqpaamJoDnUxa5XC7KysoQFxfHjiIBwIIFCyAvL4+6ujpERETAwsICAKClpYWDBw+yxxKJRHB3d8exY8egqqrK3n7q1Ck8efIEADBw4EBMmzbtpVb/srKy7GN0dXUBPJ8+2bt375f2A8Duq6enh4qKCgDA9evX4eHhwe47ZcoUrF27ln0eLdMyu7qPPvoIGzZsgJeXF2JjY6GoqCjtkgghhBBCCJGot5qmKBQKsXjxYuzevRsDBgyQdE0SV1NTI3adGICXphW+qKGhAWVlZfjwww/ZL2dnZ1RVVaGhoQGPHz9u83gyMjJYt24d5syZI3admZqaGrS1taGtrS0W0iRNTk4OZWVl7DaXy2VvB7pPGAOAzz//HGZmZtixY4e0SyGEEEIIIUTi3iqM/fHHH1BTU8OCBQskXU+HGDVqFKKjo3H27FkAQF1dHY4fPw7geYhq3YBDJBJBJBLB3t4eubm5+OOPP9j7du/eDS0tLVhZWWH16tUQCAQAgLNnz7IjUwDg6+sLNzc3eHp6or6+HsDzESo/Pz/4+flh3LhxAACGYcAwDPu4V/38T1rvO3nyZFy5coXdzs3NhbW1NczMzKCgoIDGxsZ2H7cr+Pnnn7Fv3z4UFhZKuxRCCCGEEEIk6o3DGMMw2L59O7Zu3doR9XQIW1tbbNmyBXPnzoWlpSVmz54NDw8P8Hg83L17F3fu3AGPx0NaWhqePHmC8PBw6OnpYceOHfD19YW9vT3c3d3h4uICZWVlHD16FNHR0ejTpw/s7e2hqakJNTU1REZGQiAQID4+Hnv37kVmZiZmzZqFp0+fvlRTTU0NIiIiUFZWhtu3b4PH4yE5ORmZmZmorKxESEgIACAiIkLscQzDsPfFx8ejvLwciYmJSE5ORllZGb7//ntUVlbiv//9L3JycvD777/jjz/+AIfDwbBhw/DgwQOsXbtWYgtddzQjIyP4+Phgz5490i6FEEIIIYQQieIAzxt4ABjbngfcunULy5YtQ1JSUocW1hGKi4tRXl4OS0tLyMjIoKKigh3R0tbWRl1dHTty1KdPHygoKKCwsBB5eXkYMmSI2PTC+vp6PHz4EBYWFlBVVUVDQ4PY6A2XywWPxwMAqKiowMDAQKyW6upqlJaWAng+tVFDQwOVlZUAAB0dHVRVVbEjdubm5uzjRCIRO0VSVlYWWlpa7LREHR0daGlpQSQSISkpCdXV1bC1tRWrOzc3F+rq6tDT03v3F7ST5ObmwtHREQUFBW12piSEEEIIIaSbCeNwOO5vHMb+85//QFFREZs2berQ6ghpbcSIEfj111/h4OAg7VIIIYQQQgh5V2EcDsf9jacp3rlzh94Qk07n4OCAO3fuSLsMQgghhBBCJOaNw1h+fj5MTEw6ohZCXsnU1BQFBQXSLoMQQgghhBCJeeMw1tjYCCUlpY6ohZBXUlJSYjtTEkIIIYQQ0hO8cRjT0tJiG00Q0lkqKiqgra0t7TIIIYQQQgiRmDcOYwMHDkRaWlpH1ELIK6WmpsLKykraZRBCCCGEECIxb9wnfNSoUQgLC+s2Cz6/jfLycnz33XfYvn075OXl3/l4ZWVlCA4OhrKyMqZNmyZ2X1ZWFgIDA/HRRx+hX79+b32O1NRUxMbGit2mr68PT0/Ptz5mV9Hc3Ixbt25h79690i6FEEIIIYQQiXnjkbHp06fj8uXLqKur64h6uoTGxkYUFhaiublZIsdjGAb+/v5ITEx86b7a2lqsXr2aXXPsbW3evBkXL15EaGgoQkNDcfjwYYSGhr7TMbuKoKAg9OvXD8bGxtIuhRBCCCGEEIl545Gx3r17Y+zYsfD398fKlSs7oiap6927N06dOiWx4+nq6sLU1BSysrIv3Tds2DCxRZnfBp/Px2effYZx48axt33++eeYPn36Ox23q9i9ezeWLVsm7TIIIYQQQgiRqDcOYwCwceNGjBs3DvPnz4eurq6ka2qXjIwM5OXlQUVFBXfv3sXKlStRU1OD06dPo7i4GF5eXhg4cCC7f3BwMB4/fgyRSAQfHx+2I2RoaCji4uJgbW2NadOmgcPhoK6uDpcuXcK4ceMgIyODY8eOQSAQYPbs2TA2NkZQUBBycnKwePFiKCgoICIiAtHR0RgwYAC8vLzA4XAAANnZ2QgNDYWysjJqa2vZ29vS0NCAX3/9FRUVFZg/fz5MTU0RFRWFjIwM9OrVCx999BGEQiECAgJgamoKJycn9rEaGhpiQUwoFOLWrVvYv38/ACA9PR0PHjyAhYUFTpw4AUtLSyxatAgcDgclJSWIjY2Fi4sLTp06BTU1NXh7eyM5ORmBgYFwdXWFi4uLRH93b+LChQvg8XiYPXu21GoghBBCCCGkI7zxNEUAGDx4MObPn4+lS5dKup52yczMxNy5c7Ft2zbExMQgPDwc1dXVWL16NWbOnAl3d3eMGDEC6enpAIC1a9dCRUUFfn5+uHHjBjvKsmvXLigrK2PlypXYsWMHvvnmGzQ3N+PixYuYO3cuKisroa2tDWVlZezatQuGhoYAAAUFBaiqqkJBQQH79u2DSCTCqlWr8Msvv+Bf//oXACAlJQXr16+Hr68vZsyYgXv37r32OR06dAiysrK4ffs27OzsUFpaipEjR2Lbtm0oKiqCoqIiVFRUEB0djUGDBr32WFFRUXBwcICsrCwKCwuxZs0arF27Fvfu3YO1tTXWr1+PDRs2oKKiAv/617+wfPly/PXXXxgwYAA2bNiApUuX4t69ezA3N8ekSZNQXFz8rr+yt8Lj8bBixQocPHiwzVFFQgghhBBCurO3CmMAsHXrVuTk5OCnn36SZD3tMnDgQIwdOxampqZYt24dAgIC4O/vj5qaGvz1119ISUmBsrIyTpw4gZSUFCQlJcHZ2RnA8wD26aefoqSkBIcPH0Z6ejpOnjwJLpeLw4cPQ05ODjNmzBA736JFiyArK4tr164BACIiIjBnzhxUVFTg559/RnZ2No4fPw49PT0cOXIEDMNgzZo18PHxgby8PNTU1ODg4PDakbEVK1ZgyZIlOHfuHBQUFPC///0PKioqWL16NQ4cOACGYdDU1ARlZWVoaWm99vU5d+4c+xwMDQ3h7u6Ovn37wsfHBwsXLsTOnTtx4MABaGtrw8vLC+rq6li6dCnGjx8Pd3d3KCoq4tNPP8XcuXPRp08fZGZmvsuv660IBALMmzcPPj4+7O+OEEIIIYSQnuStpikCzxfh/fvvvzF69GioqanB19dXknX9I0VFRSgrK7PbCQkJ8PDwYLs8+vn5AQAOHDiAXr16sfuZmZnBzMwMwcHB6N27N7tfy/e2yMvLw8/PDwcPHsTYsWMhLy8PRUVFJCQkQEdH56VjMAyD6Oho/PDDD+wx5ORe/1K3dG2Ul5fH6NGj8fTpUwCAr68vvv32W1y/fh1NTU2YOnXqa48jEokQFhaGPXv2iN3eOgiOGDEC5eXlaGpqeikg9urVCyKRiN1WUVHp9HXlBAIB5syZAw0NDWzevLlTz00IIYQQQkhneeuRMQAwNTXFzZs38d133+HAgQOSqumtqKqqIjo6Wuy2R48eQVlZGXFxcWKdEUtKSqCmpobk5GTU1NSwt1dVVaGsrKzN4/v5+SE0NBT//e9/MWvWLACAmpoa0tPTxcJKbW0teDwegOfXjLX2upGx1mRlZdG/f3/2eS1duhR79uxBfHz8P44S3bp1C7a2tlBQUHjlPjU1Nejbt2+b+8jIvNMfiXcmFAqxcOFC1NfX49SpUzQ9kRBCCCGE9Fjv/M7b1NQUwcHB+OGHH7B7924wDCOJuv6RSCSCUChkt2fMmIGjR4/i7NmzaG5uRnh4OMLCwjBu3Dg8e/YMS5cuxZMnTxAbG4vQ0FDY2tpCXV0dn3/+OSoqKsDj8bBt2zZoaWmxx21oaGCPb2hoiClTpiAiIgIDBgwAANjY2MDIyAiLFy/Gs2fPUFZWhs2bN0NbWxvTpk3D7t272SUA8vLyXtu+vuV1a2howP379+Ht7c3et2zZMsTExEBLS+sfA925c+fa7KLYOjCeP38eX375JXve1iNh1dXVaGxsZLcl1d6/PaqqqvDxxx+jpqYGFy9ehKKiYqedmxBCCCGEkM4mkWEQCwsL3Lp1C3///TdmzJiBqqoqSRz2lVJSUpCWlobs7Gx2NGzy5MnYtGkTli9fDiMjI0RHR+PTTz+FoaEhLl26hPj4eDg4OCAgIACzZ8+GgoICzp8/j9TUVPTp0weLFi3Cl19+CYFAgEOHDsHc3BynT58WW09t2bJlWLJkCbstKyuLc+fO4dGjRzAxMcG8efPwxRdfsI09TExMMHz4cCxbtgx9+vQBwzBtXn+1Zs0a7Ny5E7t378YPP/yA06dPQ1NTk71fT08Pnp6emDt37mtfF5FIhKCgIEyYMOGl+yorK7F161Z88803UFFRwfLly1FeXo6bN28CACIjI5GdnY2cnBxkZmYiOzsbEREREAgECAsLQ3l5+Zv9kt7QvXv3YGtrC3Nzc/z999+vHdkjhBBCCCGkJ+AAAMMwNwCMfdeDNTU14auvvkJgYCDOnDmD4cOHv3OBBGy3xrdtlrJnzx5cv34dwcHBEq7s3TEMg99//x0bNmzAL7/8Ai8vL2mXRAghhBBCSEcL43A47m/dwKMtCgoK+Omnn+Ds7IxJkybhk08+webNm6Guri7J07w3MjIyEBoayq6b9raEQqHYVMSuIiMjA76+vmhsbMStW7fY6+QIIYQQQgh5H3RIt4aZM2ciIyMDzc3NsLKywrFjxzrtWrKe5MGDBzhw4ADU1dXfeuHlgoIC3L17F1VVVbhy5YqEK3w7dXV12Lx5M8aMGQM1NTVkZWVh2rRp+PTTT+Hv74+UlBSx6wEJIYQQQgjpiSQ6TbEtcXFx+OKLL6Curs6+ASfvp8bGRhw5cgTbt2+Hm5sbdu7cCX19fQiFQjx48ACJiYlITExEdHQ0Hj58iCFDhmDkyJEYOXIkRo8eDVNTU2k/BUIIIYQQQiQhjMPhuHd4GAOeT5M7deoUvvvuO+jq6mLjxo0YN25cR52OdDENDQ34/fffsWvXLgwbNgwbNmyAnZ3dax9TXV2N5ORkREdH49atW4iPj4ecnBxGjhwJZ2dnjBo1CiNHjhRba44QQgghhJBuovPCWAuRSIQzZ85g27Zt0NDQwKpVq+Dp6Umd83qo0tJSHDlyBD///DPs7e2xYcOGd2rqUlhYyIazxMREJCUlwdTUVCycDRo0qN3ruRFCCCGEECIlnR/GWohEIly8eBG//vor7t+/Dx8fH/j5+cHMzKyzSiAdKDIyEgcOHEBQUBCmT5+OFStWwMbGRuLnEQgESElJYcNZYmIiCgoKYGdnx4azUaNGQUdHR+LnJoQQQggh5B1IL4y19vDhQ/j7++PYsWOws7ODt7c3PvroI6iqqkqjHPKWnj59irNnz+Lw4cPgcDj47LPPsGDBArH10jpDUVER7ty5w157FhMTAwMDAzacOTs7Y/jw4ZCR6ZDeNYQQQgghhLRH1whjLRoaGnDu3DmcOnUK0dHRGDduHGbOnImPPvoIKioq0iyNvEJ+fj7OnTuHs2fP4uHDh5g2bRq8vb3fuvNjR2jdHKRlimN+fj5sbGzYcObq6gp9fX1pl0oIIYQQQt4fXSuMtVZRUYGLFy/i7NmziImJwbhx4zBp0iSMHz8effr0kXZ57y2RSISkpCQEBwfj8uXLePjwITw9PTFz5ky4u7tDTk6iy9Z1GD6fj5SUFDacxcXFQV5eXqw5iK2tLZSUlKRdKiGEEEII6Zm6bhhrrby8HFeuXMH169cRGhoKPT09TJgwAePHj4erqyuNmnWw4uJiBAcHIygoCKGhoejVqxcmTJiASZMmYcyYMZCXl5d2iRJBzUEIIYQQQkgn6h5hrDWRSIR79+4hKCgIwcHBSExMxJAhQ+Dg4AAnJyc4OjrC0NBQ2mV2WyKRCPfv30dsbCxiYmIQFxcHHo8Hd3d3NgAbGxtLu8xOUVtbi3v37rGNQW7duoX6+nrY2tqya585OztDW1tb2qUSQgghhJDup/uFsRfV1tbizp07iImJQWxsLOLi4qCsrMxOMxsyZAhsbGzoeqA2iEQi5OTkICUlBSkpKYiLi0N8fDwMDAzEwu2gQYMgKysr7XK7hMLCQrGFqePi4mBiYiIWzqg5CCGEEEIIaYfuH8bakpWVhbi4OCQmJiI1NRXJycmQlZXFkCFD2HBmZWUFc3Nz6OnpSbvcDicUCvH06VPk5OQgPT2dfU0yMjLA5XLZ18Xe3h4ODg7o1auXtEvuNpqbm5GZmfna5iCjR48Gl8uVdqmEEEIIIaRr6ZlhrC2FhYVIS0tDcnIyUlNTkZmZidzcXDQ2NqJfv34wNzeHubk5+vXrB1NTUxgZGYHL5YLL5Xb5UY7GxkaUlJSgsLAQRUVFyM3NRU5ODnJzc5Gbm4unT5+Cy+WiX79+GDRoEBu+rK2toa6uLu3yexw+n4/bt2+z157FxsZCQUFB7Nozag5CCCGEEPLee3/C2KtUVVW9FF7y8vJQUFAAHo+H8vJy6OrqwsDAAIaGhuByudDT04OGhobYl7q6OrS1taGhoQFZWVkoKSlBWVmZPY+WltZLjR+amppQW1vLbvP5fAiFQjQ0NIDP54PP56OqqgqVlZWorq5mbystLUVhYSGKi4tRXFyM2tpacLlcGBkZQV9fnw2VLd/NzMygoKDQaa8peVlubq7YwtT37t2DlZUVG85GjhwJa2traZdJCCGEEEI6D4Wxf9Lc3Awej4fi4mIUFRWBx+Ph2bNnbDBqCUktoYnP56O5uRnNzc2orq5mj9MStFprHdhkZGTYxZFVVFSgrq7OBr2WkNdym66uLgwNDWFgYAB9fX2aVtgNvdgcJCoqCo2NjWwwGzlyJFxcXKClpSXtUgkhhBBCSMegMEZIV9HSHKTl2rPk5GS2OUjLFEcrK6suP22WEEIIIYS0C4UxQrqqluYgrdc+a2kO0hLOHBwc3osmNIQQQgghPRCFMUK6k6qqKiQkJLDhLCYmBoqKimLNQezs7KCoqCjtUglpF6FQyE7zrqysBMMwqK6uRnNzM4CXr61t2acFh8MRm86rqqrKXiMrLy8PNTU1dhq4trY2NDU1aXSZEEJIV0FhjJDurnVzkOjoaKSnp8Pa2pqag5BOJxAIUFJSgoKCApSUlCA/Px8lJSUoKSlBRUUFe31t66+GhgZoamqyYenFcKWsrCzWebStRdYrKirYnxsaGlBfX89ut4S3iooK9pxKSkrsOVt/aWlpQV9fHwYGBjAyMmK/c7lcyMvLd9CrRggh5D1GYYyQnqampgZJSUlsOIuMjISMjIzYwtROTk5QUVGRdqmkm6msrER2djb7lZubKxa6ysvLweVy0adPH+jr67Pf9fX1oaOjA01NTWhoaIgFIFVV1U5/HrW1tS+FwqqqKlRUVKCkpATFxcUoKChgv/N4PPTq1UvsOfXt2xf9+/eHhYUFLCws2AZMhBBCyBugMEbI+4Cag5D2qq+vR3p6OrKyspCdnY2srCz256amJjZ8WFhYwNzcHAYGBmKh68UlPHoChmHEQlrLeo6tg6mSkhIsLCzQv39/NqT1798fgwYNElvmhBBCCGmFwhgh76O2moMUFBRg8ODBbDhzdHSErq6utEslHaikpARJSUnsV3JyMvLy8mBpaSk26tMSMLhcrrRL7rJKSkrEgmtLkM3MzISZmSKsD9AAACAASURBVBmGDRuGoUOHYvjw4Rg6dCi9loQQQgAKY4SQFpWVlbhz547Y9WdKSkpizUHs7e1pAfFuqrS0FDExMYiNjWWDl0AgYMNBS1iwtLSk66MkSCAQICMjg33Nk5OTce/ePSgqKmLYsGEYNmwYHBwcMGrUKFozkhBC3j8UxgghbRMKhXjw4AG7MHV0dDQePnyIIUOGiC1M3bdvX2mXStrw6NEjREVF4datW7h16xaKiorg5OQER0dHNoD16dNH2mW+t54+fcqOSLaE5D59+sDZ2RnOzs5wcXGBqamptMskhBDSsSiMEULa78XmIDdv3oSsrKxYc5BRo0bRNTJSkJubi+vXryMqKgpRUVEAABcXF4waNQqurq4YPHgwXRPYhQmFQqSmpooFaBkZGbi6usLFxQUTJ06EmZmZtMskhBAiWRTGCCHv5sXmIElJSTA1NRULZ4MGDeqRjR2kqampCVFRUbh27RquXr2KqqoqTJo0CW5ubnB2dqYRyx6gZdmKiIgIXLt2DTo6OvDw8MCkSZPg7OxM00kJIaT7ozBGCJEsgUCAlJQU9tqzluYgdnZ27LVnTk5OdH3MWygsLMS1a9cQGBiIsLAwWFlZsW/Ohw8fToG3B2MYBnfv3kVgYCACAwORmZkJd3d3TJo0CZMnT4aBgYG0SySEEPLmKIwRQjpecXExEhIS2HB269Yt6OjoiC1MTc1B2lZeXo6zZ8/i5MmTuH//PsaPHw8PDw9MmDCBAu177NmzZ7h+/ToCAwMRHBwMGxsbzJs3D15eXm0ujE0IIaRLojBGCOl87WkOMnr06Pe2gUFDQwNCQkLw559/IigoCK6urvD29oanpycFVvISoVCI8PBwHDt2DJcuXYKdnR0WLFiA6dOnQ01NTdrlEUIIeTUKY4SQrqG6uhrJycnstWfx8fGQk5MTu/Zs5MiRPbY5CMMwCA8Px9GjR3H16lU4Ojpi3rx58PT0pDfUpN2qq6tx8eJFnDx5EvHx8ZgyZQp8fHwwZswYaZdGCOkAfD4fz549Q01NDWpra1FbW4uKigrU1tayt1VUVLD7CoVCsce23n6RpqamWOOnlm11dXWoqqpCVVUVWlpaUFNTY7e1tbWhpqYGPT09mjrfPhTGCCFdV2FhodjC1C3NQVqHs+7eHKS2thZ//vkn9u/fD1lZWfj5+WHWrFnQ09OTdmmkm+PxeDh9+jR+//13MAyD5cuXY/78+VBRUZF2aYSQ12hoaEBeXh6ePHmC/Px8FBUVobS0FM+ePcOzZ89QXFzMbispKaFXr17Q0NBgA5GmpiYbmNTU1KCpqQk5OTmoq6uLneefpjTX1NRAIBCI1VVfX8+GvpqaGlRWVrLb1dXVqKysRHV1NcrLy6GjowM9PT3o6upCX18fXC4Xurq60NPTg7GxMUxMTGBiYvK+T62mMEYI6T7a0xxk1KhR0NHRkXap/yg3Nxf+/v44cuQIPvjgA3z55Zdwd3fv1sGSdF2JiYn46aefEBgYiE8++QQrV66kjpuESIlIJEJeXh4yMzPx8OFD5OXlseHryZMnqKqqYoNKnz59YGhoyIYaPT09GBgYQFdXF7q6ulBUVJT202mTSCTCs2fP2NBYUlICHo+HZ8+egcfjIT8/n33OIpEIJiYmMDMzY593v379MHDgQAwYMKDLPkcJoTDWXvX19SgtLQWfz0dNTQ1qampQUVHB/lxbW4vKyko0NTWhtraWfVzLpwgt6urqoKCgADk5Ofa2F4eBtbW12U8wWoZ/W4aAW4Z/NTQ0oKenJ3YcQt5HRUVFuHPnDnvtWUxMDAwMDNhw5uzsjGHDhkFWVvatji8QCFBaWgpDQ0OJ1BsdHY3t27cjISEBn376KT7//HMYGxtL5NiE/JO8vDz89ttvOHr0KBwdHbFu3To4ODhIuyxCeqSmpiakp6cjMzMTGRkZePDgARvA9PX12bDROoSYmJi8d91R+Xw+njx5gsePH7OBNDs7Gw8ePEBubi4MDQ1haWkJKysrDBw4EJaWlrCxsYGmpqa0S5cECmPPnj1DXl4eHj9+jIKCApSWlqK4uBg8Hg+lpaXg8XgoKSmBSCSCnp4eNDQ02HCkpaUFdXV1drvlvtZrv6iqqopdcK+iogKBQCA27FtbW4umpiZ2u66uDvX19aiqqhILfy3DvzU1NaiqqkJpaSm0tbWhp6cHPT09dgi45VMTY2NjmJqaom/fvj32OhtCXtS6OUjLFMf8/HzY2Niw4czV1RX6+vrtOl5CQgLc3Nywbds2rFix4q1D3d27d/HNN98gMzMTX3/9NebNmwclJaW3OhYh76q+vh7Hjx/H999/j8GDB2Pr1q0YNmyYtMsipNtqampCSkoKEhMTcffuXSQmJiIjIwP9+vWDlZWVWJgYOHAgTRdup+bmZjx69EgszN6/fx/p6ekwMDBgm36NGDECI0aMgJaWlrRLflM9P4wJhULk5ubi/v37yMrKwuPHj5GXl4dHjx4hLy8PioqKMDU1hampKYyNjdkg0xJq9PX1oa+vD1VVVWk/lTa1DPeWlpayQ8ClpaUoKirC06dP2eeqqanJPk8zMzP07dsXAwcOxKBBg967T2DI+4fP5yMlJYUNZ3FxcZCXlxdrDmJra9tmONq/fz9Wr14NWVlZGBkZ4fjx47C3t2/3uTMyMrBp0yZERkZi1apVWLlyZU+fckG6EYFAgKNHj+Lbb7/F8OHD8d1332HIkCHSLouQLq+oqAiRkZGIjIxEXFwcHjx4gP79+7PBYOTIkRg6dCh9GN5BhEIhMjMzxcJvUlIS9PX1YW9vDxcXF7i6usLKyqqrT//vOWGs5dPw9PR0ZGRk4P79+3jw4AGysrJgaGiIQYMGYeDAgWwYMTMzg6mp6UsXM/ZUJSUlbBDNy8tDbm4uMjMzkZ6eDoFAACsrKwwaNAiWlpawtraGjY0NjIyMpF02IR2mvc1Bpk2bhkuXLgEAOBwOVFRUMHnyZPz222+vXefr8ePH2LhxI4KDg7FmzRp8/vnn9J8y6bLq6urwyy+/YPfu3Zg0aRK2bt1K02cJaSUvLw+RkZG4efMmoqKiUFZWBmdnZ4wePRpOTk4YOnQozXaQMpFIhIcPHyI+Ph43b95EZGQk+Hw+XFxcMHr0aLi6umLIkCFilwZ1Ad0zjDEMg+zsbCQkJODOnTtISEhAcnIyjIyMMHjwYLFgYWlpSX85/kF5eTnu37+PjIwMZGRkID09HSkpKeBwOLC1tYWtrS3s7Oxga2tLHd5Ij1VbW4vExETEx8cjNjYW8fHxEIlEaGxsZNsCt1BUVIS8vDx2794NPz8/sU/dGhsbsXv3buzduxfLly/HqlWr3psPfUj3x+fzsXv3bvz222/46quvsGrVKrGp94S8L5qbmxEVFYWrV6/i8uXLqK6uhqurK/vG3trauquPuBAABQUF7AhmZGQkSktLMWnSJHh4eGDChAld4bqz7hHGmpqacPv2bYSHhyMqKgoJCQnQ0dERCwkjR46kNzwSlp+fzwbeli91dXU4ODhg9OjRcHNzg5WVlbTLJKTDJCcn44MPPkBjY2Ob96uqqmLAgAH4888/YW1tjaioKCxevBiDBg3C3r1739tFq9sjLi4Ou3btgpmZGerq6lBVVYXvvvuuQzv8lZWV4ccff4S7uzvc3d077Dw9QW5uLr788kvk5ubi8OHD1OSDvBfKy8sRGBiIK1euICQkBBYWFpgyZQo8PDwwfPhwaZdHJCA/Px9Xr17FlStXEBkZCVtbW3h4eGDq1KmwsLCQRkldM4wJBALcvn0bERERiIiIwO3bt2FpaYkxY8Zg9OjRsLe3f+30INJxcnJyEBsbi/DwcERERKCurg5ubm7s18CBA6VdIiESc/XqVXzyySeoqqp65T4cDgcyMjIYMWIE8vPzceDAAUydOrUTq+x+mpqaYGJigtDQUAwePBhNTU2YPn061q5dCxcXFwDPG6fY2dlJ7JyVlZW4desW5s6diz///BPTpk2T2LF7svPnz2PZsmXw9vbGli1b6HpH0uPU19fj8uXLOHHiBCIjI+Hu7g4PDw94eHiAy+VKuzzSgerr63Hjxg1cuXIFly9fhqGhIT755BPMmTOnM/spdJ0wVllZicDAQAQEBCAkJAT9+vVj3+C7urrSqFcX9eTJE0RERCA8PBzh4eGQkZHB1KlTMXXqVLi6ulLrfdKt/ec//8GOHTsgEonYqYkMw6CxsREKCgrQ19eHnp4esrOzYWZmht27d2PMmDHSLrvLy8nJgYWFBcLDw+Hm5gYAyMrKwr179zBr1izEx8dj9erViIqKkvi5zczMsHfvXgpjb6C0tBRffPEFsrKycPbsWfTv31/aJRHyToRCIcLDw3HixAkEBATggw8+wLx58/Dxxx9DTU1N2uURKRCJRAgPD8fx48cREBAAe3t7fPLJJ53xZ0K6YezJkycICAhAQEAAEhISMGbMGEydOhVTpkyha5O6qbS0NFy6dAkBAQHIycnBxIkT4enpiUmTJtE/cKTbWbVqFTIyMmBpaQkLC4uXmv+cPHkSq1atwvbt27Fo0SJpl9ttCAQCDB48GMXFxTh06BBmzpzJ3lddXY1p06YhKysLS5cuha+vL5SVleHv74/KykokJiZi165dMDExwS+//ILw8HB4eXlh3759EAqF8Pf3h5OT0yvPTWHs7fn7+2PDhg345Zdf4OXlJe1yCHljfD4fhw8fxv79+6Gjo4P58+dj9uzZ1FWaiGkZLT1+/DhiYmKwYMECLF++HObm5h1xujAOh/N83jzDMDeYTsDn85mjR48yo0ePZvT09BhfX18mICCAqaur64zTk05UWFjIHDx4kJk8eTKjpaXFLFiwgAkJCWGEQqG0SyPknYhEImb9+vVM//79mZSUFGmX0y3l5eUxDg4ODADmo48+YgoLC9n7Dh48yDg6OrLb3t7eDI/HYxiGYb7++mtm8ODBDMMwzN9//80oKSkxDx8+ZEQiEbNs2TLG2NiYaWxsfOV5TU1NmQsXLnTQs+r57t69y5ibmzObNm1iRCKRtMshpF1ycnKYtWvXMlwul5k5cyYTHR0t7ZJIN1FUVMRs2rSJ4XK5zIcffshcunRJ0v/23QCADu/vKBKJEBoaCm9vb5iamiIgIACrVq1Cfn4+Dh06hKlTp1LL5x6od+/e8PPzw9WrV5GVlQU7OzusX78eZmZm+Prrr5GZmSntEgl5Y42NjZg7dy6ioqIQGxsLGxsbaZfULZmYmCA6Oho//fQTbty4gZEjRyInJ4e9v6VLWWlpKSIiInDhwgX4+/tDTU0NTk5OaGpqgpaWFjQ0NNC/f39wOBxs2bIFT58+RVZWlrSeVo83fPhwxMbGIjg4GN7e3hAIBNIuifRQRUVFYBjmnY6RmZmJWbNmwdHREbKysrh79y7OnDnz2tFzQlozMDDA5s2b8ejRI8ycORPr1q2Dra0trl27JtHzdFgYq6urw2+//QZLS0usX78e9vb2yMrKwoULF+Dp6QkFBYWOOjXpYnR1dbF8+XIkJCTg2rVrEAgEGDt2LCZMmICQkBBpl0dIuzQ0NGD69OkQCoUIDQ2lRkJv6dGjRwAAGRkZrFixArGxsaiqqsLOnTvZfVrCWH5+PgQCAfz8/ODn54d169bh4MGDbf7/oa2tDXl5eWo33cG4XC7CwsJQU1ODmTNnoqmpSdolkR7o66+/hpGREX744QeUlJS80WMLCwuxZMkSuLq6wt7eHo8fP8Z3331H66eSt6aiogI/Pz+kpaVh06ZN+OqrrzBmzBjEx8dL5PgSD2OlpaXYsWMHBgwYgMDAQPz6669ISEjAsmXL6M0LgbW1NXbu3InHjx9j8eLF+PrrrzF06FD4+/ujoaFB2uUR0qbGxkZ4enpCS0sLp06doq5y7+DSpUuIjY1lt4cOHQo7Ozv2TT2Hw4FIJAIAmJqasqNjLdLT0/Hw4cOXjvv06VP06tWLGkx0AiUlJZw5cwYKCgqYMWMGjZARiauoqEBRURG2bt0KU1NTjB8/HkFBQey/DW2pra3F+vXrMXToUOjo6CAzMxOrV6+m2VdEYjgcDqZOnYrk5GR4e3tj1qxZ8PLyQm5u7jsdV2Lt7srLy7F161YcO3YMs2fPRkREhLR69pNuQF5eHjNnzoSXlxdCQkLw448/Ytu2bdi0aRN8fHwgKysr7RIJAfB8oXlfX19oamri2LFj9GfzHfXr1w/e3t44e/Yshg0bhqysLGRkZGDHjh0AAENDQ2RnZyM+Ph6amprw8/PDjBkzsGbNGigrKyM/Px87d+5Efn4+KisrkZKSgsGDB+Pbb7/Frl27XrlIsUgkQk1NDX3oIyHy8vI4efIkvLy88Nlnn+Hw4cNt7tfQ0ID6+nowDIPKykoAQE1NDQQCAQQCAWpqagAAVVVVEIlEYrcBz99gtx59a70Ie1NTE2pra9ntluO2aDnmi148R2svHuOfCIVC8Pn8du//IgUFBaiqqrZ7f3l5+Vc2xFJVVX1p1FhTUxMyMv//c3cZGZmXFrp98Zja2toAnr/x1NLSeu3PrY/X+md1dXXIycm1WVN7VFdXA3jeTAEAQkJCEB8fDxkZGfj6+mL58uViazlGR0fDx8cHTk5OSE5OhqGh4Rufs7vLycnBiRMnICMjAxcXF1RVVXXoUivl5eU4duwYampq4Onp+V5N25eVlcWiRYswd+5c7Nu3Dw4ODvj222+xZMmSt5qd8c7dFBsbG7F//37s3LkTs2bNwsaNG6kbInkrd+7cwVdffYWysjLs2rULEyZMkHZJhGDz5s0ICQnBjRs3oKSkJO1yur28vDzcvn0bpaWlKCgoAADMnz+fXUS+ubkZP/zwA/r06YNFixZBJBLh0KFDSE5Ohq2tLRYuXAgZGRmEhYWx/xE+fPgQzs7Or1xaoLa2FpcuXcKTJ0+gpaWFMWPGYMCAAZ32nHuylvUmy8vLIRAI2DfRLUGo5c24rKwsNDQ0APz/N+qtg0hLaJCTkxNbzubFN/MtQQF4OcioqamJhfEXg0iLNw00r9P6eb2NFwPlP3nTIPliIBWJRC+tnfhiDa0Db2VlJXvtVuufWx+Xz+dDKBSK/VxfX4+GhgY0Njairq4OKioqUFRUhJKSEpSVlaGoqAgVFRX2d9HyOrYEusjISDx48KDN59kyM8HR0RHLli3D7du38eeff+LXX399bzulPnr0CB9++CGuXr0KQ0ND7N27FydOnBC7Pr+2tvaNgv/rFBcXY9GiRbC1tcWdO3dw48YN3Lx5E46OjhI5fneTm5uLRYsWQVFREYcPH4axsXF7H/rure3Pnz+Pr776CkOGDGGnJhLyri5fvow1a9bA1NQUP/30Ey0mTaQmLCwM3t7euHv3Li0A2sW0hLE3vZ6ESF5RURGGDx+O3377DW5ubmIjJ4QA/z/wNTc3o7q6mh1RbD1i2hICW64hfV0zHjk5OQiFQsjIyMDS0hKhoaHvdYv6Xbt24cKFC4iJiWFv8/Pzg7+/PwDg5s2bSE5OxooVKyRyvv3792PhwoXsBydubm7o27cvjh49KpHjd0dCoRC7du3Cf//7Xxw6dAhTpkxpz8PevrV9ZWUls2DBAsbKyoqJjIyUZIvHDlNcXMysXLmSaW5ubvdjhEIhc/78+VfeX1RUxPj7+zM3bnTKygAvqaioYJKTkxmGYZi6ujrmxIkTjL+/P3P69GmJtx0OCwvr1FbGAoGA+fnnnxkul8vs37+f2iiTTldeXs706dOHCQ0NlXYppA3nz59n1NXVabmMLuLatWuMqakpU1VVJe1SSA9gYWHBABD7UlZWZlRUVBh9fX3G09OT0dHRYX777Tdpl9olHD58mOFwOMzu3bvZ2x4+fMg0NzczCQkJTK9evRgPDw/m8OHDDMM8f491/PhxZsuWLUx8fDzDMM+XbYmOjmZCQkKYkJAQ5l//+hcTEBDQ5vmKiorEtlevXs0sXry4g55d93L79m3G2NiY2bVrV3t2f7vW9rGxsbC1tYWysjISEhLg4uLypoeQiqamJpSVlbFD6QBeOdQPPG+JunjxYixYsOCV+zAMg59//hn379+XaK3t8fTpU+zduxfW1tZobm7GRx99BGdnZ/zf//0f8vPz8Z///Eei5zM3N8emTZveudVse8nJyWHZsmWIj4/H6dOnMWHCBHZKEyGdYdOmTfD09IS7u7u0SyEvqKiowOPHj/HFF1/g0KFDdB1YFzBx4kSMGzcO3377rbRLIT1Ay9/plmmjw4YNw7Zt25Camoo//vgDsbGxOHfuHD777DMpV9o1eHt74+OPP8bq1asxbtw4ZGdno3///pCVlYW1tTWsrKzg7OwMLy8vMAyDFStWYOzYsZg/fz4mTpyI69evIzMzE1988QU2btyIsrIyGBsbY86cOThx4sRL53txFPL+/fuYM2dOZz3dLs3Ozg5xcXH4448/8M0337T/gUw7RsZEIhGzbds2xtDQkAkMDHy32NgFZGVlMatXr37tPpGRkYyqqupr95k8eTLz888/S7K0f9TQ0MB8+OGHTG1tLcMwDJOWlsYYGxuzo0cpKSmMnZ2dxM97/vx55rvvvpP4cf+JQCBgtmzZwvTu3Zu5efNmp5+fvH/S09MZAwMDpqysTNqlENJt8Hg8hsvlMg8ePJB2KaSbs7S0ZCZPnswcP36cKS8vZ2+PiYlhuFwuExMTI8XquiaRSMQcPnyY0dbWZlRVVZlTp06x940ZM4bZt28fwzAMc+HCBcbFxYXZvn07s337dsbc3JyZNWsWwzAMs3jxYmb58uXs49auXcs4Ozu/9rx3795lvvzyyw54Rt1baWkpM3ToUGb79u2v2+0G0M5uis3NzVi8eDEyMjKQmJjY6fNynz59ilOnToHL5WLOnDn466+/UFJSAhcXFzg5OSEqKoodyeLz+Th79iwUFRUhFArh7e0NDocDPp+PCxcu4OOPP0ZlZSUmTZoEHR0d7Nq1C1999VWb523rwt9XCQgIQHx8PD7++GPY2dmxtwcFBSE7OxtycnKYO3cuNDQ0kJqaisDAQHh4eKBv3744ffo0SktL2TqioqKgpKSE7OxscDgczJs3T+xc/v7+sLGxgYqKCgDA2NgYfD4f27Ztw4YNG/DXX39h4cKFAJ5fcHvx4kWMGTMG586dQ1lZGfz8/GBmZgaBQICgoCAMGzYM9+7dQ1JSEhYsWAAdHR3873//A8Mw8PPzY9vCTps2DV9//TV8fX2hr6/f/l/gO5KTk8PGjRvh7OyMWbNmYc+ePS+9JoRI0vbt27Fq1Sro6OhIuxRCug09PT0sX74cu3btwqFDh6RdDunG0tLSXupcm5+fjxkzZuDYsWPvbaOI1+FwOPj0008xfvx4zJ49GwsWLICdnR369evH3g8At2/fhru7O9auXQsA7PeWfVq/9x05ciTOnz//ynPyeDz8/fff2LNnT0c8pW5NV1cXgYGBcHJygqWlJTw9PV+57z+mjebmZsyfP59d60UaF0gaGxsjLCwMqampUFJSwtChQ7F+/XpYW1sDeP5mvcWCBQugpqaG+fPn49ixY7h06RKamppw4cIF+Pj4oKamBgYGBhg9ejSsra2xePHid67vypUrAJ63ZB43bhzbhvfLL79EQUEBli5dCg0NDQwdOhQ8Hg82NjY4ceIEEhMToaqqikGDBmHdunUQCoWIi4uDl5cXdu3ahUePHiEuLu6l8/35558YNWoUu62hoYGzZ89ix44dGDFiBKytrbF06VIAwIULF7Bo0SL88ssvsLKyQlZWFpycnFBdXY3g4GB8/PHH2L59O+Tl5VFcXIxp06bhwIEDsLGxwYULF9h208Dzv6TDhw/HyZMn3/k1extjx45FeHg41q5di2PHjkmlBtLzFRQUIDAwEEuWLJF2KYR0O1988QUuXrwIHo8n7VJIN/ZiEGMYBj4+PlixYgV1Wm7Dtm3b2J/79OmDo0ePorm5GSkpKeztLWFMTU0N0dHRYo9/1TpZfD7/lU3UamtrsXfvXmzcuJENcLQIvDhDQ0OcOXMGn332GQoLC1+53z+GseXLl6Oqqgrnz5+X6sJ5y5Ytw6VLl8AwDIYNGwZdXV02rQcHB7MjJXPmzIGDgwOam5uhpKSEtLQ0KCgoiCVSBQUFtsVq6za5b8vd3R2enp7w8/NDbW0tsrOzkZaWhkOHDmHRokUAgLlz50JfXx8//PADAIi1yG695oeTkxNsbGzg4OCAb775Bvv27RM7F8MwSEpKeikUDx48GPPmzUNpaSn27t2L0tJSAGCvefPx8cHkyZNx/PhxiEQiBAQEwMPDAwYGBpg2bRomTpwIX19fpKamYs2aNRgzZgxmzpyJtLQ0sfMYGRkhISHhnV+zt2VlZYXQ0FCsX78e165dk1odpOc6d+4cPv7445fW4ukpsrOzxd4op6SkvPb62Z6koKAAeXl57HZOTs5bdWN89uwZ2wGOiNPR0cHkyZPx999/S7sU0oP89ddfqKmpwZo1a6RdSpd0+/ZtXL58md2uqqqCqqoqO1NLTU0NZWVlqKurw+TJk3Hjxg3s27cPDQ0NSElJwblz59jHtl7a4Pz58/jyyy9fOl9zczNWrlyJ8ePHIzU1Fbdv38avv/6KjIyMDnyW3ZO9vT0WL16M9evXv3Kf14axgwcPIiYmBmfOnGHXdZCWSZMmoampCTdv3sTVq1cxYcIEHDlyhF1MsmXK3tSpU3H9+nUEBARAQUEBzc3Nrzzm2yzM9joKCgqQl5dHfX09kpKSoK2tLXaOUaNGiX1K8SqKioqvfL1bFspsvUZKfX093N3d8cMPPyAxMRFKSkovLfTXUoeioiIGDRrEvhlrXV+vXr3EHqOsrPzSeiSqqqpSf+M2cOBA/P333/Dx8UF2drZUayE9z8WLFzF9+nRpl9EhTp48CSsrKyQlJaG+vh779u3D0KFDX/uJXU8RHByMwYMHsx/iw+r6dwAAIABJREFUnDp1CpaWlrh3794bHefq1aswMjJCcnJyR5TZI3h5eeHChQvSLoN0YSKRqN2Nd0QiETZu3Ijdu3e/0eUj75MhQ4bg/PnzWLduHb7++mts2rQJFy5cQJ8+fQAAM2fOxLFjx3D48GEMHToUR44cwY8//ghDQ0McOnQIK1euZI+VlZWF77//HitXrsT06dPx4YcfvnS+H3/8EWFhYfD19cWsWbMwd+5cXLlyBUOHDu2059ydrF27FiEhIa9cO++V14zl5ORgw4YNuHXrltgCjNIiKyuL//u//4O/vz/09PTg7+8PY2NjbN26FZ988gm735QpU7B69WpMnjwZAQEBrz2mpMNYa/r6+igpKRFbZE9JSemdp3kqKChAR0dHLBAlJCRAQUGBDVPnz58Hl8tFeXl5m4tRvmrYuT2vR1lZGUxMTN7hGUiGg4MDNmzYgIULFyIyMvKlKQ2EtNbY2NiuD5SEQiESExPh6uraCVV1vnnz5rGfLCsrK+Ozzz5r81NPSUhJSUFjY6PYNbRv6uHDh+DxeHB2dn7nesaPH4/Bgwez23Pnzn2rT9k9PDygp6f3zvX0ZG5ubliwYAFEIhG9eSZtqqurQ+/evTF58mT4+vrC3d39lf+Ph4eHQ1NTUyL/DvRUracptmXBggVi3cEXLlzI9hZ4kb29/T925F67dq3YtWbk9dTU1LBo0SIcPnwYu3bteun+V/4ruWbNGqxZs6ZLLeTs6+uLCxcuYNSoUVBWVob3/2PvvqOiurq/gX+p0qQoTZAiIFIMCioWEEEURYkxKhofoxKjkkiWLcYSIw+KGhR7iV0DlkexRgU7HRUliIUuTRCk987Mfv/gN/dlpNgF9XzWmgUzc++dc2eGy933nLP3jBmIiIjg5o4VFRUhKCgIMjIyqKqqQkpKCurq6sDj8biU9oIrMYIu25aq0Qvw+fxXpnIXVJgHGk/kGhoaUFNTAxsbGxgYGODYsWPcsv/++y/mzJkDoHGeV0JCAogI//77LwBww174fD5X2b4ltra2QsUQdXV18eLFC1RWVgJoDNi0tbWFhmAKup2fPn2K2tpajB49utlrlZeXg4i4Mb88Hq9ZO7KysmBpadnme/KxuLm5QVRUVOg9ZpiWLFiwAGZmZtixYwdycnJaXS4+Ph5aWlrcBZRPARHh6dOnzfarpKQEUVFRKCwsFHq86cnx65wo19XVIS0trdkog5qaGlRXVyM7O7vZFe7s7GxMnDhR6LgENJYTaVqiorq6GsXFxSguLkZtbS33O4/HQ35+PiZMmIDMzEyhbbwsMzMT6enpzR5/8eJFs6GEL+9vW/svKE5bVlaG2NhYobIogvXKysqQlpbW4rppaWmor68Xeryurg4VFRWoqqpqcb3KykpkZmYKPUZEiIuLQ3Z2dpsjPToSeXl5qKmptVm0l2Fqampw+vRpTJo0CV26dMGcOXNw586dZudd/v7+cHZ2bqdWflkaGhqEjnXM+zN58mT4+/u3+FyL/4kePXqE+/fv45dffvmgDXtT3bp1w+LFizFx4kQAjdXFf/75Z+55wR+zi4sLNm7ciB9//BG3bt1CSEgIDh06BD09Pfj6+qK6uhrjxo1DZGQkPDw8WrxiHhcXh1OnTkFdXR1HjhxBUVFRs2Xu37+P4uJiREVFITMzEz4+PtDS0sKFCxcgLi6Oy5cvIyAgAJs2bcKOHTswbdo02NraAgCWL1+OU6dOYeTIkVBVVcXw4cNx/fp13LhxA0VFRQgNDUVsbGyL78P8+fMRFBTE3dfW1sa+ffuwdOlSHDlyBN7e3jh37pxQT9eZM2fg6emJP//8E5cvX4aYmBgCAgIgIyOD69evIz8/H2fPnkWPHj3g4+ODnJwchISEoLCwkKvoXl1djfj4eEyZMuXNP7wPQEREBBs2bICnp+dHq3/GfJp4PB4eP36MFStWQE9PDxYWFtizZw8KCgqElsvMzESPHj3aqZVvLi4uDitWrMDz58/h4uICd3d3AMCVK1ewaNEidO7cGTNnzhSaS/Amtm7dCm9vb0RFRWHo0KFc8p5Dhw5BU1MTO3fuxJAhQ5rVUomPj0d2djZCQ0Nx7949EBE2bdqEU6dOwd3dHWPGjEFdXR2Kioowffp0mJqaoqqqCr/88guOHTuG+vp6bht37tzhjkFNZWdn49dff8XTp0/x3//+FzNmzADQ2Hvv7u6Oq1evwsnJiZun+yZu3LgBTU1N/Pbbb1i4cCGcnJxgZWUlFBReuXIFS5cuxTfffCP0f+jvv/+Gu7s7YmJiYG9vj7/++gtA4zBJDQ0NbvjP6NGjha4s79ixAydOnICXlxfs7OxQVVUFAPjhhx9QV1eHwMBArFy58o33pb3o6uo2CywZpikREREQEXfR4/Dhwxg1ahRUVFQwb948REdHA2icD8WyJ354iYmJSEtLQ3JyMsLDw9u7OZ+dr776CllZWSgrK2v2nAjQWGcMwHDBg4sWLYKioiL++9//frxWfsY+xFCNRYsWYeHChdDR0WlzuYaGBkhISCAuLg7Gxsbv9Jr79u1D165dMWnSpHfazvtmYWGBLVu2cIEuw7zM1dUV+/fvF3pMVlYWDQ0NMDQ0xKxZszBt2jTcuHEDAQEBn0Rva319PWxtbXHt2jXIycnh3r17OHjwIPbv3w8PDw+oqKjAzc0NXl5eiIuL4zKQamtr4+DBg3BwcOCOD4mJic1GQQQGBuK3337jeu6jo6MxePBgxMTEQF9fHzIyMvjf//6HcePGNZvHCgBKSkq4ePEihg4dCj8/P2RkZGD27Nmor6+Hrq4udu7ciR9//BGFhYUwNTXFH3/8gZKSEqHATktLC/v374ejo2Oz/R8zZgz++usv6Orq4tmzZ5g/fz7Onz+P2bNnY968edDT00NoaCgmTJiAtLQ0aGtrY9iwYZg6dSpXKFZHRwf79u3jRgo01bNnTyxZsgSurq4oKyuDiYkJfvvtNyxYsADa2tpYs2YNXFxcEBISgvHjx6O4uBgxMTGYOHEikpKSICYmhvT0dPTs2RPBwcGwsrJCz5494ebmhoULF+LSpUuYN28eMjMzceXKFdy9excLFy4EEcHAwADu7u6YPXs29PX1ERcXh65du+LatWufTCa5KVOmQF1dHRoaGu3dFKYDqqurg6enZ7PeYwFxcXFISEhAVVUV5eXlOH/+/Gc7fJz5chgaGsLf3x89e/YUPBQoIiJi3+KcsatXr8LPz+/jte4z9yHGzG/cuBFbtmzBjz/+CGVl5VaXEwxraWvY4+sIDw+HvLx8hwvEAGDChAm4evUqC8Y+sMrKylbT1rY13BdonB8gGM7bkqbZm14mGA7XmpKSklZ7Ruvq6lBZWdnipFlBL8fjx4+xatUqLF++HHp6elBUVERFRUWz4KKjefToEerq6rh2WlpackOIPTw8UF5ejrNnzyI2NpbrZXkTFy5cELqAY2FhAU1NTVy/fh0LFiyAjIwM9PX120w4JOidF8xjPX36NABg27Zt+OqrrwA0Jg7avXs3vvvuuxYTibQ0l7WoqAj37t2Drq4ugMYA88KFCwAay3kMGDCACyL37NkjVP7kdUlKSkJRURFA47C7MWPGICYmhnteMP+3e/fuKCkpQW1tLS5dugQDAwNu7ouuri769euHgIAAWFlZQUJCgjted+vWjfvenzt3DqKiotz74+XlBVNTU8jJyWHw4MHo06cPNmzYIDQ/+lMgGHrKMC97VQp0Pp8PMTExVFZWgs/ntzlUmWE+dc3+Q1VUVCArK4ubh8V0TBISEli6dOkrs6D5+PhAT08PJ06cgJub21tfpdTX1++wk2ctLS2xdu1a3Lx5s9lzFRUVrV554/F4LXYXC7QVfBBRm6mtq6ur28wU1VYAUVtb2+bJc2lpaavBdX19fZvZLsvLy1uddyKYI9MaWVlZSEpKtvicqKhom6ngpaWlhco5vKytEhNSUlJtltVQUFBo9YKHpKQk1wPWFhEREYiIiEBRURE8Hq9dy3i8rsLCQmRnZ7fY837t2jX8/fffOHLkCNLS0nDnzp033n59fX2z74Ompmarf08tEQRSZWVlsLa2xty5c1tcrra2FsbGxli1ahX27t3b4jaaKioqQklJCcrLy4USTPF4PFRUVMDe3r7plcf3olOnTi0mRGqqpb+h13nPSktLYW5u3uL7c+7cOWzevBmurq64e/cudu7c+eaNbwfFxcWYM2dOi5nYGKaiogK7du0SekxERASdO3cGj8fDmDFjMHfuXNjb28Pa2rpDJJJjmHfB5/ORm5sLVVXVZs81C8by8vKgpqbGMiB9AkRERKCpqdnmMq6uru+leG23bt3eeRsfioaGBjIzM4UKVAvIyclBQkKixfXExMTaPLmSkZFp84p/WwGEhoZGm8GHoqJiq9krO3XqxJVqaElbwYeEhESbPTqdO3dutZdAXFz8s/2Ht2jRombzjmRkZMDj8WBoaIhffvkFU6dORVpaGqZNm/ZJZOc0MzNDYWEh9uzZwxV5P3XqFCZNmoRFixZh9erVkJKSQl1d3VvNqRw+fDhcXV1RU1PDfZezs7MxfPjwV6zZSFxcnAtCBgwYgN27d2PGjBmQl5dHeXk5fH194ebmhszMTCQkJODSpUv46quvMHnyZO41mm6jKV1dXSgpKcHDwwObN28G0DjJf+jQobCwsICXlxcOHjwIERERPHjwAHl5ee88vO/ff//Fxo0bATRejBG8p01/2tnZYcOGDSgoKOB6wLKysloNQgUsLS2xa9cuuLq6okuXLqiursaBAwcwbdo0REZG4rfffoODgwP69++PLVu2tHpM60iePXv2yv9PDAM0/p9uaGjA2LFjuQC+6TG4f//+uHv3boe9IMwwryMuLg7q6uqtX7gmolv0f1JTU0lPT48Y5lPx+PFj+uqrr9q7GUwH9uuvvxIAEhcXJ2lpaTIwMKDNmzdTTk6O0HL19fUkJydHlZWV7dTSN7Njxw4SFxenwYMHk4ODA927d4+IiOzt7cnQ0JCWLFlCCxYsIC0tLTp37hylpaWRrKwsbd++nXg8HkVGRhIAunDhQrNt8/l8mjlzJs2dO5fKysro6NGj5O7uTkRE8fHxJCYmRgcPHiQej9di22xsbOjbb7+lY8eOUUFBAZmYmJCWlhb95z//ocmTJ1NJSQmVlZXR2LFjqaSkhIiIFi1aRFpaWpSenk5ERI6OjjRmzBg6cuRIs+2fP3+epKWlqU+fPjRq1Ci6dOkSERGFhYVR586dqX///vTdd9/RihUriIgoNzeXevToQYsXL6b6+npKS0sjOTk52rZtW4v7YGJiQuPGjaOoqCj6888/acmSJURElJWVReLi4uTp6Ul8Pp9OnDhBACgiIoKIiJYsWUKTJ0+m4uJi8vf3p3nz5hERUUFBAXXu3JnWrVtHfD6fdu3aRaKiopSSkkJlZWVkbm5OGhoaNHXqVJo4cSLl5eVRfn4+DRw4kLKzsykuLo6cnZ1f74vRzsrLy6lz586tfjcYpry8nCQlJcnBwYHOnDlD1dXVrS575coVsrS0/Iite/9u3rxJDg4OdPDgQSIi8vPzIysrK7p69Wo7t+z9unv3Lk2ZMoX+97//vdF6jx8/JnNzc6qtrf1ALWt/7u7utHDhwpcfvgW0kMCjoqICGhoaKCkpYb1jzCfhxo0b2LBhQ4vDFBkGAFasWIFDhw5h1qxZcHFxgZGRUavL2tjY4I8//oCDg8NHbOHbS0lJQXJyMiwtLdGlSxcAjUNsIyIi0L9/f8jLy+P+/fvo378/njx5wg1x1dbWxrNnz7jtGBsbt9gjGxkZicTERPTp04cr6BkdHc31COnq6jYrGA8Aubm5ePToEYYNGwZJSUlUVFQgLCwMEhISsLW1hbi4ODIyMlBQUABtbW2oqKhw25WSkoKpqSkKCgoQHR0NGxubFnuas7Oz8eDBA1hYWAj13mdnZ+Pu3bvo0aMHzM3NAQCxsbHc0OHu3btzQzwBQE9Pr1lPt6mpKVasWAElJSXo6OhwNcoSEhK4+Ss9e/bk0rdLSkpy8+BiYmLw6NEjGBkZcfP4nj59ys2r7NGjB5faXkZGBsbGxqiurkZoaChERERga2sLSUlJ1NfXIzU1FampqZCTk4O1tfUHrY/5vvj7+2PLli24detWezeF6aD4fD7Ky8vbHN4uwOPxoK+vj5MnT2LQoEEfoXUfxqBBgzB9+nRuJEO3bt1w8OBBjB07tp1b9n5ZWlpi3rx5cHFxaXO5pKQkLnFUWVkZzp8/32rts09dVVUVDA0Nce3atZengQWKiIjYt5hN0cjICGfOnBEqkMkwHdW6detQVlbW4jBFhgEa51d16dLltU5kt27dioSEBOzbt+8jtIzpqExNTeHu7t5hSnl8SlxcXDBgwADupJNh3tXff/+NQ4cOcRcsPkXDhw/HxIkTub8LPT097Ny587MLxmxsbDB79myu3EhL0tPTMWPGDISGhn7ElrUfT09PxMXF4X//+9/LT7WeTXHUqFE4d+4cC8ZeITExEevXr0fXrl25g4Obmxv09PQ+eluioqJw5coVrFq16pXL3rlzB2fPnoW0tDRGjBiBYcOGtbl8XV0dNmzYgCtXrkBdXR0eHh4wMzN7X01/Z+fPn+fmcjBMS1rquWnNpEmTYGFhgU2bNn22c+iYtpWWluL58+eIjY1FXV1dq4lrmOZKSkpw+fLlt6rvxjCtmTFjBg4dOoRt27Zh0aJF7d0cAMDRo0fB5/MRHh6Or7/+GuPGjUNVVRW8vb2hr6+PBw8eYNq0abCwsHjjbV+4cAHPnj2DmJgYiouLuZIfdXV1OHToEDp16oSQkBAsWLCA2/6xY8fA4/EQEREBJycnjBs3DkBjT3VWVhaePXsGeXl5LF68GOLi4rh+/Tr8/PywYsUKrF+/Hrm5udixYwdiYmJw4MAB6OjoYMeOHejUqROICD4+PlwNyD59+gj1Yu3ZswdiYmKoqalBQUEBd06ckZGBI0eOwNDQEOHh4Vi9ejVkZWXxww8/ICkpicsSGxsbixMnTmDbtm1QUlICj8fDvn37IC4ujtjYWAwfPhzffPMNcnJy8PfffwNo7Fk8dOgQ7O3t4eHhAaAx83dcXByICKWlpVi6dOnbfrzvzYMHD7B7927cu3ev7QWpyZwxIqKYmBjS1tammpqajzCKsmNLSEho8XEej0f6+voUHh5OREQlJSVkY2NDwcHBr1z3fYuMjKQxY8bQ0KFDX7lsQ0MDdevWjcrKyojH45Gdnd0r11m1ahUdOnSIQkJCaPTo0aSqqkqlpaXvo+nv7M6dO6Snp8fmJjDv1dSpU2nz5s3t3Qymndy5c4du3LhBN27coKSkpPZuziflzz//JBcXl/ZuBvMZSktLI3V1dQoKCmrvptD69evp3LlzREQUFBREMjIyxOPxaMuWLfTdd98REZGvry85Ojpy69jZ2dGuXbu4+z169KDLly8323ZVVRVJSEhQXl4eEREpKSlxx6Hp06dz55bbtm2jQYMGERGRl5cXnTlzhoiIgoODSVpamhoaGujcuXM0YcIEImqcBzx+/HiaPn0695yoqCidPHmS6urqyMXFhfr370937tyh6upq6t27N508eZKIiDw9Pbk5w1VVVdS7d2/asGEDERFt3LiRtm7dSkREdXV11L17d/L19SUiImdnZ9q+fTsREf3888+0evVqIiI6duwYmZmZEVHjXO3o6GgCwO2zq6sr7du3j4iI8vPzSUNDg44fP058Pp9+/vlnMjU1pZiYGMrOziZxcXF6/PgxERGZmppSRUUFERFt2bLltT/PDyU3N5f09PTIz8+vtUVutRqMERGNHz++Q+xIe7p9+zZNmjSpxecyMjIIAN2+fZt7LDY2lk6cOEFERMnJyTRs2LCP0UwiItq+fftrBWPZ2dkEgLKzsykrK4ucnJzaXL68vJz7oyIiKi4uJlFR0Q5xMOTz+TRs2DA6fPhwezeF+cw8fPiQNDQ0uMQSDMO8WmFhIamrq9OTJ0/auynMJ87c3JymTZtGFy9epKqqKu7x4OBgUldXp3///bfd2lZXV0ddu3YlPp/PPZafn09EREVFRZSWlkalpaW0fPlyLuAgev1gjIgoOjqaiBoTEikrK1NwcDDFxcXRwIEDuWV4PB4VFRVRfX09de3aVeiitKA9AwcO5IIaIqLQ0FACQC9evKD09HQCwCVP2bNnj9B564wZM8jLy4t4PB7JyckJne/u3r2bVFRUiMfjkYKCAmVmZnLPWVtb09GjR4moMYAuKiqijIwM+uabb8jV1ZWIGoOxPn36cOvk5eVxwVhBQQGJiopSRkYG9/yKFSvI3NyciIjWrFlDY8aM4Z7T19enixcvcq89ZswYSktLo/Ly8hbf24+luLiYBgwYwAWgrbgFAK1m6Ni4cSO8vLzw9OnTd+6iexfZ2dnYtGkTdu3ahd9//x3jx48HANy7dw9bt27F9OnT4evrC6BxUvmiRYtw9OhRzJw5E3379sWff/7JTTRPT0/H1q1bMWfOHHh5eYHH4wFoTFm8bt06+Pj4wM3NDdXV1Xjx4gV+/PFHPHz4EMuXL29W96lbt27Q1tbGt99+i6CgIACAiYkJvv76a1RUVMDFxQXx8fFYvnw5srOzwePxsH//fnh4eMDFxQUZGRmoqanB33//jenTp+PSpUsYNGgQRowYgcePHwMACgoKsGHDBpw6dQpz5sx5ZZHE16GmpgZlZWWsXr0anp6e2LlzJw4dOoT9+/dzXb9NycnJYfr06dx9eXl5SEtLd4iUxXv27EFNTU2b45IZ5m2YmZnByckJq1evbu+mMMwnY9WqVXB2dmZ1Spl3lp+fj+PHj2Pq1KlQUlKCra0tDh8+DGNjY+zbtw9jxox5q/qJ78OzZ89QVVUlVDJEUMpCRkYGR44cwa1btzBgwIC3KisCNCZAWr9+PfT09CArKws+n4/4+Hih7YmKikJJSQmZmZmorKxssT0ZGRlCJXoESYaaJm8SeHlYvri4OKqrq1FYWIiKigqh7ZiZmSE/Px9JSUkoLS0Vqs3ZdE6fpKQkNmzYgKysLBgbGwu1sbW5f5mZmeDz+UJJm8zMzFpsM9BYpkiQjOns2bMgIhgbG+PMmTMtLv8x5Ofnw97eHkOHDn2t6UOtBmM9e/aEh4cHnJ2d2ywi+6FJS0vjypUrOHnyJMaNGwdHR0ckJibi1KlTWLRoEby9vTFr1iwEBQXBwMAAFy9exK1bt7Bv3z5s3boVnp6eOH36NMrLy/HHH39g4cKF2L17N3bt2oU9e/YAAObMmQNzc3PMnDkTT58+xfnz56Guro4pU6agd+/e8PLyapZlTEJCAgEBAVBSUoK9vT1mz56N0tJSyMnJQU5ODrNnz4aWlha8vLygoaGBJUuWYPjw4fDw8ICamhomTJgACQkJiImJ4fTp0+jSpQtu3boFTU1NfPvtt6ivr8eWLVugo6ODKVOmYPDgwW0WEX5dT548gbq6Os6ePYutW7dCV1cXxsbG2LZt22tNIo2KioKtre17L6j6pu7du4fVq1fD19f3k6gJxXx61q9fj1OnTiEsLKy9m8IwHV5gYCAuXryINWvWtHdTmM+A4MS/srIStbW13PwobW1t/Prrr7C3t4eTkxOOHz/+0dumrq6O2tpaXL58mXssIyMDJSUlWLZsGXg8Hr799tu3PjdJTEzEzJkzsXTpUmhoaHCPa2ho4MGDB0KdJI8ePYKqqirq6+tx6dIlofYUFxfDyMgIDx8+5B6vq6uDhIQEDAwMXrs9Kioq6Nq1a7Pt6OrqQlNTE6Kios3mQwkCrQkTJmDo0KEYMmRIs+22Fqjq6+tDQkKi2eu1lQVZIDc3FwEBAdi3bx9cXV2Rnp7+Orv4Xj158gQDBw7EN998g82bN79WwpmWq7/+n59//hkPHjzAlClTcP78+XaZxKykpARjY2OIiIhg0KBBGDRoEH755RdUVlZy2fNGjx6NzMxM2NnZQUVFBdbW1pCSkoKdnR2mTJkCf39/FBQUoKioiEv0YGVlhaKiIgDAyZMnoa2tjSdPnqC0tBTZ2dnc67f1JpqamuLBgwdYu3YtvLy8EBISgqCgIHTv3l1o3YqKCvj5+UFdXR1A45eqS5cuqK2thY6ODmRkZGBlZQUA2LRpE1RVVZGYmAhVVVUsXboUioqK+P7771st1vu6fH19cfXqVfj7+6NPnz7YsmULVq5ciaioKOzduxcqKiptrs/j8XD48OEWe9A+puTkZEyYMAGHDh3i0qIyzPvWtWtXHDp0CNOnT0d0dDSXNv5TwuPxcObMGaSlpcHOzg4DBw5stsylS5cQFxcHCwsLaGpqIjY2Fs7Ozq1uk8/nIyoqCuHh4Vi8eHGz5/Pz83Ht2jWMHj2auzr7pamsrERgYCAMDAxgbGzc3s354PLz8zF9+nT89ddfUFRUbO/mMB1YeXk5GhoaUFlZibq6OlRXV6Ompga1tbWoqqpCfX09KioqWjzfEXQMPH36FJmZmairq4OLiwu2bduGa9eufbRjtKysLFxdXTFjxgysWrUKCgoKKCoqwtKlSxEfHw8RERFERkYiODgYRUVFiIuLg4mJCWpqaoSK2L98X0BQBuPGjRuoqalBVVUVkpKSMH78eFhaWmLUqFFYtmwZV4rKzMwMP/30E1xcXLj2FBYWYtmyZXB3d8fUqVOxZMkSaGhowN/fHwsWLICSkhIKCgq4dkhJSSEvLw8lJSVcOyoqKtDQ0AAAWLNmDbZv347vvvsO0tLS8Pf3x3//+1907twZLi4uWLJkCbS0tCAuLo7ExEQEBQXB3t4e8fHxCAwMhLy8PB4/fgwRERGkpqZCVVWVSypSVVXFdXjU1NRARUUFS5Ysgbe3N+zt7SEqKoqrV6/C3d0dwP//DglUVVVxo9c2bNgAX19fzJgxA9u3b4esrOx7/vRbR0TYvXs31qxZgx0eGS0NAAAgAElEQVQ7duC777577XVfeXa/e/duTJ06FZMmTYKfn1+LtV4+NFFRUaGgKCUlBdOmTcP3338PAFi2bFmr62prayMpKQkpKSno06dPi8vW1tZizZo1+P7776GlpcV1dwKtB2M5OTno1q0bpKSksHbtWjg4OMDBwQHr1q3jetyaZpNpaGhos50CKioqkJaWRm1tLebPn4+qqiqMGzcOkydPxoEDB4S6gt9EWloaXF1dkZ2dDSUlJXh4eGDZsmUwNzdHWloa5s+f/8pteHl5YcWKFe16gpWUlIQRI0bA09MTTk5O7dYO5sswevRo7vh39erVTy6rnru7OxwdHaGqqoqdO3c2C8YOHDiATp064euvv8b8+fPx008/4ebNm20GY4WFhbh69Sr27NnTYjAWHh6O6dOnIyUl5YsNxh49esRlf/vcg7GamhpMmDABAPDDDz9wJ0rS0tLc+YKghpvgMRERES5oa+mxpusAjb0kTUendO7cmTtZFxMTg7y8PPecjIyM0HAqoHF4fUu9FKKioq3WuXr5Nd+VoqIid04gCDheBxEJnSC3pK6ujqt9JyAIbpqqqalBdXW10GOCYEigoqKCCxDe9nc+n8/V1CsuLgbQmKGUz+dzn6uCggJERUW5z1JWVhaSkpLc96Gt4X3i4uIQERGBmZkZFixYgNjYWPTr1w8HDx6Evb19m+/V+7Jz504YGRnhzp07GDx4MH799VcAjaVRNmzYgPDwcLi7u6O2thbZ2dnIzMxEnz59UFxcjPT0dERGRuLrr79GfHw8hgwZAlVVVW7bo0ePxrJly/DPP/9gwYIF8Pb2RlpaGhQVFXHlyhV4e3sjODgYEyZMwKRJkwAA27dvR69evXD79m0MGjQIS5YsAQDY2dnhzJkz2Lx5M0xMTCAqKoqNGzeivr4eQUFBmDt3Lvz9/TFy5EiUl5dj8ODBuHv3LuTk5KChoQE+n4/U1FTMmzePm+JiZGSEoUOHctOG9u7di82bN2P16tUYNWoUli9fjj59+kBFRQUnTpzAyZMnuSlHO3bsQG1tLYYNG4apU6fiwIEDWLx4MY4fP465c+fi4sWLmD17NtatW4cDBw7A3d0denp6mDNnDuzs7JCTkwMxMTH06tULjx8/Rm5uLsaMGYOMjAxUVVXByMgIe/bsgZKSErZu3frKTob3JSMjAz/++COqqqoQFhaGXr16vdH6LdYZe1l9fT1cXFyQnp6OCxcufLSdE5g/fz5ERESwfft2AMDcuXNRVFQkNB701q1bsLe3x6BBgzB79mzMnj0bADBr1iyYmZlBREQEBw4cwMOHD7mD8q1bt2BjY4Pu3bsjNDQUvXr1grOzMwYMGIClS5dizZo1ePToUYvjTnfu3AkrKyuhlKUjR45E165dcfLkSfj4+GDXrl24f/8+SkpKoKysjLCwMAwePBgAkJWVhYqKCuTl5WH8+PFcL11hYSH09fWRnZ2NxMREmJubIy4uDuPGjYObm1urKV137NiBM2fOtFqzwc/PD9OnT0d5eTkkJSXB5/MxYsQIhIaGIjExEfr6+m1+Bn/99RdsbGy4cgdZWVlcD+DHEh4eDmdnZ2zcuFFoHhvDfEh8Ph9TpkyBlJQUfH19P6kaN1paWggLC4Ourm6Lz9vY2MDDwwPDh7d6+G9RYGAgpk2bhpycnGbP8Xg8iIuLIz09HTo6Om/T7M+CiYkJ1q5dywUqnyM+n4+pU6dCXFwcx44dE/rbaBogCE7EmwYIJSUlICIuGHg56BCcxAPNA4uysjJuzndDQwPKy8u556qqqlBbWyvUTsHrt9R+QdDwspaCmXch2F+gcZqDnJzca633cpDakpa211IwKSUl1eyCbtOgGRAOdJv+3jSgFQRSgHCQKQi0JCUlISsrC3FxcXTu3LnNoLc1I0aMaFY0XF5eHg0NDXB2dsaSJUuEyi/duHEDs2fPxtixY7FmzZov9kIQ83HV19dj//79WLNmDX777TcsWrToTYentl5n7GUSEhI4duwYPDw80L9/fxw+fPijXX0AGg+KTQ+kP/30EwYNGgQ3NzeMHTsWYWFh+Prrr7nnBQkw0tLS8PDhQ+zcuRPV1dVYvXo1Jk2ahFmzZiE+Ph5aWlooKipCQUEB/P39kZ6ejoyMDKiqquLZs2dQUVFBUlIS0tPTISIiInRioaenhx9++AEXL16Ejo4O8vPzERsbi8OHDwNo7OHKyMjgEnV8//33mDx5Mjw9PSEnJ4fQ0FBs27YNeXl5qKysREpKCvT19bF582a4u7tDRkYGR48ehZqaGkxMTDBlypQ2Dy41NTVC3bYv6927N/h8PpYvX45169YhOTkZBgYGyM/Ph4ODAzw8PNDQ0AADAwMMHTpUaF0fHx/cvHkT5eXl8Pf3R2lpKerr6+Ht7f1mH+Rb4vF48Pb2xrZt23D8+PGP+t1jGFFRUfj6+sLR0RFz5szB/v37uRORjiA/P587abGzs4OamhpKSkpw/fp1PH/+HAEBAdDX18eoUaO4dRoaGnD+/HkkJSUhJCQEJSUlmDBhAqqrqxEREYERI0Zwy4aGhuLp06ewsbFpc55BVFQUHj58yNUgbC1oraiowI0bN5CTk4OxY8dyx9WwsDCYmpoiICAAgwcPhr6+PtLT0xEaGopu3bph5MiRABpr6VRVVcHKygrV1dWIjo5Gp06dMH78eNTV1eHixYuwsbFpNq+1uLgYaWlp0NXVxfXr12FgYID+/fvjyZMniI6Ohr29PZeYiIgQEhKC1NRU2NnZoUePHgAaT+oFx85r165BR0cHgwYNQnx8PO7duwc7Oztoa2sLve7169eRkZGBr7/+mhuqDgAhISFISUnBsGHDuIth+fn5SElJgZycHOLj4+Hs7Iz4+Hg8fvwYUlJS6NevX4dIngQ0Hpd/+OEHFBcX49KlS80+b0lJSa4nuWkvF8O8DkFwKSkpCVFRUfTp0we//vorvvnmmxZHKIwcORKPHj2Cu7s7jI2NsXDhQixcuPCjDlNjvhxEhDNnzmDlypXQ19dHcHDwO42CeO0zChEREaxevRqHDx/GrFmz4Orq+l6vGrUmKioK0tLSkJGR4TLnWFhY4Pr16ygtLYWfnx8mTpwoNDlQREQEa9euha+vLwICAiArKwtlZWWEh4dDWVkZx48fh6mpKaZOnQo1NTUcPnwYT548QadOnbBlyxZIS0tDUlISU6ZMgaWlJS5dutTsH6ypqSlmz54NHx8frFy5EqtXr8aJEycwevRoAIC9vT2+++47+Pj4QF9fH/v378fcuXNx4cIFJCQkwMvLizuhk5aWRlBQEFavXg1TU1Nu6I+trS2OHTuGs2fPolevXtywzJeFhYWhsLAQffv2xblz51ocg2xiYoLz588jNTWVG3K1fft23L59GxMmTICvry9ERUWbBWJlZWW4f/8+VFRUkJqaitTUVBQWFmLixIlv+Ym+mYyMDNjb2+PmzZuIiopigRjTLgRj5NPS0vDDDz+0eeHjY7p37x5cXV0xZswYaGlpYeDAgQgPD4eMjAz69u0LIoKJiUmz7HaioqLo168fREVFoa+vD3Nzc+Tn52PhwoVwc3Pjllu1ahWkpKRgbGyMIUOGIDg4uMV2/PXXXwgODsasWbOQmJgIoOVgLCcnBwsXLoSdnR369u2Lr776CpmZmdi8eTNsbGywefNmnDt3DgEBAbh+/ToCAgIwbNgwbN68mWuXlJQU5s+fj169esHCwgIHDhxAeno6FBQUoKKigqCgoGY9gc+ePcOoUaMwb948+Pj4ID8/HzY2NvD29kZgYCCio6OFegd///13dO7cGT179sSAAQNw584dPH/+HE5OTnB1dcXhw4dRVFSE4cOHY8OGDbh27Rri4uJgbW0tNLzKx8cHwcHBOHPmDPr27Yvnz58DAFauXAkZGRn06tULgwYNQnh4OBITE2FjY4M//vgDf//9N7y9vfH8+XO4u7tj8uTJkJSURGBg4Ot/OT6guro6zJgxA7m5ufjnn3+aDQtkmHelqKgIRUVFLFy4EHFxcbh79y6cnZ3bHCquoKCA7du3IzIyEnFxcTA0NMTevXtbPCdimLd169YtDBw4EN7e3ti3bx+uXLnyfoajUwt1xtpSVFREU6ZMoa+++kqo7kBHMHDgQDpw4EB7N+O1hYSEkJKSUns3o8NpaGigvXv3kqqqKm3dulWongfDtJeqqioaN24cjRw5skPUILOwsKDz589z91etWkUmJiZE1FgLBwA9ffq01fW1tLTo+vXr3P1z586RoaEhETXWtxkxYgT5+fmRn58fmZmZccVDb926Rerq6kRElJOTQ1paWlRfX09Eje8RAKG6MwIzZ86kmzdvcvf/+usvKi4u5tYR1A7i8/lkbGxMJ0+eJD8/P/rll19IRESEysvLqaGhgbS0tOjGjRtE1FhkWFB7Jzc3lzZt2tTivnp4eNDEiRO5+3379uXq71RWVpKIiAiVlJTQ9evXacyYMdx+Gxsb07Rp04iosbhp0yKuQ4YM4Yqd1tfXk4SEBGVnZxMRkbGxMVeEtb6+noyMjGj58uUUFBREDg4O3PZ79+5NkydPJiKiX375hSsYS0QUERFBurq6lJKSQkREcXFxLe7bx1RUVER2dnY0YcIErj4Rw7xvqamp3DHlbT148IAcHR1JU1OT1q9fz9XeYpg3VVtbS8eOHaMBAwaQkZER+fn5va/z0rbrjLVFSUkJJ0+exMqVKzF16lRMnjwZqamp7x4VvgcVFRXNxot3ZIKMQvSWtSg+R1evXkXfvn3h5+eHwMBALFy48JOap8N8vqSlpXHu3DmYmJjAysoKSUlJ7daWqqoqxMTEoFu3btxj9vb2iIuLQ1lZ2Vtts+nfWVhYGAwMDNCvXz/069cP58+fx86dO5utc/v2bXTt2pWbW9LWletbt25BS0uLu//zzz9DUVGRm8ciqHOTlZWF4uJiDBgwAP369cOiRYvw9OlTdOrUCWJiYpg9ezY3JPzZs2dITk5GbGwsjh071uoIAlFRUaGx/CoqKtx9GRkZiImJobCwEGFhYTA0NOT2+/Lly9yQ7Je3oayszN0XFxeHtLQ0CgsLuecFc3HExcUxevRoJCcnN9v+P//8g61btwJo/H41TUYxaNAg2NnZoXfv3vD09HzjSeHvW1xcHAYPHoz+/fvj9OnT7ZLQi/ky9OjR450zSPft2xcBAQEIDAzEixcvYGhoiBkzZnBTWRjmVfLz87FhwwYYGBhgz549+O233/DkyRM4Ozu/1/PSd5r4MGXKFMTHx8PCwgKDBg3Cr7/+yiWiaA/h4eEYOnQoXrx48Un8sZWVlSE+Ph7Tpk3D33//3SzL0Zfm0aNHGDVqFBYvXow///wTt27dYsVDmQ5HTEwM27Ztw6JFizB06FCcOnWqXdohJSUFKSkpoVIc8vLy7y0LnLi4OFJTU6Gnp8fdxMXFm104EmQLezlBQkv/qERERBAdHS30WEuBo4SEBPLy8iAjI8O9do8ePbgEDz/++CMuXrwIPz8/jBo1CtOnT8fBgweRl5cHNTW119q/1ub9iYuLIy0tTWi/W5uQ/SYTtaWlpaGjo9Pq+9qSyspKHD58GEePHsVff/0lNIT0Yzt27Bjs7OywcuVKbNy4sUPNm2SYthgaGmL79u1ISkpCr169MHr0aAwbNgwHDhx4ZaZK5stTX18Pf39/TJ06Fb169UJKSgquXLnCJZH7ELVt3/loKi0tjeXLlyM2NhY1NTUwNDTEwoUL26XQmrW1Nfbs2QNPT0+uynhHJi8vj8WLF2Pfvn344Ycf3jpt/acuKCgITk5OGD16NMaPH49Hjx6xtPVMh7B+/XpMmDABy5Ytw65du3Dx4kVERUUhJycHs2bNwvXr17Fq1SrMnj37rXuj3paoqCgmT56MkydPco8JrtiJi4tz2eZayiInwOPxhJ7n8/moq6sD0Jhe+ebNmzhx4gSAxiuEe/fuhYiICIiIC8psbGxQXl6OY8eOAQDy8vIAoMU5xY6Ojvj9998RFxcHPp8PHx8flJWVcdsS/FRXV0efPn3g5uaG6upq8Pl8bNiwgZurp6mpiZEjR8Lb2xvjxo2Dq6srdu/eDQcHhzbfs6aBZHV1Nbe9pvvj6OiIS5cu4ezZswCAFy9eYP/+/a/chuD9a83du3cxd+5cjB49GlevXuU+t7y8POzbt4/bdtNt3L17F9HR0Zg4cSJOnz6N+/fvt7l/H0JJSQlmzpyJdevWITAwkGWyZT5ZysrKWLlyJdLT0/Hrr7/ixo0b6NGjByZNmoQLFy5wxz7myxQZGYn58+eje/fu8PLygq2tLVJSUrB///6P0zFAbzhnrC0vXryg//73v6SiokJOTk4dbk4Z0zHweDy6ePEiDRo0iHr27Enbtm2jqqqq9m4WwwjZtGkTiYuLEwCSlpYmBQUFUlBQIBkZGRITE6MuXbqQsbExaWlpUefOncnb2/ujtq+4uJjGjx9PK1eupAsXLpCbmxsVFBRQZWUlHThwgJSUlGjt2rWUm5srtF5DQwP9888/pKysTPPnz6f09HTKzs6mn376ibp27UrXrl0jIqKtW7eSjIwMqaio0IQJE6ioqIjy8/Np/vz5pKKiQpcvXyYiolOnTpGamho5ODiQl5cXaWpqkqenJ9XV1TVr77hx40hMTIz09PTo2rVrxOPx6NChQ6SkpESrV6+moqIiIiJ6+PAhGRgYkJSUFJmbm1NwcLDQtq5evUq+vr7c/Tlz5rQ6hv/58+c0fvx46t+/PyUkJFBMTAzp6enR1KlTKT8/n44fP05KSkq0YcMGqq2tpT///JOkpKRIVVWVpkyZQmVlZZSTk8PNlY6NjaUnT55Qr1696Ntvv6Xc3Fw6d+4cKSkpkZeXF1VXV9Pq1atp7NixtH37dlq1apXQ3LxNmzaRtLQ0qaio0KRJk6ikpITi4uLI3t6eLC0tublzN2/eJCcnJzp//jytXbuW/P393+Zr8tYCAgJIS0uL5s+fT5WVlR/1tRnmYygpKaFDhw6RnZ0dKSsr08yZM+n06dNUWlra3k1jPrD6+noKDg6m3377jXr27ElGRkbk6elJaWlpH7MZt4DXrDP2NioqKnDkyBFs27YNqqqqcHFxwZQpU15ZL4P5vCUlJcHHxwe+vr7o1asXFi9eDEdHRzYnjOmQ7t27BwcHh1ZrEQH/fx7R9OnTERgYiCFDhmDTpk1Cc7k+NEENow+RQryhoQHV1dXcfK7WEBFqamogLS0NHo/X5lCOmpqa155vVFxc3OJ+0f/1ZgmGy73qNd9UfX09amtrX7seVEv4fD6qq6tbTK9dX1+PmpqaV76vQONwxY+Zovv58+dYtGgRHjx4gAMHDsDW1vajvTbDtJesrCxcvnwZly9fRlhYGAYMGICxY8fCycmpWakM5tNUWFiIq1ev4vLly1yJEycnJzg5OcHc3Lw9mhQoIiJi/8GCMQEej4fr16/D19cXV69exahRozBjxgyMGjXqg4y7ZDqekpISnDp1Cj4+PkhPT8f333+PmTNnsvlgTIdXXFyMbt26tZoUSE5ODkZGRjh+/DgMDQ1RVVWF9evXY//+/Vi6dCnc3Ny+2OHHzKenqqoKO3fuxKZNm+Dm5obly5ezJB3MF6mqqgqBgYG4fPky/P390alTJ9jY2GDYsGGwsbHhag8yHVtxcTHCw8MREhKC0NBQJCcnY/jw4Rg7dizGjh372nOMP6CPE4w1JTgp9/X1RVpaGsaPH49vvvkGtra2rE7JZ6agoACXL1/GxYsXERQUxIJw5pOQm5uLiIgIhIWFISIiAvHx8ejWrRuSk5OFluvUqRMkJSXh7e2NuXPnNuvZTUpKwu+//47IyEisXLkSP/74IyQkJD7mrjDMa6urq8P+/fvx559/wtraGuvWrWuzwDfDfGni4uIQEhKCsLAwhISEQExMjAvMhgwZAiMjI3Zu0wFkZmYiMjISoaGhCAkJQXp6OgYPHswF0gMGDGgz4287+PjBWFNPnz7FhQsXcPHiRTx+/BgjR47EuHHjMGbMGHTp0uVjNoV5T5KSkvDPP//g0qVLQp+pk5MTG57KdEjZ2dmIiIhAeHg4IiIikJycDEtLS1hZWcHa2hrW1tZYs2YNvL29uUQNsrKysLW1xZEjR6CiotLm9h8/fgxPT0/cu3cPv//+O2bNmvXO6ZoZ5n3h8/k4e/YsVqxYgR49esDLywv9+vVr72YxTIeXnJyM0NBQhIaG4u7du8jOzoaZmRn69esHCwsL9OvXD8bGxux4/wGlp6cjOjoa0dHR+PfffxEdHQ1RUVEMGDAANjY2sLGxgYWFRUf/DNo3GGtK0Ity6dIl3Lp1CyYmJrC1tYWdnR2srKzeS5pm5v3LyclBUFAQgoODERQUhJqaGnz99dest5PpkHg8HhISErjgKzQ0FHV1dbC2tuaCL3Nz82Ypu69evQpnZ2fweDzIy8vj6NGjGDly5Bu9dkREBFauXIn8/HysWrUKEydOZD1lTLupr6+Hn58fPD09oampibVr12Lw4MHt3SyG+WSVlZXhwYMHXFDw77//IjMzE6ampjA1NYWRkRGMjIxgbGz8XmqofUmeP3+OhIQEJCYmIi4uDgkJCYiJiYGUlBQX+Ap+amhotHdz31THCcaaqqmpwd27d7kT/AcPHqBPnz6ws7PjuhibFsVkPp7MzEzcuXOHC8AKCgpgY2MDOzs72NnZwcTEhCXiYDqMqqoqREdHC/V8KSkpcYHXiBEjoKen98rtlJaWQkVFBfPmzcP69evf6eLQjRs34OXlhaSkJPz000+YM2cOVFVV33p7DPMmcnNzsX//fuzduxempqZYvnw5hg/vEP/6GeazU1FRgUePHiEuLg6JiYmIj49HQkICsrOzoaenB2NjY/Ts2RM6OjrQ1taGjo4OdHR0Pmqyno6grq4Oz58/x7Nnz5CRkYGMjAykpKRw75eMjAyMjY3Rq1cvGBsbw8jICGZmZlBXV2/vpr8PHTMYe1l1dTXu3LmD4OBghISEICYmBhoaGujfvz93Mzc3Z71n71lubi6ioqJw//59REVFISoqCmJiYrC0tOR6Lb/66isWfDEdRllZGe7du8cFXnfu3IGRkREXfA0fPhxdu3Z9q22npKRAX1//vbU1KSkJu3fvxtGjRzFixAgsWrSI9UwwH0x0dDT27duH06dPw8nJCUuXLkXv3r3bu1kM80Wqra1FUlISEhISkJycjIyMDDx79gzPnj1Deno6pKWloa2tzQVoKioqUFVVhZqaGpSVlaGiogI1NTUoKCi09660qbq6Gvn5+Xjx4gXy8/NRUFDA3RcEX+np6SgsLISGhoZQQNqjRw+YmJigV69en/s0l08jGHuZYKiRIEC4f/8+YmNj0aNHD/Tu3ZvrDjYxMYGBgQEbCvQK5eXlSEhIQGxsLOLj4xEXF4eHDx+iurpaKOAdMGDAp9j9y3zGXjXfy8rKqsNnMiwuLsahQ4ewe/duaGhowNXVFd9+++1rpTtnmLaUlZXh/Pnz2Lt3L/Ly8uDm5oZZs2Z97ic2DPPJKygo4IKzZ8+eIT8/H3l5ecjNzeUCmtzcXFRXV0NFRQXKysqQlZWFrKwsFBUVIScnBzk5OaH7EhISEBUVFQrgXr7fVGVlpVAR7Kb3i4uLUVFRgcrKSlRWVqK4uJj7vaKiAoWFhcjPzwcRQVlZGerq6lw7VVRUoK6uzgVfurq66NatW7PpAV+QTzMYa0l9fT1iY2MRFxeH2NhYJCQk4MmTJ8jMzBSKrgURt66uLnR0dL6YOU0lJSVIT09HRkYG0tPTkZaWxnX/FhUVccGriYkJjI2NYWZmBl1d3fZuNsMISU1Nxc2bNxEeHo7w8HDugoEg8Bo4cOAne/GFx+Ph8uXLOHLkCEJCQuDg4ID//Oc/GD169BdznGLeXW1tLQICAnDixAncvHkTdnZ2cHFxgZOT05d8ssMwn6W6ujrk5+ejqKiIC4RKSkq435veF5RnKS8v55JRAf+/RuXLOnfuLDSvTVFRESIiIlwAJy8vzwWACgoK6Ny5M3e/a9euXIDIvNLnE4y1pq6uDklJSYiLi0NSUhI3FjU9PR3Pnj1Dly5duMBMU1MT3bp1g4qKChe5q6qqQkVFpaOlweRUVlbixYsXyM3N5a6cCLqDBcFXRkYGREREhAJRXV1dbtytjo4OG2rIdDgNDQ14+PAh1+sVGBgIBQUFoV6vz3WOYklJCS5evIjTp0/j7t27cHR0hLOzMxwdHdmkb6YZPp+P27dv4/Tp0zh58iR69uwJZ2dnTJs2DcrKyu3dPIZhGKZ1n38w1hYiQk5ODhe0ZGdnIycnB/n5+VwXsCDIkZWVhbKyMuTl5aGgoMB1AcvJyUFJSYn7XTBvTUpKSmh4lIyMTLOr2xUVFaivr+ful5WVgcfjAWhMGCC4qlFRUcF1CQtuRUVFyMvLg5iYGNTU1KCmpsaNKVZXV4eysjIXZOro6LBhKUyHV15ejsjISC74unv3LrS1tblEG7a2tq9MI/85ev78OU6dOoUTJ04gJycHTk5OcHR0xIgRIyAnJ9fezWPaSXl5OW7evImAgAD4+/uje/fu+M9//oPJkyez4eQMwzCfji87GHsTJSUlKCgoQGlpKcrKyrigqLy8vFmXMNA45KisrIxbv6amBtXV1ULblJeX5woEvjxut2mAJycnJ9QlLCcnhy5dukBFRaXDz4dhmNbk5OQgKioKERERuHnzJpKSkmBmZsb1etnY2HT4yckfW0pKCvz9/REQEIA7d+5g4MCBcHR0xNixY2FoaNjezWM+sISEBAQEBCAgIAD379/HkCFDMHbsWIwZM+a1soIyDMMwHQ4LxhiG+ThSU1O5Xq/w8HAUFBTA0tKSC74sLS077HDgjqiyshKBgYHcybmkpCQcHR1ha2sLKysrqKmptXcTmXf04sULhIeHIzg4GFeuXAGfz+eCbyXIFswAACAASURBVDs7O5ZBmGEY5tPHgjGGYd6/l+d7BQUFQUJCQqi4soWFxWc536u9PH78GNeuXUNoaCgiIiKgrKwMKysrDB06FFZWVqzn7BOQmJjIJacJDw9HSUkJhgwZgmHDhmHUqFEwNTVt7yYyDMMw7xcLxhiGeXeVlZV48OABN+Sw6XwvKysr2NraQltbu72b+cUgIsTFxXEn9WFhYaipqYG1tTUGDx4Mc3Nz9O3bF126dGnvpn6xCgsL8eDBA8TExCAiIgK3b9+GrKwsrK2tuZuxsTG7YMEwDPN5Y8EYwzBvLj8/H2FhYQgNDUVYWBiSk5PRr18/DB06lDvhZ3WyOpasrCyEhoYiMjISMTExePjwIRQUFNC3b1/07dsXffr0Qd++fdnco/eMiJCamoqYmBju9vDhQ5SXl3Pv/aBBg2BtbQ1NTc32bi7DMAzzcbFgjGGYV3v+/DlCQ0O5W3Z2NqytrTF06FAMHToU/fv3/2Tre33JBEHCw4cPuUChtLQUZmZmMDQ0hIGBgdCNZW9sXUVFBZ4+fYrk5GQ8ffoUT58+RVJSEh49egQlJSUu8BIEvj169GjvJjMMwzDtjwVjDMM0l52dzQ05bCnZxqdcXJlpW1FRER4+fMgFFE1vCgoK6NmzJxec6erqQlNTE+rq6ujevftnnVCisrISWVlZyM3NRVZWFtLT07n3JTk5GWVlZTAwMBB6f3r27AkzMzMoKSm1d/MZhmGYjokFYwzDCGc6vH79OmpqarjEDyzZBiOQlZUlFJxlZGTg+fPnePHiBZ4/fw4xMTF0794dampq6N69O9TV1aGpqQk1NTUoKCg0u8nLy7fbvpSWlgrdysrKUFJSgry8PGRlZXH79OLFC2RlZYHP5wvtm46OjlDQxWp7MQzDMG+BBWMM86Xh8/mIj4/nUswHBQWBx+NxxZWtrKxY1jbmrZSVlQkFZ4KfeXl5LQY/paWlUFRUhKKiIhecSUpKNqu7KCcnx/XESkhICA2XrKioQH19PQCgvr6eq/UINAZcfD4fdXV1Qq9dXFzMvWbTwFBBQQGqqqpCQZfgJ5sDyTAMw3wALBhjmM8dj8dDTEwM1/N169YtKCoqcr1eDg4O0NXVbe9mMl+okpISoUCptrYWQGNgx+PxAADV1dWoqakB0Fg2oby8nFu/c+fOEBcXBwBISUlBWloaACAmJsb1vHXq1Eko8FJUVPxo+8cwDMMwbWDBGMN8bgQ1vgTzvW7fvg11dXVuvtfw4cPRvXv39m4mwzAMwzDMly5QRETEXry9W8EwzNtrqcZXr169YGVlhRkzZsDHx4fVk2IYhmEYhumgWDDGMJ+Q8vJyREZGcj1fMTExMDIywogRIzB//nycOXNGaL4NwzAMwzAM03GxYIxhOrC8vDxERkZyPV9JSUkwMzODtbU1PDw8YG1tDSkpqfZuJsMwDMMwDPMWWDDGMB1ITk4OwsPDuYQbycnJsLS0xIgRI7Bt2zZYWlpCUlKyvZvJMAzDMAzDvAcsGGOYdtRWgeV9+/bB3NwcoqKi7d1MhmEYhmEY5gNgwRjDfESpqalc4BUaGoq6ujou0+HcuXNZgWWGYRiGYZgvCAvGGOYD4fF4SEhI4Hq+goKCICEhwRVYXrZsGSuwzDAMwzAM8wVjwRjDvCcNDQ34999/ERISgpCQEEREREBLSws2NjaYOHEitm/fjm7durV3MxmGYRiGYZgOggVjDPOWeDweoqOjERwcjODgYEREREBHRwd2dnaYM2cOfH190bVr1/ZuJsMwDMMwDNNBsWCMYV7Ty8MOb968CSUlJYwYMQIuLi7w8fGBsrJyezeTYRiGYRiG+USwYKwVxcXFyM3NRX5+PvLz81FQUIDi4mJUVFRwt9LSUpSVlXH3y8vLufXLy8vR0NDA3S8tLQWfzwcASElJQVpamntORkYGnTp1AgCIiopC4f+xd95hUVxfH/8uIEjvRYSACCooKEU0ligIKgIaCyaKotjFjkF+saLGKMYuNuzdILFhiwUL2AKIgoIovUrvdct5/+DZed2wCBoDGufzPPuwM3PLuXdmh3vuPfccZWUoKipCQUEBCgoKUFJSgrKyMnOsqqoKTU1NaGhooF27dtDU1IScnFwL9czXg0AgQHx8PKN83b59GyoqKnBwcICLiwu2bt2K9u3bt7aYLCwsLCwsLCwsXygcACCi2wDsW1mWFoHP5yMrKwtpaWlITU1lPtnZ2Xj79i2jfMnLy0NbWxuamprQ0tKCpqYmlJWVoaSkxChFioqKUFFRYY7l5eWZelRVVUXqVVFRYbzk1dXVobKykrnG5XJRUVHBHDel9BUXFzNyvn37Fnl5eeBwONDW1mZkNjAwgKGhIQwMDJjv7KpN0wi9Hd66dQuhoaFQVlaGg4MD+vbtC3t7e+jp6bW2iCwsLCwsLCwsLF8+oRwOZ9B/VhnLyMhAfHw84uPjERcXhzdv3iA1NRU5OTmMstKhQwdGUWnfvj10dHSgqakJTU3NLy6wbmVlJXJzc5nVPKGSmZaWxiieNTU1MDQ0RIcOHdClSxd06dIFXbt2RZcuXaCiotLaTWgV3qd82dnZQV9fv7VFZGFhYWFhYWFh+e/x31DGSktL8fTpU0RGRiIuLg5xcXF49eoVFBUVYWpqClNTU5iZmaFTp04wNDSEvr4+2rRp09pitwoVFRVIS0tDcnIyXr16hfj4eLx8+RKvXr2CgoICzMzM0KVLF1hYWMDGxgbdunX7z/XVu8rXnTt3oKSkhL59+6Jfv34YOnQovvnmm9YWkYWFhYWFhYWF5b/Pl6eMVVVVITo6GpGRkYiMjERERARycnLQo0cP2NjYoGvXrsxKj7KycmuL+0WRmZnJrCQ+f/4cERERSElJQbdu3WBjY4OePXvCxsYGXbp0gYSERGuL22wSEhIQGhqKO3fu4O7du1BRUcHAgQOZj66ubmuLyMLCwsLCwsLC8vXx+StjVVVVePjwIcLDw/HgwQM8evQIBgYGsLa2hrW1Nfr164cePXpAUlKytUX9T8LlchETE4Pw8HBERUUhKioKmZmZsLW1ZUz5evXq9VmtnqWlpeHOnTsIDQ1FaGgoJCUlYW9vz3xYhxssLCwsLCwsLCyfAZ+fMsbj8RAWFobbt2/j7t27eP78OaytrWFnZwc7Ozv06tWL8TrI0joUFBTg3r17uHv3Lu7cuYPs7Gz0798fdnZ2GDJkCExNTVtUnry8PNy7dw+3bt1CeHg4CgoKMGDAAEZZ7Nq1a4vKw8LyuVBbW4uqqirU1NSguroa1dXVqKmpQWVlJerq6lBRUQEul8t4fhUeA2DSAqIOhogIJSUlTB3veokVlvtu3X/n786KmpL9Y5GXl2/Wvl8FBQWxk0nveriVlpZmnDNJSkpCSUmJSfeuY6Z3y5KVlUXbtm0BAG3atIGCggKkpKSgqKjIHMvIyEBOTo7xrivM01zZWVhYWFi+eD4PZay8vBzXr1/HxYsXcf36dXTs2BFDhw7FwIED0bt3bxEX8CyfH0Jl6M6dO7h69SqkpaUxYsQIDB8+HH369Pnkq5YVFRV4/Pgxs+/rzZs3zEqdg4MDrKysmMERC8vnTm1tLSorK1FSUoKKigpUVlaisrISxcXFqKysZM4Jj4XnSkpKIBAIUFJSAj6fj7KyMvB4PJSXlzMKj1ChEA7uFRUVISUlBSUlJUhKSkJZWRkSEhJQVVUFh8MRceIjTAOIKhZChULIu15j31VG/h6+Q4hQEWmKdxWgj+FdxfB9vKuAvktVVRVqa2sBvF8ZfTeEiVDpBcDcCyHv3i+BQIDS0lLmvgnLF3rZFSqiwv4U3jfh/VJRUWH+vuvJV3gsLy8PeXl5qKqqMt+FIVFYRY+FhYXls6L1lLHi4mKcPXsW586dw6NHj9CvXz+MGDECrq6uaNeuXUuJwfIvEB0djUuXLuHSpUvIyMiAs7MzRo8ejaFDh0JK6sPD2glNVYUrXy9evEDPnj0/WzNJlq8HLpeLkpISFBcXo7i4mPne2N/y8nJGmSotLUV5eTnatGkDeXl5KCkpQUlJiRk8vxtr8N1j4XUVFRVGsREqLsKVlneVJ5YvF+HqpFAxFCqYQgWwpKSEeZ6ECrpQYS8vL0dpaSlz/d1jPp8PBQUFqKioMM+ToqIiVFVVoaqqChUVlSb/su9cFhYWlk9CyypjPB4P169fx7Fjx3Dz5k0MHToUY8aMwZAhQ5o1U8ry5ZGRkYFLly7h9OnTSEpKwrhx4zB58mRYWFg0mofH4+H58+fMytejR4/QpUsXZuWrf//+rKkqyyeFz+ejoKCACe4uDA9RUFDwXgWrrq6OGaA2NXhVUVGBsrIyM/gVKl/sfleWlka4IldWVsYob6WlpU1OJrw78SAjI/PeZ15DQwOamprQ1taGhoYG82GfdxYWFhYRWkYZe/XqFQIDA3H69GkYGxtj0qRJcHNzY70dfmUkJibi+PHjOHbsGFRUVDBp0iRMnjwZioqKePbsGbPyFR4ejo4dOzLKV9++fVlTVZYPoq6uDgUFBSgoKEBeXh7y8vKY4/z8fOTm5oocl5SUiAwYhYHTNTQ03qto/RMzOhaWLxmh6WxjCtvff3v5+fkoLCxkFDXhR0dHh/muqakJLS0tJtanhoYGuwLHwsLyX+ffVcbu3buHTZs2ISoqCtOnT4eHhwc6duz4Katg+QIhIty/fx8HDx7E1atXwefzoaenhyFDhsDe3h7fffcdu1LKIhYej4fc3FxkZWXh7du3yMzMZP7m5uYyf4uLi5kBnpaWFrS0tMQeCwd8Ghoard00FpavgndXoP++Cp2fn4+8vDzk5+eLKG86OjrQ09ODtrY29PT0oKOjg/bt26Ndu3bQ1dWFtrb2R5nAs7CwsHwGhHI4nEGf9A3G5/MRHByMTZs2obKyEt7e3ggODmbNylgYOBwOBgwYgAEDBiA7OxtbtmzB0aNHkZWVBW1tbVYR+0qprKxEamoqUlNTkZmZiZycHEbpysrKQk5ODgoLC6GlpYX27dszAzIdHR3069dPZMCmra3d2s1hYWERw4dMfhAR8vLyRCZesrKyEBMTg2vXrjHH+fn50NDQYJQz4V9dXV3o6enB0NAQhoaGkJOT+5dbx8LCwvJxfLKVsStXrmDJkiXQ0NCAj48PnJ2dWa92LM2ivLwcBw8exLZt22BtbY0NGzbAxMSktcVi+YSUlpYiLS0NaWlpSElJYb6npqYiLS0NVVVVMDQ0hIGBAfT19ZnB1LsDLG1t7S8q4DgLC8u/j0AgQG5uLrKzs5GdnY2cnBzme0ZGBvOeUVBQgIGBAfOeEX4XHr8bsoCFhYWlhfg0ZopxcXHw8fFBcnIy1qxZAzc3t08qJcvXQ11dHfbs2YN169Zh5MiRWLt2LbS0tFpbLJZmwOPxkJqaijdv3uD169dISUlhFK20tDTw+fwGg593B0Sampqt3QQWFpb/MHl5eSITQMLvwmMpKSmRd5ORkRFMTEzQqVMnGBgYsKaQLCws/wb/TBkrKyvD4sWLcfXqVfj5+WHKlCmspySWT0JhYSHWrFmDM2fOYPXq1Zg5cya7yvqZkJWVhdevXzNKl/CTnp4OXV1dZvBiZGQkMrB5Nx4VCwsLy+dGUVERo6SlpaUhKSmJec/l5OTAwMAAnTp1Yj7Cd52urm5ri87CwvLl8vHKWHh4ODw8PODk5AR/f/8vYp9PXFwcRo0ahejo6GZ750tMTMTmzZuxZ88esdejoqKwbt06uLq6wtPT81OK2ywePnwIOTk59OjRA8+ePcO1a9cgLS2NgoICrFix4pPayJ88eRKDBg2Cjo7OJyuzKRISEuDh4QFNTU0cPHiQ3QvUQnC5XMTHx+PFixeIj49nBiRv3ryBoqJig8FI586dYWRkxAaTZWFh+U9SV1eHpKQkJCQkiExEJSQkoKqqCiYmJsz70NTUFObm5ujcuTPrDZKFhaUpPlwZ43K58PPzw5EjR7B//34MGzbsX5fyU1FVVYVLly7hxx9/ZM69fPkSXbt2FZv+9evX2Lt3LwIDA1FRUdFouYMGDcLIkSMxd+7cTy7z+7h27Rpyc3MxefJkZGdnY+DAgYiNjYWMjAzWr1+PxMREHDx48JPVx+Vy4ePjgxUrVkBdXf2TldsUPB4Pa9euxf79+7F3714MHz68xer+GsjNzUVMTAyeP3+OmJgYxMTE4PXr1+jQoQPMzc1hZmYmongpKiq2tsgsLCwsnw1lZWXMZFVCQgLi4+MRExODtLQ0dOnSBRYWFjA3N0f37t1hYWHBmt6zsLC8y4cpY0VFRRg9ejQUFBRw8ODBL/6FcuHCBVy7dg379u1rNM2DBw8wZMiQ9ypjzs7OcHJyalFlLCsrC+PGjcP9+/cBAOvXr8eDBw9w+fJlAEB6ejo6duyIlJQU6OnpfbJ6Y2JisG7dOvz++++frMzm8vjxY7i7u8Pd3R2rV69mzRY/EB6Ph5cvXzIKl1D54vF46NGjB8zNzWFhYQELCwt07doVbdu2bW2RWVhYWL5YqqurRd65wveutLQ0LCwsGOXMwsICZmZm7J40Fpavk1AOhzOoWa7JsrKy0KdPH9ja2uLixYstroglJyejf//+WLhwIaqqqrB06VLY2Njg1q1bAIBz585h1qxZAICnT5/Cz88PJ06cwLRp01BeXg4ej8esiuXl5SElJQU//fQTnj17ht9+++0fy1dVVYUFCxagV69e2Lp1K3O+pKQEGzZswK5duzBz5kw8ePAAQL3J5IgRI3Dz5k1UV1dj8+bNcHR0BI/HQ1xcHHx9fXHixAlMmDABM2fObFDfli1b4OLiwhxnZmaCz+czx3p6eiAiREdH4/z58xg7diwuXLiAwYMHw9LSEkFBQQCAJ0+ewMvLC2FhYVi0aBH69euHkJAQPH78GKNGjYKTkxOSkpKYci0sLJCcnIzo6Oh/3GcfSu/evfH48WPcvn0bkydPFmkvS0Nyc3Nx8eJF/PzzzxgwYADU1NTg7u6O69evQ0NDA97e3nj69CkKCgpw69YtbN26FZ6enrC2tmYVMRYWFpZ/iKysLGxsbDBlyhRs27YNoaGhKCwsREREBBYsWAA1NTVcuXIF48aNg7q6Ouzs7LB06VKEhIQgPz+/tcVnYWFpaYjoNjVCVlYWmZiY0ObNmxtL0iLMmjWLJk+eTEREeXl5JC0tTampqUREdPnyZbp58yYREX377bcUHBxMRETff/89BQYGEo/Hozdv3hAAysrKIiIiLy8vmjVr1nvrDA8PJ3l5+femGTZsGI0YMYJKS0vp2bNnxOFwqKSkhHg8Htna2lJkZCQREb169Yrk5OToyZMnRERkbW1NR44cISKimJgYAkB1dXVUVFRExsbGNHr0aIqMjGTa8i4dO3akkJAQ5jggIIDU1NSopqaGiIh4PB5JSEhQUFAQpaamEgDas2cP8fl82rNnD7Vp04YSExMpOzubFBQU6Oeff6aamho6duwYqaurU0hICAkEApo5cybNmTNHpO7p06fTsmXL3tsn/yZVVVXk6OhIEydOJIFA0GpyfE7weDx68eIFHT16lGbMmEFmZmakpKREffv2JV9fX7p06RIVFha2tpgsLCwsLGIoLy+nsLAw2rBhA7m4uJCGhga1a9eO3NzcaNu2bRQWFka1tbWtLSYLC8un5zYAvHdlrKqqCiNGjMDkyZPh7e3dAmph48yePRsXLlxAdXU15OTkoKSkhKNHjwKodygyaNAgAMCpU6cwbNgwPH/+HIWFhXj79i0kJSXFBpr8VKZuffv2hZKSEiwsLNCmTRukpKTg/v37ePPmDaytrQEAnTt3hoODAwICAgBAJF7Su+YJqqqqMDIywnfffQdra2uMHj1apC4+n4+UlBQRRxpTpkyBqakpvv/+e+zcuRO+vr4QCATo1q0b2rdvDwAYMGAAJCQkMGvWLBgZGeHWrVto164dVFVVYW9vDxkZGVhZWaG4uBguLi7gcDiwtrZGamqqSP0aGhqIj4//JP32McjKyuLixYtITU3FihUrWk2O1oTL5SI8PByrV6/GwIEDoaqqinHjxuHBgwf49ttv8ccff6CkpATh4eHYsGEDXF1doaam1tpis7CwsLCIQUFBAf369YOvry9CQkKQl5eHW7duYejQoXjx4gVmzZoFDQ0N2NvbY+3atXj48CF4PF5ri83CwvKJeK+R8vz582FmZoalS5e2lDyNYmFhAVNTUwQHB6O0tBTr1q3Dhg0bMGXKFOjo6DCKVUVFBXbv3g1PT08YGhpCIBA0Wuan3nfE4XAgKSkJPp+PzMzMBp6UunXrhkePHjVZjoSERKOyERGISESZk5WVxb179/DixQu0bdsW169fh6WlJUxNTcW+sPX09MDlchuc/7tzBklJSdTW1oqck5KSavX9WrKysjh37hxsbW3Ru3dvEZPN/yqJiYm4cuUKbt68ifDwcBgbG8PBwQFLly5F79692YClXxHR0dGIjY2Fh4cHAKC4uBhjx46FnJwctLS0kJ2dDVlZWSgqKiIvLw/6+vrYu3evSBm1tbXYtGkTNDU1ERsbCzc3N3z33Xet0ZwPIjo6GmPHjkVcXBzzfr179y6io6Nx9epVDB48GD4+Pk2Wk5WVhZ07dyIqKgrq6upQVVVFdXU1Bg4cCHd39wbv7vDwcOzbtw+KioqQlZVFZWUlNDQ00Lt3b6irq2P//v3IyMjAjh07YGpq2qC+hQsX4uXLlxg2bBhGjRqFw4cP48GDB9DW1oaWlha4XC4GDx4MZ2fnDw5sfuLECZSXl+PIkSNYsmRJgwk8li8PDocDMzMzmJmZYcqUKQCA0tJSPHr0CKGhoZg3bx6SkpLQv39/ODo6wsXFBUZGRq0sNQsLyz+CxJgpXr9+nTp27Ejl5eUtvmbXGEePHqXevXvT4sWLSSAQUJcuXcjJyYny8/OJqN5cS1dXl549e0ZERBMmTCA/Pz8iIiouLm5gpujl5fXe+pprprhx40bmWFZWliIjIykyMpI4HA5lZGQw17y9vWnu3LlERNSzZ086ePAgERHFxcUxZopEREOHDqUdO3Y0WqehoSHdunVL7LWCggJq37493blzh4iIuFwuAaC4uDgmjYmJCWM+qa+vz5h4pqWlkYSEBJPu4MGD5ODgIFL+jBkzaMmSJe/tk5YiLCyMdHV1qbi4uLVF+eTw+XwKCwujJUuWkKmpKenq6tKMGTMoODiYNTn8ypkyZQp17dqVMdNNTU2liRMnMu8PMzMz8vb2JqL698GwYcMalDFt2jQ6fPgwEREVFhaSrq4uY/b9uRETE8N8r6iooHPnzolc79SpE9XW1lJmZibdv3+/2eXGxsYSALp8+TIR1Zvkd+rUidzc3ETSbdu2jXR1dSk2NpY5l5eXRzY2Nsw7fNeuXQSAPD09G9QTHx9P8vLyJCcnx9yzrKwsAkBBQUFERJSYmEiGhoY0b968ZstPVP9/rXv37kRU308vXrz4oPwsXy75+fkUFBRE06ZNIx0dHTIzMyNfX18KDw8nPp/f2uKxsLA0j8bNFAUCAXx8fLB9+/bPKoaYm5sbXr9+jXHjxoHD4WDmzJlQU1NjTBDLy8uRl5eHCxcu4MqVK0hJSUFKSgqSkpJQXV0NoD6gMABoaWnhxYsXePnyJXJzc8XWV11dDR6PByJqVKaioiIUFxcDACorK1FbW4vi4mJYW1tj1KhRWL9+PYD6OCWPHj1iZm0NDQ1x8eJFPH78GOfOnQMAXL16FQBQU1ODysrKRut0dXXFy5cvG5xPSkrC2LFjsXnzZgwcOFDk2rNnzwDUOzuxtrZmzCdra2uZvsnNzYVAIEBJSQmA+lXGv8uRmJgIJyenRmVrSfr16wdnZ+dP4oTlc4CI8PDhQyxYsAD6+vpYsGABZGVlcfz4cWRmZmLfvn0YPXo0a3L4FVNYWIja2lokJCTg5s2bAABpaWn89NNPYmMaqaurY968eSLnqqurcfjwYfTu3RsAoKamhv79+2PHjh3/fgM+kLi4OMyePZs5lpeXx8iRI5nj3NxcJCYmQlpaGu3bt0f//v2bXbYw3qTQTFxXVxejRo1CcHAw6urqAAB//fUXvL29ERAQgG7dujF5NTU1cejQIVRVVQEA5OTk4OjoiJMnTyI7O1uknj179mD8+PGQkZFhrAqEMSCFq2AdO3bEpEmTEBgYyNTdHKKiohjrD3Nz80ZDtbD899DQ0ICbmxv279+P7OxsHDlyBNLS0pgzZw6++eYbLFy4EI8fP37v+IWFheXzQKwydu3aNcjJycHZ2bml5XkvsrKyOHHiBKNIeHh4YNGiRcx1FRUVnD59GtnZ2VBQUMD27duho6MDCQkJ/Pnnn/D19UVERARqa2sxffp0dO7cGTExMWKDCSclJSE2NhYLFy5EcHAwysrKGqSJiYmBvb09FBQUkJOTg5s3b8LHxwdJSUng8/k4c+YMjIyM4O/vj0OHDuH48eP45ptvANR7RNTV1UVISAgmTZqETZs2oXv37ggPD0efPn0gEAjw5s0bsf3g7e3NeJIE6hXCM2fO4Pz58zh16hR++OGHBnny8vKwatUqJCYm4vjx4wCAO3fuwNPTEzk5OSgqKkJ8fDx8fX1x584d5Ofno66uDnZ2dnj69CkAICcnBzU1NQ0UvdZk5cqV2Lt3LzMo+hLJzMzE6tWrYWhoiJkzZ0JTUxN3795FVFQU/Pz8YG1t3eqmoSyfBwcPHsTy5csxfPhwxnNru3btYGFh0WieoUOHihzn5OSAz+eLmDDr6+sjIiICSUlJ+N///gc/Pz/4+vrC2NgY7u7uKC0tRUFBAbZt24Y1a9bg+PHjcHJygru7O0pKSuDr64s+ffpg06ZNDerncrkICAiAs7MzHj58iMGDB8PBwQF5eXlMmhMnTmDfvn3w9fXFypUrmQmpuXPnIjk5Gf7+/sjIyMDvv/+OESNGoLS0FG/evMGmTZtALhM5lQAAIABJREFURPD390dwcDBCQkLg6OiI7du3o66uDpWVlfD29saNGzea1b8ZGRnQ09NjApjv2bMH0tLSYuMbmpubi5gEenl5oU2bNti+fTtzrqioCNXV1c0KMfL27VtIS0tDUlJS5HxxcTHWrVuH3bt3Y+rUqcy7/+HDhzh69Cjy8vLg7++Pu3fvNquNLP89OBwOevbsiTVr1uDZs2e4ffs21NTUMHXqVBgZGWHt2rUNJglYWFg+M+hvZoo//PAD7d+/vxVW61iay7Fjx+jGjRtNphNnpvixLFu2jOLj4/9xOZ8aFxcXOnXqVGuL8cHcvHmTXF1dSV1dnebOnStijsXC8nd4PB5NmTKFiIhu375NHA5H7O/6XTNFcdTW1pKKigoFBAQw5xYtWkS9evUiIqJx48aRra0tlZSUUFZWFpmZmdGcOXOopqaGFi1aRJ07d6Y3b95QbW0tGRoa0pQpU6i0tJSSkpKIw+FQZWVlgzrv3btHkpKSdOXKFRIIBDRo0CDGhPzw4cPk4eHBpB09ejSNHz+eiIiOHDlCVlZWRFRvuhsfH08AGFPdhIQEAiDiWbVv3760YsUK5tjLy0us59XExEQCQOvWraOjR4+Sh4cH9erVi/F4S0RkZWVFXbp0abQvhRw+fJju3btHCxYsIGVlZSotLSUiog0bNlBUVBStXr2aVFVVmfRCs/mjR49SXl4eBQUFkZqaGu3evVukXD6fT7a2tvTXX38REVFSUhLJy8tTWFgYERH98ccfZGZm1qR8LF8v0dHR5OXlRWpqajRixAi6fbtR59ksLCwtT+Nmivfu3Wswm8ryeTFx4kRUVFQgJibmvenKy8sB1Js+/hPOnj2LcePGoUuXLv+onH+DoUOHtuiscEJCAlJSUj4qr0AgwPnz52Fra4uFCxdi5MiRSE9Px86dO2Fubv6JJWX5L3Hp0iX0798fxcXF6NGjBzp27CiyCtNcpKWlsWvXLqxevRq//vorNm3ahMuXLzOra9ra2jA3N4eysjJ0dXXh7e2NP//8EzIyMjAwMECHDh1gbGwMaWlpmJqaomvXrlBSUoKRkRGUlJSQlpbWoE5VVVXw+Xw4ODiAw+HA0tIS6enpAOqtBITecAFg3rx5OHXqFAoKCgD8v6MlCQkJqKioNNk+X19f7NmzB9XV1cjOzoahoeF7V5YlJCRw4sQJPHnyBDdu3ICtrW3zO/NvLFq0CJWVlQgMDASXy8XLly9hZWXVaPqbN2/i0KFDTIDgd00yAeDBgweIj49Hz549AQBGRkZwcnJivPKysDRFjx49sGvXLqSnp8PV1RVz587Ft99+i5CQENaEkYXlM6GBMlZYWAgul9ssswqW1mXkyJHvNU8C6veIzZgxA9evX0dmZuZH1+Xm5vbZ7kfo0aOH2D10/xZ37tyBkZERLC0tcejQIbEmrOKIiIjAt99+i/Xr12PZsmWIjY2Fp6cns3+EheV9BAcH49WrV/D398fGjRthZmaG48ePM/tgP4Tx48fj1atXGDJkCKZMmYLc3FyMHz9ebFpdXd1G3Wg3xwOrOCQkJJiBYHZ2tkh4D+F7RmhW9aEmui4uLtDS0sLRo0cRFBTUaLuEWFpa4tSpU6iursaECRNEPPB2794dycnJzd7HZWBggLFjx2L79u04c+YMxo4d+97033//PXx9feHh4SESrkRIVlZWA7PFrl27Iisrq1nysLAIkZeXx9SpU/HixQv4+PjAz88P/fr1Q1RUVGuLxsLy1dNAGSsqKmIdBPyHmDp1Kvbt24eff/75P6tgq6urf9SA9GPhcrlo27Ytnj17hvnz50NbWxvOzs4ICQkRO2itqqrCrFmzMHLkSMydOxdPnjzBiBEj2H1gLM0mMjISxsbG2LBhA/M5cuQIACAwMPCjylRTU4O1tTX8/f3h4ODQ6F7Q1NRU9O3bV+y1TzGz3rVrV5EBYXV1NWRlZWFsbAwOh/PBdXA4HPj4+GDr1q3Izc1lYi2+Dw0NDZw9exY3btzAypUrmfNeXl7g8/k4ePCg2HxC508CgQB8Ph8A4OPjw7jO/6f7rrt27YqSkhIkJycz56qrq9lVdJaPRkJCAqNGjUJkZCSmT5+O4cOHY86cOYwjLxYWlpangTImKyv7j03aWFhakqqqKkhLSyMqKor5xMTEIDk5mflkZ2ejuLiY+YiLs9ZcuFwuM3teWVmJmpoaXLt2DRMmTICmpiZmz57NeK9MSEhAr169UFtbi/j4eEycOJFVwlg+mDVr1jRwIqGqqopBgwZh27ZtKC0tBVCvHBUWFqKoqKjJMgUCAbZu3YrExEQcO3ZM5Nrz58/B5XJRWlqKU6dOMQHW/+7p9e3bt0xdPB4P1dXVYleRhB5ahb+7/Px8xoR67dq1OHXqFDIyMgDUr+YvX74ccnJy0NbWRmpqKl6+fIn4+HimbqEJo7DdwrKEjB8/HlVVVbC0tGy0/cIJHKH8tra22Lp1K3799VecPHkSAGBjY4OAgAD4+PiIeE/MyMiAn58fI0dqaioSExMB1K/UOzo6Yvr06cxvvbCwEFVVVcyqoTBfU/fJ3NwcEyZMwC+//AKg3ivvgwcP4OvrCwAoKytr0HYWlubA4XAwefJkxMfHo7S0FH369GGeYRYWlpaFA9Q78ABgD9S/7NXV1ZGXl8e4/mVh+Zw5d+4cfvvtNxEFi8vloqKigjmurq4WmWSoqKgQSa+srMy4mZaQkICysjJzrU2bNiIhHtq0aYOoqKhGFbo2bdpAQkICurq6KCoqwtq1axu4F2dhaS537tzBn3/+iQ4dOsDT05Px9BcTE4Pz58+juroaBgYG8PDwwOnTp5GYmAgJCQlYWlrCzc1NbJl3797Fy5cvYWZmBjs7O5FrixYtQnp6Onr16oXCwkJMmjQJZmZmyMnJwfHjx1FWVoYxY8ZAQkICQUFBUFBQwMSJExEVFYWHDx/C0NAQkyZNYv5/CAQC7N+/HykpKbC1tYW1tTUOHToEAJg0aRKMjIwQFRWFP/74Ax07doSysjLGjBkDoP53vHLlSmhqamLatGk4c+YMkpOTYWxsDBcXF1y4cAGpqakwNTXF8OHDoaqqyrRj2rRp2LVrF2RkZBq0PycnBydPnkRBQQFkZGQwevRoxuR7+/btyM3NxYgRI9CrVy8AwIsXL3Do0CG8efMG7du3h4mJCaZPnw4lJSXcu3cPN27cAIfDwZgxY9CjRw9ER0fD1NQUbdu2xf3793Hjxg3weDxoa2tjzJgxCA4ORm5uLmRkZODk5MSEGRAHn8/Hnj17UFFRAVVVVTg6OsLIyAjp6ek4e/Ys8vPzYWtrC2dnZ7FtZWFpDvv27cMvv/yCO3fuwNjYuLXFYWH5WgjlcDiDGihjAJh9LZ+TC/PPFS6Xi8LCQujo6KC2thaSkpIi+x9aEj6f32B/QWOUlZWBx+N9kElqSUkJFBQUWq19jeHt7Q0tLS3873//++gySkpKGHMogUDAzLgDDRW7Y8eOISAgQGRviRAOhwMFBQXm2pw5c/DLL7+IjQHFwvI5smjRIpSXl+PAgQOtLcpHU1BQgF27dmHVqlWtLQoLyxfDoUOHsG7dOjx//vyzijHLwvIfJpTD4QwSO6oeOXIkTp8+zSpjTXDmzBkcOHAAQ4YMQUJCAp4+fYqjR4+2uD1/WVkZtm/fjoiICFy6dKnJ9Nu2bcPbt2+hrq4OIsKSJUvemz4jIwNjx45FbGwsgHrvZzNmzPgksv9T+Hw+goODmx1HqDH+7qVNXV290bSXL18WUcQkJCSgoKAAPp8PJycneHh4IDw8HKWlpfD39/9HcrGwtDRlZWVfrKn6mTNnsG/fPkhKSjKmhiwsLM1jypQpCAsLw8aNG7FmzZrWFoeF5atBrDI2adIkdOvWDX5+fmjXrl1Ly/RZcfbsWbGmPjU1NZg2bRqePXvGLOkvXrwY2dnZjDLWWN5PTVZWFsrLy5l9Ge+juroavr6+qKioQJs2bWBnZ9ekMrZ161acO3cOOjo6WL9+PebMmQMnJyfo6+t/qiZ8NCdPnoSxsXGLutyvq6sDh8OBvLw8OBwORo4ciUmTJmHAgAHMyuT06dMRERHRYjKxsHwKkpOTYWBgAB6Ph/v37+O7775rbZE+iO7du6N///4YPXo0tLW1W1scFpYvjpUrV6J///6sMsbC0oKIjTOmra2NqVOnYtmyZS0tT6PU1NSAx+OJbFbm8/ki5mPvpuVyuWLd/xKRWFfk5eXlSElJYTxiAcCmTZtw4sQJsfIUFBSgsrISd+7cYc4tXbqUyf/777/j119/FVvP383bhLPQBQUFDdpTXV3dpEt6U1PTZntKrKioQF1dHRISEnDr1q0m3dVXVlZizJgxaNeuHTgcDnx9fSElJYU3b940q75/k/LycqxcuRJr165t0XrV1dXh6emJkJAQFBcX4+jRo7C3t2cUsYKCAvD5/M9CWWVh+RCMjIywcuVKrFmz5otTxID6d+GaNWvQvXv31haFheWLpEOHDqiqqkJxcXFri8LC8tUgVhkDgOXLl+P+/fsICQlpSXkaEBcXhyFDhmD+/PlwdXWFiYkJAGDPnj3YvXs3pkyZgnHjxjEzuWZmZli0aBE8PT1ha2uL/v37MwrOuXPnsHXrVixfvhzfffcd401rz5492LhxIzIzM2Fra4vMzEzk5eXhxo0bSEpKgr+/fwOznfbt22Pw4MGYOXMmlixZgqqqKqirq2PYsGGoqqrChQsXkJ+fD39/f+Tm5iIzMxOrV69GYGAgevTogStXrqCqqgq+vr4wMTHBhg0b8MMPP0BDQ4NxWR0ZGQk/Pz+kpKRgwIABn8T1rKamJszMzDB79my8fPkSmzdvxsaNG5nYOH9HXl4effr0YY65XC6kpKQ+C9fKCxYswJAhQxp1u/1v4e3tjYMHD2LgwIFi9+ipqKigpqbmizX1YmFhYWH5OqmqqgKfz4eSklJri8LC8nVBRLdJDI8ePSJtbW2Ki4sTd7nFGDduHDk6OhKPx6PExES6fPkybdmyhYiIamtrSV5eng4fPkxERN27d6d169YREVFxcTHp6+uTv78/vX79mmbPns2U2b17d/rpp5+IiGjgwIF07949IiJydXWlPXv2EBGRn58fjRo1qlG5qqurycvLiyQkJMjIyIjCw8OZa4cPHyZra2vmePjw4VRZWUlERNu2bSMNDQ0SCAR048YNatu2LZWUlBAR0d69e0lBQYFKS0tp4cKFtGPHDiIiun37NpWVlTUqy/bt26l///7v7Uc+n09btmwhR0dHkpOTo4yMDCIievz4MY0aNYoEAsF78xMRnT59mpYtW9Zkun+bgIAA6tatG5WXl7e2KGJxdHRknkkWFhYWFpYvgcDAQBo2bFhri8HC8rVwG3jPyhgA9O7dG5s2bYKTkxNSUlJaRjMUg4aGBkxNTSEpKYmOHTvizJkziI2Nhb+/P7Zu3YoVK1agQ4cOAIC2bdtCS0sLQP0KxejRoxEZGYng4GCkpaXB398f/v7+GDduHONO+M6dOzA3N0dwcDDy8vJEzBjfFxOqbdu22LVrF+7duwciwqBBg3D//v0GeXNzc/H48WPs3LmTWWX76aefUF1dDRkZGcjKyjKu1CdPnoyqqiq8evUKQ4YMwZIlSzB//nxYWlpCUVHxH/XjlClTwOFwcPXqVRgaGmLx4sUAgPPnz2Pbtm1Nxr/Kzc3F06dPW92WXGgCeunSpc/W49P69euxfPlysaayLB9HSUkJ8vLyPipveno6E+Ppa6empgbp6ekfnb+wsBBPnjxBRUUFqqurmfhg74OI8PLly0avFxcXi8Qvay61tbV49OgRE3z5v0ZKSorYQPL/FIFAgPT0dCYmXGuapH1I+6qqqpCenv5BgcBLS0tFvOOyNE56ejpWrVoldosFCwvLv8d7lTEAmDBhAv73v//Bzs4O8fHxLSFTkxQWFqJnz57w9fVlPgMGDBCbVl5eHkpKSigqKkKHDh1E8owePRoAcODAAfj7+2PkyJEN9vk0pqA8evSI+YfQr18/REZGQkVFBbt27WqQt6ioCFVVVfjpp59E6peTk2tQrrS0NNq0aQMlJSUMHToU9+7dQ2hoKGxsbP6RQvzkyROcPn0ac+fOhZSUFHbu3Ing4GDMnz8f33zzTZP7myoqKrBt2zb88ssvTDyu1uDYsWPw9vbGjRs3GAX8c8Ta2hqLFy+Go6Pjf3ag2NKsWbMGCxYs+Ki8Li4uje7//No4cuQIvv/++4/KGxUVhS1btiAmJgZdunTBwYMHmZhgjZGXl4dZs2Y1ugft5MmT0NLSQlpa2gfJUlpaCi8vL9TU1MDMzAwJCQkflP9LoHfv3rh+/fonLTM2NhbfffcdgoKCsGzZMtjb2+Pw4cOftI7mwOPxcOTIEXTu3LlZJt3379/H9OnTERYWBg8PD5H93eLgcrmYOHEiTExMoKKiAnd3939Fsf2vkJ2dDUdHRyxbtozdc8nC0sI0a1Q9a9YsrF27FnZ2drh169a/LVOTWFlZYc+ePcweqpqaGgQGBopN+/z5czg7O8PS0hKnT59mBsZEhJ07d6K0tBSzZ8+Gl5cXJCUlRQL5SkpKNvryfvHiBc6cOcMcq6mpwdzcnHGR/m7eDh06QEpKSiRuz61btxAXF9eg3ISEBBgYGMDExAR//PEHbG1t8fTpU5iYmPyjwWRGRga4XC4KCgoAAPb29vDy8sLu3btFPBGKmyHlcrnw9/fH0qVLmYCzDx48+GhZPgaBQAA/Pz+sWbMGt2/fbtLxyOfAokWLMGnSJPTs2RPh4eGtLc4Xz/r16z869tX9+/fh6en5iSX6MpkxYwZCQ0M/Ku/GjRvRt29fTJ8+HVFRUZg9ezb+/PPP9+bR0tKCu7t7o9fHjx8PgUDwwbH4Tp48CU1NTWaisFOnTjh9+vQHlfG5ERYWJuKwKT4+Hs7Ozp+0jsWLF2PixIn46aef8Ntvv2Hp0qXIzs5mrl+/fr1FVspycnKgpaWF5OTkZqVftWoVJkyYAHd3d0hJSTW5Irt7924sWLAAeXl5ePToEc6dO8dOyDTC3bt3YWtri1mzZmHOnDmtLQ4Ly1dHs5c4Jk6ciKCgIHh6esLHx6fFTH64XC4yMjKQkpLCeCGcP38+KioqYGVlhblz52LSpEkYMWIEk+f8+fNISkrCsWPHoKysjO+//x5ubm7o3LkzrKys4OXlhbFjx+K7775jYkTNnTsX69evR01NDW7cuIHIyEiYmJjg8ePHOHToUINZW2NjY8yYMQMHDhxARkYGLl68iMTERPj6+gIATExM8OrVK+zbtw9JSUlYt24d5syZg7FjxzIu8c3MzADUewU8ceIEkpOTsXTpUiZOzu3bt3Ht2jVIS0vD0NAQgwYNEttHPB4PycnJKCwsZMxO/s6AAQOgpaWFUaNG4Y8//oC/vz8UFRUxc+ZMDBkyBOPHj4enp2cDszoiwowZM3DmzBnY2dnBxsYGFhYWOH/+/Mfd0I8gLS2NMQF9+PBhi7qx/6f4+vriwIEDGDt2LHx8fMR68vzaET6zFRUVzGQIETUYEMrIyIisygoEAqSmpqKyslJklryoqAiZmZki51RUVETeWdXV1RAIBCgvL2/Uu6pw4uJ9VFVVgcvliryfhBAR8vPzxebh8/koKipi2pGSktKgHUB9zC9xjnuEJn1v375tkKegoADZ2dmNrhxISEhARkamQXkCgQA5OTnvbe/Lly+Ze6CtrQ1JSckGZYlrt7jVdCJCRkYGBAIBOBxOo1YIPB4PCQkJDZ6HFy9eMA50tLS0EBAQIFZZLywsbNAXVVVVACD2/rzvemFhYYP7LEybmZkp1rtvcXGxyCSfsE2vX79mngGgPqzAjz/+KPKcqqmpiawaCe97SUmJWLPO4uLiJhWpzMxM3L59m+kTBwcH9OjRA0C98jdhwoQGk5CVlZUN6uPxeKirq0NZWZmIMie8lpycjNra2kafQ319/Q+ybigpKUF8fDyys7ORlZXVpDWHubk5bGxsANSvMA4aNAivX79udn1fAyUlJVi0aBHc3d1x7NgxLFq0qLVFYmH5eqFGHHiIo7i4mNzd3alr164UHR39yXey/Z34+Hi6efMm3bx5k54/f86cLywspJMnT9Lvv//OOMYgIurVqxcFBATQyZMnKTQ0lPh8PnOtqqqKzp07R0ePHqW8vDzmfGJiIp09e5ZKS0spJyeHbt++TXw+n/h8PgUHB9OLFy8ayFVYWEivX7+mR48e0Z49e+jUqVNUWloqkubKlSv05MkT5jgiIoICAwMpMjKSOXfv3j1SVVWlly9f0vHjxyktLY25lpSURH/++ScFBQXRmzdvGu2j6Ohopo/u3LlDXC5XbLrc3Fzau3cv7dixg2JiYpjzoaGhtGXLFkpOTm6Qp6Kigin73U9ubm6j8nxKgoKCSEtLi1atWiVyL7808vLyaPr06aSrq0v79u2j2tra1hap1cnIyKAff/yRhg8fTmvWrCFnZ2fS19en+/fv06xZs8jS0pJcXFyIiCgzM5OmT59Ojo6ORERUV1dHHh4eFBERQWvWrKHdu3cTEdHx48cpICCAQkNDaciQIUREFBUVRX369KFff/2ViIg2bdpECgoKFBgYSD/88AOpqanR1atXGblWr15Nu3btorVr15KBgQFNnTpV5DdLVP9btrCwoAkTJpCnpycZGRmRubk587u4evUqbdy4kZYtW0aWlpaUlpZGiYmJ5OrqSmPHjiU3Nzdq27YtlZeXk4eHB0VGRtKqVato//79RESUlZVF06ZNozNnztC8efNozJgxVFxcTG/fviU3Nzeys7OjZcuWkYODAxkbGzMOgAICAujIkSN07do1sc6HCgsLacWKFdSxY0ciInr+/DlZWlrSjBkzaNasWdS9e3caOXJkg3w8Ho82bNhA6urqNHnyZPL396eCggL6+eefqUuXLky6kJAQ+u2332jp0qVkZWVF6enpREQUFhZGampqTLpnz57R9OnT6caNG7Rq1SricDiUmJjYoN6kpCQaMWIE/fXXXzRjxgzatm0bEREdO3aMbGxsaMCAAbRhwwZ6/vw5ubi4kImJCW3YsIFKS0spPj6e/Pz8aMuWLWRmZkahoaFUVFRECxYsIDMzM/rll19ISkqKHjx4wNRXXV1Nq1evJhUVFTp06BDJy8vT8ePHKTY2llavXk2bNm0iU1NTCgsLo+LiYpo2bRqZmZnRzz//TAMHDiRZWVk6f/48ERHl5OSQn58fbd++nbp3704nT54kIqL09HRycXGhJ0+e0Lx582j9+vVERHTo0CECQL6+vnT//n0KDw+nbt260YEDB4jL5dKKFStIRUWF9u/fT2PGjCEVFRWR/y8LFy6ko0ePkre3NxkbG9PMmTPp9evXDfp08+bNBIDs7e0pKSlJ5Nr27dsJAK1atYoeP35MNTU1tG7dOgoICCB7e3taunQpEREdPXqUNDQ0aNmyZeTm5kYqKirk7u5OAoGASkpKyMPDg54+fUrz5s2jS5cuNZBBSFxcHAGg6urqRtMIWbRoERkYGNDSpUupqKiIrl27RmPHjqWlS5dSQUFBk/nt7Ozo3LlzTab7GqipqaFdu3aRjo4OzZw5k/Lz81tbJBaWr5XbH6WMCTl69ChpaWnRihUrPiuPdr169WIGNF8CQmWMRZSEhAQaMWIEmZubiyjhXzpRUVE0bNgw0tfXp23btlFFRUVri9Sq/PLLL2RjY0N1dXVERGRubk4+Pj5ERFRWVkYcDodRNLZu3Ur29vZERBQTE0NWVlZUW1tLAoGAGfDZ2dlRaGgoERFdvHiRqcfZ2ZlRxt6+fUsAGO+nPj4+NG7cOCIiev36NamrqzP5jI2N6fjx42Jld3BwIG9vbyKqn+ixsLCgxYsXU1ZWFk2cOJFJ5+joSB4eHkRENH/+fOrZsydxuVxKT0+np0+fUs+ePamuro74fD5dvnyZyXP27FmmjKFDh5KnpyfTD506dWIGsHp6ekz7e/TowUySNTYIvnr1KrVv3545Hj16NLm7uxMRUXJyMgGgoqIisXk7duzIyEhU38eGhoZEVK9cC9tJVH8vhDK/q4zV1tZS165dmQmx8vLyRpWxkydP0pQpU4iI6PLly9SjRw/mmqenJ/n6+jLHmzZtosGDBxNRvfI4ZMgQ4vF4RES0atUqMjY2JqL6CR4FBQXKzc2lrKwsJo2QiIgIAkCxsbGUl5dHZWVlNHToUMbb7P/+9z/q2rUrEdX/H2zfvj0zubJ27VrS0dEhPp9Pbm5uVFhYSET1kwRycnLMhKDweQsNDaVOnToREVFpaSkBoNTUVEYWGxsbOnDgABHVK84AmIm5iRMn0sKFC5n+NTMzI6J6r7lKSkp08+bNBv0p5PDhw6SqqkqysrKMgktUP+nx7v1fu3Yt83sSKk4RERHE5XJJSkqKmcRISEggGRkZunbtGl2+fJlcXFxIIBBQRUUF3bp1q1E5mquMXblyhcaNG0dSUlJ06tQpIqq/x927d6fi4uL35iUiSktLIwcHhy96Qu9TUF5eTps2baL27duTi4tLi0yos7CwvJemvSm+Dw8PDzx9+hTp6eno3LkzAgMDm9xQ+2/D5XKRnZ39wd6WWpP09HRUVlY2ai7ztVFYWIj58+ejf//+6NevHyIiImBhYdHaYn0yrKyscOXKFVy8eBEPHjyAgYEB5s2bh9jY2NYWrVVo27YtdHR0mP1C33zzDRPAXFFREYqKiozprJSUFJPPxMQEdXV16NWrF8LDw+Hq6goA+P777+Hi4oK1a9diyJAhTPp39yMJv+vq6gKojxkojDkoNFsUBpd/Xzw9GRkZaGpqAgBkZWXxww8/ICoqCpcvX0Z+fj4CAwMRGBiIMWPGYNSoUQDqzc5MTEwgJSUFfX19dO7cGRUVFfj222/x+PFjODs7o6SkBDdv3hR57n/88UdcuHCBkV9NTQ1t27YfYSlqAAAXnElEQVQFAOjp6THyf//99xgwYAA2b96MYcOGiZX73X4E6p0GCftC2PfC8pri3bJCQkJE2v3jjz+KdRTy8OFD8Hg8pu8UFBQgISEh1kxx/Pjx2L9/P27evIlHjx4x96UxhGW8evUKSUlJOHjwIAIDA6Grq4slS5aAiKCmpgY1NTVoaWlBV1e3QaxANTU1APUBpDU1NfH69WukpaVh//79CAwMRIcOHbBw4UIA9c+AsrIys5d20qRJePv2Ld68eYNbt24hODgYgYGBqKqqwtatW1FXV4eRI0fi5MmTCA0NRVhYWIM2vdsP73tu9fT0GDPHsrIy5OXlgcfjQUJCAt26dXvv/8DJkycjLi4OdnZ2WLhwIfz8/MTKEBQUhIiICAQGBiIsLAz79u2DiooKpKSkICkpydzDTp06oU+fPoiKikLPnj3x7Nkz2NvbIykpqVHz+uZy+PBhHD58GMePH8fs2bPh6+uL0tJSXLp0CcuXL2f2aTcGn8/Hjh07cObMmVZ1PtWaPHv2DF5eXjAwMEBkZCSuXr2KkJAQxjyVhYWldZFqOknjtG/fHkeOHEF0dDR8fHywY8cOrFu3Dq6urq3y0nvy5Ak2b94MAIiJifnsPQKVlJRAVlYWJ06cwL179zBs2DCxHha/BsrLy7F7925s3rwZ48ePR1xcHNTV1VtbrH8NS0tLBAUFITMzEwcPHoSzszPat28Pd3d3uLm5QVtbu7VFbBX+vv8IQIM9OkC9Evf48WP89NNPcHBwwLZt2zB79mzMnz8fHTp0gJeXF65evYqbN29+UPgDKysrjB8/HgsWLMDEiROhqamJsWPHNiuvnJwcVFRUUFJSAkVFRcyYMaNZef766y94e3vDzs4OAQEBjGL57h4dfX191NbWiu2Ld1m1ahU6deqEhQsX4tq1a7h69SqjKPzblJSUQFlZucl2Z2dnM/usmiI5ORkLFy5kvNS+6zRJHEIlori4GNXV1Zg+fXqTITuaori4GLW1tc2+n0JKS0vh7u4OeXl5kTQZGRnw8vLC9u3bISMjg71794ptw4fg6OiI3r17Y8mSJRgyZAisrKzg4ODQIF1aWhokJSWhp6cHHR0dXL58GSNHjsSOHTtEFLJ3+/Hbb79F//79m5RBTk4OysrK0NLSQnR0NLy8vNC7d2+cOnXqo7138vl8LFq0COfOnYOkpCT8/PwQHByMyZMnQ09PDzt37myyjPXr12PBggX/6f8n4sjJyUFQUBBOnjyJvLw8TJs2DbGxsYwyz8LC8vnwSTQmS0tL3Lp1C/7+/vj1119hZmaGffv2id14/m/Sr18/uLm5wc3N7bNXxID/j4Pm5uaGMWPGfJWKWGZmJpYsWQIjIyPExMTgwYMH2LZt21fzj1NPTw+rVq1CSkoKVq5ciYiICJiZmcHBwQH79+9v0qHCf42mVteFs/0xMTHIzMzEnj17cOzYMWzcuBEAcPbsWbi6uiImJgbFxcWM18APWSkfOHAg5s+fz7zHmqvMPHv2DK6urrCyskJISIiIs4Dt27eLVaSio6ORm5uLwMBAHDp0CBs3boSOjg46deqE27f/35T87du3jMOhxvpE2P5x48YhJiYGCQkJePLkiVhZP9ZyQFw+4TkrKyvGkZEQce3u1q0bMjMzERUVBaDe2QMRie2flStXwsLCAvr6+uByuSL1E5HI8bvecM3MzFBUVITff/+duf7HH398VHw1c3NzZGZmijgtOnPmjNjfZnR0NAYMGIBOnTqhXbt22Lp1K3MtPDwcf/31F9asWQMTExMYGRmJtEm4Qtdc9+vvtl1KSgrOzs6YOnUqbGxssHPnzkaVuuXLlzPfORwOvv32W2Y18O8yWFlZYevWrcy9ycrKQlBQUIMy+Xw+4uPj4eTkhFu3bkFKSgpBQUFYvXo1tmzZ0qz2iKOiogKlpaWMh0k1NTXs27cPFy5cgIKCAtMHja3k7t69G6NGjWKcfSQnJ4t4q/yvkZWVhb1798Le3h7dunXDs2fP8MsvvyA5ORnLly9nFTEWls+Uf7Qy9necnZ3h7OyMsLAwbN68GatWrcLs2bMxa9asr3amn0U8T58+xdatW3Ht2jVMnjwZUVFR+Oabb1pbrFZDUlISTk5OcHJyQk1NDa5du4bg4GD8/PPP6NChA1xcXODi4gJLS8v/lKlNZmYmsrOzmcHf69evmQFDdnY2KisrkZSUBFNTUyQlJSEpKQmVlZWora3Fr7/+isOHD6Ndu3aMSd7hw4dhYmICMzMzGBsbw9bWFlVVVcjKysLLly/B5/OZeFS5ubkwNDREbGwsMjIyUFdXh5KSEixevBgODg7Q1taGhoYGHBwc0KdPH7Hyh4SEwNXVFS9evEBFRQU8PDwgJSWFwYMHo3fv3hg+fDgqKyuxaNEi8Pl8pKSkICUlBXV1dZCWlkZNTQ02b96MAwcOiLTj4MGDmDp1KpycnNChQwdcuHCBGdgLvfDV1dWhtrYWKSkpjHvw3bt3M8qLmZmZWDPL169fIy8vD7m5uVBTU0NycjKkpaVBRHj+/DkAICkpCcbGxiL5iouLkZ+fjzdv3jDnYmJikJOTg4KCAgwePBj29vbo1asXXF1dUVFRAR8fH0hISCAhIQFVVVXIz8+HhYUFZs+ejVGjRsHb25tZJQsICMCGDRsY80sAUFVVxaFDh8Dj8aCgoICcnBzs378fnp6eSEpKQllZGQQCASQkJNC5c2esXr0ae/fuhYODA1atWoWJEyfi3LlzaNOmDezt7aGvr4+rV6+iqKgIBQUF0NDQENs/QH2YETMzM2hra2PZsmX44YcfMGrUKHA4HAwbNgzt2rUDUG9qfu7cOXTq1AmbNm1iFKHNmzdjwoQJePjwIbS0tGBsbIzly5cjODgYR44cYcxNCwsLsWvXLsyZMwd6enrYvHkzhg4digEDBiAnJwexsbEgIpHn9ptvvsH/tXdvMU2efxzAvwUFpNCDPVAE/hQU5CCoU7A4EQpsaETNLpbFZNFdbFm2JbvyYpebu1iWmOxiWUyWZWNLzOISLzyMnVRkuhUFHVago6K0HIo9wNsjltL2/V+QPmspTnRiQX6f5E37CtQXaOnzfQ6/p6+vDy6XiwWhDz/8EA0NDVAqlZDL5Thw4EDcFO+8vDz88MMPEIlEePvttzE1NYWTJ0/i+PHjAGarUkokEnzyySd46aWX8NFHH7Hf6datWxEOh3HixAn2eK2trZBIJPjqq6/wzjvvYP369ejp6cGxY8fw6aefIjs7+6Gl+XmeZ9u7jIyMoKioKO5zxGIx9u3bh6NHj7LO3Zs3b+KLL77A0aNH0dHRgZKSEuzZsyduBLu1tRUff/wxvv76awCzATMyov68CIfDbGr0+fPnYTabsWfPHrz//vvYu3fvvDMNCCFLjwCYLeABoOFpP7jRaMRnn32GU6dOoba2FkeOHEFLS8szmzZDlhabzYbvv/8era2tcLlceO+99/DWW29BJBIl+tKWrFAohD/++APnz5/Hjz/+CLvdDq1Wi6amJjQ2NqKwsDDRl/jELBYLa4ytW7cOPM+z0Yby8nLcvXuXlfVet24dK58tlUpRWFiIoaEhmEwmyOVy1NbWQiAQwGAwwGQyIRAIYNeuXZDJZOju7obT6QQwuyXF8PAwAoEAW1uj1+sB/LNe7fjx4/jf//4Hu90Or9cLnU7H9rSK1tLSgp07d6K0tBQSiQS1tbVsDVUwGMSFCxcwOTmJhoYGqFQqDA4OwmQyAZhdJ6XRaDA5OQmTyQSTyQSFQhEzHcxiseDXX3+FUChEQ0MDZDIZJicncfPmTQCASqUCMDtqBgDV1dUYHh6G2WxGKBRCXV0dxGJxzDVbrVa2PjE1NRU5OTksyJWUlMBkMsHv9yMpKQkNDf+8JYTDYXR0dLCRS7VaDaFQiL6+PgCz00Z37doV8303NjYiKysLExMT+OuvvwDMjuDU19cDmB0pslgsaG5uxt9//40dO3bEPUdmZmbw888/o7i4GBs3bsSlS5ewZcsWmEwmtl5KIpGwEuZtbW3Iz89n+xBev34dBoMB1dXVKC0thcPhQE9PD3t8rVYbs2bM5/NBp9Oxc41Gw6a56nQ6GI1G1NTUoLi4GABw6tQpHDt2DCdPnsTg4CDq6+tjAl5/fz+6urpQXl7OrjEYDOKXX35BQUEBysrK0N7ejoqKCsjlchiNRhiNRuzduxfXrl1jQbWkpAQDAwPgeR4pKSlYv349DAYDgNnntFgsxueff468vDzYbDZ4vV50dnbi/PnzcQ3y3t5epKeno6urC36/H1qtNqYjrK+vD8PDw9izZw8EAgFGR0fR0dEBpVKJpqYmNuKWlpbG1glWVFSw4G+1WjEyMgKz2Yy8vDxUV1fH/V6B2SmT0cF+y5Yt84bjYDCIs2fPwmKxYNOmTWyE+N69e/jpp5+wbds2aDSauK+7cuVK3BY8kXWay9ng4CAuXryICxcuoL29nQXeffv2YefOnXFrIAkhS9olgUDQuKhhLMLn8+H06dP49ttvcfv2bbz22ms4fPgwqqqqFuu/JEvE9PQ02tra0NraiitXruDAgQN44403UFdX95/XcqxEY2Nj7I344sWLSElJwYsvvgiNRoOdO3eisrIyrkADWbhDhw7h3XffjQlFp0+fRm1tLZRKZczntrS0YNeuXfjggw+e9WWSJSISxiKhNFEaGhpw4sSJmKDxzTff4NChQzEjjU9TWloarl69ykImefpmZmZw69Yt6HQ6dHZ24urVqwiFQqwzrqmpiY3QEkKWpUsCgaDxmbTahEIhDh8+jMOHD2N4eBjfffcdXn/9dQQCAezfvx8HDx7E7t27YypHkeWL4zi0tbXhzJkz+O2337B161YcOXIEJ0+efKxiCiReTk4Oey0Bs1XjOjs7odPp8OWXX8JkMuGFF15ATU0NampqoNFo4kIEebiNGzfizTffRFNTExQKBcLhMJqbm+N+hqFQCMPDwzCZTAgGgxSAV6ihoSE4HA5wHAepVJqw6ygpKcGrr76K+vp6rF27FjzP45VXXlm0IDY2NoZAIIA7d+5QGHuKrFYrOjs78eeff0Kn06GnpwcFBQWoqanByy+/zAr0EEKeL89kZOxh+vv7cfbsWZw5cwZGoxHNzc04ePAgmpqaVkwBh+eF0WhEW1sbzp49ixs3bqCxsRH79+9HS0tL3PQusnjcbjeuXbvGelI7Ozshk8mg0WiwY8cOVFZWorKy8pHloFcyk8mEwcFBZGdno6ysbN4R3L6+PjalUqVSYdOmTc/6MkmCRU8ZFQgE0Gq1CV3PaTQaMTIygry8vEVvsEdPASwrK6PCEE+A4zjo9XrcunUL169fh06ng8vlgkajgUajQU1NDaqrq5GZmZnoSyWELJ5nN01xIaxWK86dO4dz586ho6MDarUaWq0WWq0Wu3fvpsbjEnPv3j1cvnwZ7e3taG9vR3JyMpqbm3HgwAE0NjZizZo1ib5EgtlF8pHRs+vXr0Ov16O3txdSqRSVlZWoqKjA5s2bUVlZiaKiIlpvQAghT1EwGITRaMTt27dx69Yt6PV63L59G06nk3WOVVVVsbWINH2fkBVlaYWxaMFgEDdu3MDly5dx+fJl6HQ6bNiwAXV1daiurkZVVdWyLlyw3MzMzECv16O7uxs6nQ7t7e0IhULQarWor6+HVqul38cywvM8hoaGoNfrWcOgp6cH4+PjKCkpYeGsoqICpaWltCaBEEIWwGKxwGAwsL+rer0eBoMBubm5MX9XKysrUVBQkOjLJYQk3tINY3MFg0F0dXXh999/R1dXF7q7u+HxeLB9+3ZUVVVh+/bt2LZtG9tLhDy5YDAIg8GA7u5udvT19WHDhg3Yvn07NBoN6urq5i1DTJY3n8+H3t5eNnWmt7cXBoMBfr8fRUVFKC4uZlXtiouLUVRURJUwCSEritvtZlUvBwYG2P07d+4gPT0dpaWlLHBt3rwZ5eXlK3IPUULIgiyfMDYfm80WExhu3LiBqakplJaWoqysDKWlpSgvL0dJSQny8/Np6H+OQCCAgYEBGAwG9Pf3s9u7d+9CrVbHBN0tW7bQtMMVzOl04s6dOzGNj8h5ZmYmC2nRh1qtXrTiAYQQspj8fj9MJlNc2BoYGIDP52OdUXM7p+ZuJUEIIY+wvMPYfDiOQ39/f0y4MBgMmJiYQHFxMfLz85Gfn4+CggJ2X61WJ7QK1mIJh8MYHx9nexiZzWZ2DA0NYWRkBIWFhSy4Rm43btxIG0WSBRsbG4sJZ5HDbDZDKpWy11n0oVar2T5VhBDyrHm9XvZeGP3eGDmcTifUajXrXIqeGUDFSgghT9HzF8YexuPxsA1XzWZzTEAxmUwIh8PIzc2FQqFAdnY2FAoFFAoFVCoVsrKyIJfLoVAoIJFIkJGRkbBRIrfbDa/XC6fTCbvdjvv378Nms8Fut8NqtcJqtbJ/Hxsbg0wmYw3fuQ3hwsJC2kqALKpIZ8Dchk7k9Zeenj5vUMvLy0N2djaysrISWp2OELL8hEIh2Gw2WCwWtvn03L9Dfr8/7r0x+qB1soSQZ2TlhLFHcblcGB0dhcPhwPj4OOx2e1zYsdvtcLlc8Hq9mJ6ehkgkglgsRkZGBjuiR9iSk5Nj1tOsXr2a7bHFcRz793A4DJfLxc5nZmbg9XrBcRy8Xi87XC4XC4MikYiFRaVSCYVCgaysLGRlZbH7ubm5NMJFljS73R4X1IaGhjA6Oorx8XFMTExAoVAgJycH2dnZyMnJgUqlQm5uLruNPO8JIc83nudhs9lw//59jI6Osk7H8fFxdmuxWGC32yGXy5GdnY3c3Nx5Q5dcLk/0t0MIIQCFsSfH8zycTic8Hg8LS263Gz6fD4FAgH2e0+kEz/MAZgtjeDweCASCmDL9KSkpMdO1MjIykJqaCrFYDJFIxIIe7TVCVppgMAir1YqxsbGYBtjo6CisVitGRkZgtVrhdDpZB0QkpMnlcsjlctZBETmXy+U02kbIEhEOh+FwOOBwOFinp81mY+dzX+tr166Ne62rVKqYDhulUkmbsBNClgsKY4SQ5S8QCMSEtMgot8PhYFN3I+cTExOQyWQsmEVGkqPDWnSAk0qlVIiEkAV68OABOI5jYSo6WEVej9Hha3JyEjKZjL3eFAoFlEolux8Z/Y7cpqSkJPpbJISQp4nCGCFkZeF5PiaczRfYIlOTHQ4HOI4Dz/OQSqWQSqWQSCSPdZ9GtMly43a74XQ6wXEcOI57rPtJSUmQSCSQy+VQKpUsWP3bSDVVOiaErGAUxggh5FH8fv+8Dc+FNFJ9Ph+kUilEIhGkUimEQiGEQiEyMjIgkUjYeWZmJsRiMftY9LlQKIRIJIJIJEJycnKifxxkiYlMgXe5XPD5fPD5fHC73WzqvM/ng8vlgsfjYedOpxNer5edcxwHt9sNjuPYc/NJOiBonTIhhDyWSwKBoJEmVhNCyL9IS0uDSqWCSqV67K8Nh8PgOA4ul2vexnKkQcxxHMxm8yMbz8nJyRAKhRCLxWy9aWpqKtLT07FmzRqkpaUhPT0dqampyMjIwOrVq5GZmYlVq1ZBLBYjKSkJUqmUrV2NFBpatWoVG8VLSkqK2S+JQuDChEIhuN1udh69Ztjj8SAYDMLlciEcDsPpdMbculwuFqoiRZymp6cxNTWFBw8ewO/3Y2pqCtPT0/B6vZiZmYHT6YTP5wPP8xAKhQsK+0qlMibcRz4uFoshkUggkUhoTSUhhDxjFMYIIWSRJCUlQSaTQSaTPZXHCwQCLLxFGv+RRnzkY/M14j0eD0ZGRjAzMzNvMOB5PqbKq9vtRigUAgAWAgCwoAfEVogFEFNNNhIAo0VC46MsZN9HgUDAgs7DRAotPcrcwkvAP1VtI6J/NpEwBMyOmj548ABA7PcXHW4B/GsAjg7VUql0QaE6OTmZVdelLUoIIWR5ozBGCCHLREpKClJSUhK2UX0k6AELGwl62Nf+m+jg8zA8zz9yrdHcyrUPEx0wI6KD5tzHiYwwAoBQKKSiEoQQQv4TCmOEEEIWJDU1NSa40H5NhBBCyH9Dk8MJIYQQQgghJAEojBFCCCGEEEJIAvwf7hUrackWTDwAAAAASUVORK5CYII=" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 2: Procedures for failed check-in
</p>
</div>
<p><br><br><br></p>
<!-- <br><br><br><br><br><br><br> -->
<div class="figure"><span style="display:block;" id="fig:map-prep"></span>
<img src="data:image/png;base64,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" alt="Map of potential sampling areas." width="100%" />
<p class="caption">
Figure 3: Map of potential sampling areas.
</p>
</div>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-electrofishing-sites">Table 4: </span>Potential Phase 1 assessment, Phase 2 assessment, and Electrofishing Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
<th style="text-align:left;">
pscis_assessment_comment
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
125000
</td>
<td style="text-align:left;">
tributary to Parsnip River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream continuosly for 350 m to beaver influenced wetland area where walking became difficult. Then stream was visited again upstream at 1.6 km upstream from crossing then again at approximately 2.5 km upstream of crossing. Undercut banks provide areas of deep cover ad Large woody debris is scattered througout. Overhanging vegetationalso provides cover througout. Pools observed were somewhat shallow but were preseetevery 20 - 30 m or so. Minnowtrapping conducted upstream and downstream of crossing. Electrofishing conducted downstream of the crossing. No fish captured upstream of the culvert. First beaver dam located approximately 330m upstream of the culvert.
</td>
</tr>
<tr>
<td style="text-align:right;">
125179
</td>
<td style="text-align:left;">
Unnamed tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration with habitat for rearing and overwintering upstream. Surveyed upstream for 520 m with no barriers to fish passage present. Bull trout and rainbow recorded upstream. Some deep pools for overwintering and rearing. Large woody debris and undercut banks throughout. Sections of gravel suitable for spawning. Good flow. Surveyed downstream for 360 m. No barriers observed and none likely downstream of surveyed section due to gradients. Abundant large woody debris and gravels suitable for spawning.
</td>
</tr>
<tr>
<td style="text-align:right;">
125180
</td>
<td style="text-align:left;">
tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569664
</td>
<td style="text-align:right;">
6053048
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream of PSCIS crossing 125186 for a distance of 515 m. Good flow and abundant cover. Large woody debris and pools throughout. Frequet pockets of gravel suitable for spawning. Good candidate.
</td>
</tr>
<tr>
<td style="text-align:right;">
125231
</td>
<td style="text-align:left;">
tributary to Table River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065140
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed for 600m to new bridge (modelled crossing 16603641). Some deep pools and bounlders, udercut banks, gravels throughout. Abundant large wody debris throughout. Some debris steps from 30 - 70 cms high. No barriers. Rainbow trout known upstream (FIDQ 2020). Good candidate for rehabilitation.
</td>
</tr>
<tr>
<td style="text-align:right;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534600
</td>
<td style="text-align:right;">
6067770
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
Two additional culverts at 0.9m diameter.
</td>
</tr>
<tr>
<td style="text-align:right;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Grate on inlet and beaver influenced wetland upstream. Inlet blocked by beaver debris with beaver trap on inlet. Potentially good candidate for leveler to maintain beaver activity without attempting to remove the animals. Ministry of Transportation chris_culvert_id: 1997066. 13:04:57
</td>
</tr>
<tr>
<td style="text-align:right;">
198668
</td>
<td style="text-align:left;">
Tributary to McLeod Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Abundant gravels, suitable for spawning upstream. Although flows are minimal, the streams does still have water. Models as having over 3 km of habitat upstream below 5%. Although no fish are recorded as present upstream it seems highly likely that this would be a fish bearing stream. Outlet drop is 80cm. Steep section of pipe at the inlet recorded as inlet drop. Ministry of Transportation chris_culvert_id: 1996852. 13:40:04
</td>
</tr>
<tr>
<td style="text-align:right;">
198692
</td>
<td style="text-align:left;">
Tributary to Kerry Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511735
</td>
<td style="text-align:right;">
6059316
</td>
<td style="text-align:left;">
CRKD
</td>
<td style="text-align:left;">
Nice little stream with decent flow for this time of year. Pockets of gravel throughout and healthy shrub and mixed riparian. Fish presence unknown, but seems likely due to proximity to Kerry lake with low gradients. 17:14:13
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fish_passage_assessments" class="csl-entry">
BC Ministry of Environment. 2011. <em>Field Assessment for Determining Fish Passage Status of Closed Bottom Structures</em>. Manual. Victoria, British Columbia: BC Ministry of Environment. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field <span>Key</span> to the <span>Freshwater Fishes</span> of <span>British Columbia</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
