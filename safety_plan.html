<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan Peace 2024" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Safety Plan Peace 2024">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gitbook_on":true,"repo_url":"<a href=\"https://github.com/NewGraphEnvironment/mybookdown-template/\" class=\"uri\">https://github.com/NewGraphEnvironment/mybookdown-template/</a>","report_url":"<a href=\"https://newgraphenvironment.github.io/mybookdown-template\" class=\"uri\">https://newgraphenvironment.github.io/mybookdown-template</a>","update_bib":true,"update_packages":false},"title":"Safety Plan Peace 2024"}
</script>

<title>Safety Plan Peace 2024</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
.title {
font-size: 18px;
color: Black;
text-align: center;
}
.author { 
font-size: 13px;
color: Black;
text-align: center;
}
.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan Peace 2024</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-09<br />
Date Revised: 2024-09-08</p>
</div>
<p><br></p>
<p><br></p>
<div id="safety-plan---2024-073-sern-peace-fish-passage" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2024-073-sern-peace-fish-passage</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/safety_plan_sern-peace-fish-passage.pdf">here</a>.</p>
<p><br></p>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the six permitted electrofishing sites most of the time. Additionally, we may conduct fish passage (Phase 1) and habitat confirmation (Phase 2) assessments in the Carp and Crooked watershed groups as well. A summary of the potential sites for fish passage assessments, habitat confirmation assessments, and electrofishing is provided in Table <a href="#tab:tab-electrofishing-sites">5</a>, with kml (google earth) and gpx (garmin) files downloadable <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/sites_sern-peace-fish-passage_20240908_kml_gpx.zip">here</a>.</p>
<p><br></p>
<p>Georeferenced pdf maps can be accessed and downloaded <a href="https://hillcrestgeo.ca/outgoing/fishpassage/projects/parsnip/">here</a>.</p>
<p><br></p>
<div id="new-graph-employee-information" class="section level2 unnumbered">
<h2>New Graph Employee Information</h2>
<p>Al Irvine<br />
Vehicle: 2013 Toyota Tundra black w/flatdeck and yellow can-am quad<br />
Accommodation: 3396 Rosia Road, Prince George, BC V2K 4Y5</p>
<p><br></p>
<p>Lucy Schick<br />
Vehicle: 2006 Pontiac Vibe red<br />
Accommodation: 6596 Dawson Road, Prince George, BC V2K 5Y4</p>
<p><br></p>
</div>
<div id="crew-members" class="section level2 unnumbered">
<h2>Crew Members</h2>
<p>New Graph Employees Al Irvine and Lucy Schick will be joined by crews from McLoed Lake. All crew member information and emergency contacts can be found below.</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 1: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
must be contacted by inreach first. Cannot cold call
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara@newgraphenvironment.com" class="email">tara@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Jillian Isadore
</td>
<td style="text-align:left;">
<a href="mailto:jillianmarie457@icloud.com" class="email">jillianmarie457@icloud.com</a>
</td>
<td style="text-align:left;">
778-349-8471
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Eugenia Isadore
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
 250-644-0418 
</td>
</tr>
<tr>
<td style="text-align:left;">
Tristan Salonas
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Bianca Prince
</td>
<td style="text-align:left;">
<a href="mailto:biancaprince@hotmail.com" class="email">biancaprince@hotmail.com</a>
</td>
<td style="text-align:left;">
250-730-1480
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
John Demont
</td>
<td style="text-align:left;">
<a href="mailto:justjohndumont@icloud.com" class="email">justjohndumont@icloud.com</a>
</td>
<td style="text-align:left;">
250-720-9700
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
Lucy Schick
</td>
<td style="text-align:left;">
<a href="mailto:lucy@newgraphenvironment.com" class="email">lucy@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
604-741-2032
</td>
<td style="text-align:left;">
807-790-9843
</td>
<td style="text-align:left;">
Sa Boothroyd
</td>
<td style="text-align:left;">
<a href="mailto:saboothroyd@gmail.com" class="email">saboothroyd@gmail.com</a>
</td>
<td style="text-align:left;">
604-740-7199
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="equipment-checklists" class="section level2 unnumbered">
<h2>Equipment Checklists</h2>
<p>PLEASE NOTE THAT EQUIPMENT CHECKLISTS ARE PROVIDED FOR THE OVERALL TEAM AND NOT ALL CREWS ARE REQUIRED TO HAVE ALL EQUIPMENT. ALTHOUGH ENCOURAGED FOR ALL ENVIRONMENTAL SCIENCE TECHNICIANS AND MONITORS TO HAVE THE PERSONAL EQUIPMENT NEW GRAPH ENVIRONMENT WILL HAVE ALL EQUIPMENT NECESSARY TO COMPLETE THE WORK.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR EACH CREW MEMBER INCLUDES GOOD QUALITY AND APPROPRIATELY FITTING LIGHT WEIGHT WADERS AND SEPERATE WADING BOOTS (RUBBER SOLED), HAT, WATER AND A FOOD.</p>
<p><br></p>
<p>MINIMUM REQUIREMENTS FOR FIELD TRUCKS INCLUDE A QUALITY RADIO APPROPRIATE FOR FOREST SERVICE ROADS, OFF-ROAD CAPABLE TIRES IN GOOD CONDITION, SPARE TIRE, JACK, AND TOOLS.</p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:table-equipment">Table 2: </span>Personal Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Personal Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
water
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
food
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
gloves work
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
field vest (surveyors)
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
Wading Boots (Rubber-soled only)
</td>
<td style="text-align:left;">
range finder
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-crew">Table 3: </span>Crew Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
glasses safety
</td>
<td style="text-align:left;">
tape measure eslon
</td>
</tr>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio handheld
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Satelite communicator
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
hard hat
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
steel toed boots
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<div style="border: 1px solid #ddd; padding: 0px; overflow-y: scroll; height:500px; overflow-x: scroll; width:100%; ">
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-truck">Table 4: </span>Truck Equipment Checklist - SEE NOTE ABOVE FOR MINIMUM REQUIREMENTS
</caption>
<thead>
<tr>
<th style="text-align:left;position: sticky; top:0; background-color: #FFFFFF;">
Equipment
</th>
<th style="text-align:left;position: sticky; top:0; background-color: #FFFFFF;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
truck/car jack
</td>
</tr>
<tr>
<td style="text-align:left;">
radio truck
</td>
<td style="text-align:left;">
Battery booster
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Compressor 12V
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
Tow strap
</td>
</tr>
<tr>
<td style="text-align:left;">
truck tow rope
</td>
<td style="text-align:left;">
–
</td>
</tr>
</tbody>
</table>
</div></li>
</ul>
</div>
<div id="nearest-hospitals" class="section level2 unnumbered">
<h2>Nearest Hospitals</h2>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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" alt="University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000" width="100%" />
<p class="caption">
Figure 1: University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000
</p>
</div>
<p><br></p>
</div>
<div id="emergency-response-plan" class="section level2 unnumbered">
<h2>Emergency Response Plan</h2>
<p>New Graph’s detailed emergency response procedures can be found <a href="https://www.newgraphenvironment.com/hsp/plans-and-assessments.html#emergency-response-plan-erp-and-procedures">here</a>. These procedures should be reviewed and an emergency response plan should be completed for each job site. Our Emergency Responce Plan template can be downloaded <a href="https://github.com/NewGraphEnvironment/hsp/blob/master/data/form_templates/ERP_template.pdf">here</a>.</p>
<p><br></p>
</div>
<div id="driving" class="section level2 unnumbered">
<h2>Driving</h2>
<p>We will be driving on forest service roads where it is essential to exercise caution and adhere strictly to all radio use protocols to ensure our safety. Proper communication on these roads helps prevent accidents by keeping everyone informed about vehicle movements and road conditions. Please review the <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#resource-road-safety">resource road safety</a> and <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#radio-use">radio use</a> sections of our Health and Safety plan so that everyone stays safe.</p>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the 5 or 6 permitted electrofishing sites most of the time. In addition we may spend some time with fish passage assessments in areas of not only the Parsnip watershed group but also the Carp and Crooked watershed groups.</p>
<p>Field work methods will result in products feeding reporting formats such as <a href="https://www.newgraphenvironment.com/fish_passage_peace_2022_reporting/">here</a> for 2022 and <a href="https://www.newgraphenvironment.com/fish_passage_peace_2023_reporting/">here</a> for 2023. We generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(BC Ministry of Environment 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data, and the Field Guide to these site cards can be found <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a>.</p>
<p><br></p>
<p>We have PIT tagging equipment so we could consider <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">tagging</a> fish captured at electrofishing sites to help us better understand population sizes and fish movement upstream and downstream of sites over the years.</p>
<p><br></p>
<p>We use digital field form using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Please see our <a href="https://www.newgraphenvironment.com/fish_passage_guidebook/">Fish Passage Guidebook</a> for instructions on how to set up Mergin Maps and use our digital field forms. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) each morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,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" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 2: Procedures for failed check-in
</p>
</div>
<p><br><br><br></p>
<!-- <br><br><br><br><br><br><br> -->
<div class="figure"><span style="display:block;" id="fig:map-prep"></span>
<img src="data:image/png;base64,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ITgMoPiRj3xEenp6zOd73/uedHR0mMkAL0FnDW9729tk7969xmkDjzPvpZdeOmINSI7+9E//VO6//36prKyUH/3oR9LS0iJXXHHFiPl1Z+kgMFobY3t6xzveIdu2bZNgMCi/+MUv5IEHHpCbb77ZkKTxjo+E0De/+U255557ZNeuXfLCCy+YD9vlddddN1J23VciCPT19cldd90lR48eldtuu23wribShv7mb/5G2G5Icrjg8x//8R+ybt06Wbp06WA5hRs//OEPheeEQiF5+umn5d577zXEPhAIFGbTbUVAESgBBFSCVAIPUW9BEZgMApT+cKDnh17pChNXXH/wgx8YQmOvxlIC8Nd//dfypje9SdasWWPOa2xslO9+97vmVE4U/uIv/kKYn5KA4vSTn/xEOInh5JUTi6amJnnXu94lt956q6xfv744u/4uAQTGamO8vZ/97Gdmpf5b3/qWudt4PC633367aSMf+MAHxj0+EkT79+8XnvuWt7xlpMO6rwQReOaZZ+Sf/umfzKLNypUrh9zheG1s3759wr7tpz/9qdTV1ZlzP//5z8vXv/71ERdvKDkigfra174mF1xwgbCNc+GH/Rq/NSkCikBpIaA2SKX1PPVuFIFxEeBK/a9//Wv54he/OGyltLOz06i/vfa1rx0sx1a/oyoK07XXXit/+Zd/OXicUiGmrq6uwX2FG0888YSwPJIjpuXLlxu1vd/+9reF2XS7hBAYq43xNik1eve73z14x1yBp+ql3cbGOz544sAG3TZzAquEuxiZ0v1Nl/B/9Vd/JX/wB38gb3/724fd6HhtiP3V+973vkFyxALY11G6nc/nh5X37LPPGlJPcsTkdrvlda97nWg/Ngwq3aEIlAQCSpBK4jHqTSgCE0fgqquukv/+7/+Wyy+/fNhJNTU18olPfMLECLEPPvLII0Y/35580t5o9erVJpYIV3C5osp9VE0ZKZ08eXKYXj/1/Nva2kbKrvtKAIGx2hhvj+SosP2RmG/fvl02bdpk7n6848UQHTlyRCj9pDSTk963vvWt8p3vfMe00eK8+rs0ECCppnT6/e9/vyErxXc1Xhti+ysk6Tyffd3GjRuHSdZ5jP3Y4sWLuTmY2I9RlY9tT5MioAiUFgJKkErreerdKALjIlBdXT3ihGKkEw8dOmRU6WgvUqw+d9999xl9/N27d5sJ6UhBF6mGwglEWVnZkOL5m5NiTaWJwGTaWCqVEprCUrJINc7iNN5x5j9w4IA5jZKkD3/4w3LjjTca+5CvfOUrxcXp7xJBgBIctrOJpIm0IarKvfTSS/Kxj31sxCIpWSrux+jghuSItm6aFAFFoLQQUBuk0nqeejeKwCACHOz37Nkz+Puiiy6StWvXDv4eb+Pll1+WT33qU3LDDTeYVfni/LQ5evOb32w8QH3mM58x6i5UOSlMLpfLRKsnUSpM/G2r3BXu1+35hcCZtrHe3l759Kc/Lfz+6le/Kh6PZwgA4x23M9O5A73V0TaOiV4X2fbuvvtu43CkeGJrn6ffcx8BLqQ8/PDDgxWlvRD7pImmibSh73//+/Kf//mf8vd///ejqmmybY7Uj7EeVOfTpAgoAqWFgBKk0nqeejeKwCACdKlNz3F2oq3QRAkS7YY++9nPyp133ikf/OAH7SKGfXMVl+6ZadP06KOPGp38wkx0AkF3uLQXKEyctDQ0NBTu0u15iMCZtDFKFj/+8Y8bovyNb3xDysvLhyAw3vHCzHQPbpMjez9VqEiQRlr5t/Po99xHgNIZSqvtRFu1iRKk8doQpT+UMv7ud7+TL3/5y8PCHdjX5DfVj+kprzCxH2O/WuievvC4bisCisD8RUAJ0vx9dlpzRWBMBGi4PJLx8pgn4SCJzt/93d8ZVZM//MM/HJadk1ramNhe7piBXupGW6VftWqVUA2PXuvsxIm1ehuz0Zi/31NtY62trfLRj37U2LJRva54gjne8WLE6LGMbpq/9KUvDR6idIsEvZg4DWbQjXmBAL3T/dd//dek6zqRNsR+ju3k29/+trCfGiuxHgyBQCkSF4aY2K8V2yWNVYYeUwQUgfmDgNogzZ9npTVVBGYcgVOnTsk//uM/mtgxK1asMJMHTiD4sW2GSI6ojkL7JNp8MBYIJwr0JsVEN948bkuNSIS4QktSRO9QP//5z4U2Aa9//etn/H70AnMTAa7aMz4WSTbjadltjM4WmMY7zjxsY2x3TAzYSYchbIucwDIOErep8kk7EU0LD4Hx2tCDDz5o+qX3vOc9pq+y2yC/2TaZCtvYTTfdNLiPkicGyaa3RoYs0KQIKAKlh4BKkErvmeodKQJTRoCThlgsZlzXFruvpT0SpUAMxrhz507hxMLrX/7pqQAABg5JREFU9ZrVVAZqpKodEycO9CDG35ycUtWJgWVpPE89fq640mZJI9BP+THN6xPpypsBYpmKDeIvu+wy40VxrONUhWJiG2P8mXPOOcd4SWT7oqoe49hwgnvLLbeYskxm/bOgEBivjbENUerI9M///M/DsPnNb35j7IoK2xilnJQ4MVYSiRO96DF2F8m5JkVAESg9BBxY0R3u8L/07lPvSBFQBKYZAarVUQef3u1oED9eotSI+anLr0kRmAkEKD2i+3i2MZJ3TYrATCBA9b3a2lrjgGYmytcyFQFFYPYRUII0+89Aa6AIKAKKgCKgCCgCioAioAgoAnMEAbVBmiMPQquhCCgCioAioAgoAoqAIqAIKAKzj4ASpNl/BloDRUARUAQUAUVAEVAEFAFFQBGYIwgoQZojD0KroQgoAoqAIqAIKAKKgCKgCCgCs4+AEqTZfwZaA0VAEVAEFAFFQBFQBBQBRUARmCMIKEGaIw9Cq6EIKAKKgCKgCCgCioAioAgoArOPgBKk2X8GWgNFQBFQBBSBGUSAcXFaWlpm8ApatCKgCCgCikApIaBuvkvpaeq9KAKKgCKgCAxDYPPmzRIKheTpp58edkx3KAKKgCKgCCgCxQioBKkYEf2tCCgCioAioAgoAoqAIqAIKAILFgElSAv20euNKwKKgCKgCCgCioAioAgoAopAMQLu4h36WxFQBBQBRUARKHUE4vG4fO9735Pnn39estmsnH/++fKBD3xAKioqBm/93/7t36SyslKuv/56ufvuu03exsZGueOOO+TKK68czKcbioAioAgoAqWFgNogldbz1LtRBBQBRUARKEKg2AaJThuuuuoq4fe1114rPp9PHn30UUOO7r33XrnoootMCZdeeqk51t7ebvJu2bLFkKREIiH33HOP/NEf/VHRlfSnIqAIKAKKQCkgoCp2pfAU9R4UAUVAEVAEJozA+973PmltbZWtW7fKww8/LPfff7+8+OKLkslk5D3veY/5tgt74okn5LbbbjP5H3vsMdm+fbsEAgH5yle+YmfRb0VAEVAEFIESQ0AJUok9UL0dRUARUAQUgdERePXVV+Whhx4y6nSUENlp3bp18slPflJ27doljz/+uL3bSJC+8IUvGFLEnWvXrjXqeE1NTYN5dEMRUAQUAUWgtBBQglRaz1PvRhFQBBQBRWAMBPbs2WOOFpIjO/tll11mNvfu3WvvkqVLl4rX6x38zY26ujqhDZMmRUARUAQUgdJEQAlSaT5XvStFQBFQBBSBERA4deqU2VtWVjbsaDgcNvvS6fTgsWAwOLhtbzgcDsnn8/ZP/VYEFAFFQBEoMQSUIJXYA9XbUQQUAUVAERgdgdWrV5uDR48eHZbJ3nfBBRcMO6Y7FAFFQBFQBBYOAkqQFs6z1jtVBBQBRWDBI7Bx40bjuptuu4ulQN///vcNPkqQFnwzUQAUAUVggSOgBGmBNwC9fUVAEVAEFhICVKOj0wV6rbv99ttl27Zt8sILL8gHP/hBoYvvL37xi0NiIS0kbPReFQFFQBFQBCwENFCstgRFQBFQBBSBBYXAn/3ZnxmvdPRaZwd8pRe7f/mXf5G77rprQWGhN6sIKAKKgCIwHAENFDscE92jCCgCioAisEAQOH78uLhcLlm0aNECuWO9TUVAEVAEFIHxEFCCNB5CelwRUAQUAUVAEVAEFAFFQBFQBBYMAmqDtGAetd6oIqAIKAKKgCKgCCgCioAioAiMh4ASpPEQ0uOKgCKgCCgCioAioAgoAoqAIrBgEFCCtGAetd6oIqAIKAKKgCKgCCgCioAioAiMh4ASpPEQ0uOKgCKgCCgCioAioAgoAoqAIrBgEFCCtGAetd6oIqAIKAKKgCKgCCgCioAioAiMh4ASpPEQ0uOKgCKgCCgCioAioAgoAoqAIrBgEFCCtGAetd6oIqAIKAKKgCKgCCgCioAioAiMh4ASpPEQ0uOKgCKgCCgCioAioAgoAoqAIrBgEFCCtGAetd6oIqAIKAKKgCKgCCgCioAioAiMh4ASpPEQ0uOKgCKgCCgCioAioAgoAoqAIrBgEPj/ATX951wzTl8xAAAAAElFTkSuQmCC" alt="Map of potential sampling areas." width="100%" />
<p class="caption">
Figure 3: Map of potential sampling areas.
</p>
</div>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-electrofishing-sites">Table 5: </span>Potential Phase 1 assessment, Phase 2 assessment, and Electrofishing Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
<th style="text-align:left;">
pscis_assessment_comment
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
125000
</td>
<td style="text-align:left;">
tributary to Parsnip River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream continuosly for 350 m to beaver influenced wetland area where walking became difficult. Then stream was visited again upstream at 1.6 km upstream from crossing then again at approximately 2.5 km upstream of crossing. Undercut banks provide areas of deep cover ad Large woody debris is scattered througout. Overhanging vegetationalso provides cover througout. Pools observed were somewhat shallow but were preseetevery 20 - 30 m or so. Minnowtrapping conducted upstream and downstream of crossing. Electrofishing conducted downstream of the crossing. No fish captured upstream of the culvert. First beaver dam located approximately 330m upstream of the culvert.
</td>
</tr>
<tr>
<td style="text-align:right;">
125179
</td>
<td style="text-align:left;">
Unnamed tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration with habitat for rearing and overwintering upstream. Surveyed upstream for 520 m with no barriers to fish passage present. Bull trout and rainbow recorded upstream. Some deep pools for overwintering and rearing. Large woody debris and undercut banks throughout. Sections of gravel suitable for spawning. Good flow. Surveyed downstream for 360 m. No barriers observed and none likely downstream of surveyed section due to gradients. Abundant large woody debris and gravels suitable for spawning.
</td>
</tr>
<tr>
<td style="text-align:right;">
125180
</td>
<td style="text-align:left;">
tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569664
</td>
<td style="text-align:right;">
6053048
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream of PSCIS crossing 125186 for a distance of 515 m. Good flow and abundant cover. Large woody debris and pools throughout. Frequet pockets of gravel suitable for spawning. Good candidate.
</td>
</tr>
<tr>
<td style="text-align:right;">
125231
</td>
<td style="text-align:left;">
tributary to Table River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065140
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed for 600m to new bridge (modelled crossing 16603641). Some deep pools and bounlders, udercut banks, gravels throughout. Abundant large wody debris throughout. Some debris steps from 30 - 70 cms high. No barriers. Rainbow trout known upstream (FIDQ 2020). Good candidate for rehabilitation.
</td>
</tr>
<tr>
<td style="text-align:right;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534600
</td>
<td style="text-align:right;">
6067770
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
Two additional culverts at 0.9m diameter.
</td>
</tr>
<tr>
<td style="text-align:right;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Grate on inlet and beaver influenced wetland upstream. Inlet blocked by beaver debris with beaver trap on inlet. Potentially good candidate for leveler to maintain beaver activity without attempting to remove the animals. Ministry of Transportation chris_culvert_id: 1997066. 13:04:57
</td>
</tr>
<tr>
<td style="text-align:right;">
198668
</td>
<td style="text-align:left;">
Tributary to McLeod Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Abundant gravels, suitable for spawning upstream. Although flows are minimal, the streams does still have water. Models as having over 3 km of habitat upstream below 5%. Although no fish are recorded as present upstream it seems highly likely that this would be a fish bearing stream. Outlet drop is 80cm. Steep section of pipe at the inlet recorded as inlet drop. Ministry of Transportation chris_culvert_id: 1996852. 13:40:04
</td>
</tr>
<tr>
<td style="text-align:right;">
198692
</td>
<td style="text-align:left;">
Tributary to Kerry Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511735
</td>
<td style="text-align:right;">
6059316
</td>
<td style="text-align:left;">
CRKD
</td>
<td style="text-align:left;">
Nice little stream with decent flow for this time of year. Pockets of gravel throughout and healthy shrub and mixed riparian. Fish presence unknown, but seems likely due to proximity to Kerry lake with low gradients. 17:14:13
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fish_passage_assessments" class="csl-entry">
BC Ministry of Environment. 2011. <em>Field Assessment for Determining Fish Passage Status of Closed Bottom Structures</em>. Manual. Victoria, British Columbia: BC Ministry of Environment. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field <span>Key</span> to the <span>Freshwater Fishes</span> of <span>British Columbia</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
