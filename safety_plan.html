<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta name="viewport" content="width=device-width">
<meta property="og:title" content="Safety Plan Peace 2024" />




<meta name="author" content="Al Irvine" />


<meta name="description" content="Safety Plan Peace 2024">

<script id="pandoc-meta" type="application/json">
{"author":"Al Irvine","biblio-style":"apalike","bibliography":"references.bib","knit":"pagedown::chrome_print","link-citations":false,"links-to-footnotes":false,"newpage_html_class":"page-break-after","output":{"pagedown::html_letter":{"css":["style-pagedown.css","default","letter"],"self_contained":true}},"paged-footnotes":false,"params":{"gitbook_on":true,"repo_url":"<a href=\"https://github.com/NewGraphEnvironment/mybookdown-template/\" class=\"uri\">https://github.com/NewGraphEnvironment/mybookdown-template/</a>","report_url":"<a href=\"https://newgraphenvironment.github.io/mybookdown-template\" class=\"uri\">https://newgraphenvironment.github.io/mybookdown-template</a>","update_bib":true,"update_packages":false},"title":"Safety Plan Peace 2024"}
</script>

<title>Safety Plan Peace 2024</title>


<style type="text/css">:root {
--background: whitesmoke;
--pagedjs-width: 6in;
--pagedjs-height: 9in;
--color-paper: white;
--color-mbox: rgba(0, 0, 0, 0.2);
--running-title-width: 2.5in;
--screen-pages-spacing: 5mm;
}
html {
line-height: 1.3;
}

a[href^="http"]:not([class="uri"])::after {
content: " (" attr(href) ")";
font-size: 90%;
hyphens: none;
word-break: break-all;
}
.references a[href^=http]:not([class=uri])::after {
content: none;
}
.main a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page) ")";
}
.main a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: " (page " target-counter(attr(href), page, lower-roman) ")";
}

.sourceCode a[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after,
.sourceCode a.front-matter-ref[href^="#"]:not([class^="footnote-"]):not([href*=":"])::after {
content: unset;
}

.toc ul, .lot ul, .lof ul {
list-style: none;
padding-left: 0;
overflow-x: clip;
}
.toc li li {
padding-left: 1em;
}
.toc a, .lot a, .lof a {
text-decoration: none;
background: white;
padding-right: .33em;
}
.toc a::after, .lot a::after, .lof a::after {

content: target-counter(attr(href), page);
float: right;
background: white;
}
.toc a.front-matter-ref::after, .lot a.front-matter-ref::after, .lof a.front-matter-ref::after {

content: target-counter(attr(href), page, lower-roman);
}
.toc .leaders::before, .lot .leaders::before, .lof .leaders::before {
float: left;
width: 0;
white-space: nowrap;
content: ". . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . ";
}

.chapter > h1 > .header-section-number::before, .chapter-ref > .toc-section-number::before {
content: var(--chapter-name-before, "Chapter ");
}
.chapter > h1 > .header-section-number::after, .chapter-ref > .toc-section-number::after {
content: var(--chapter-name-after, "");
}

.subtitle span {
font-size: .9em;
}
img {
max-width: 100%;
}
pre {
padding: 1em;
white-space: pre-wrap;
}
pre[class] {
background: #f9f9f9;
}
abbr {
text-decoration: none;
}
@media screen {
div.sourceCode {
overflow: visible !important;
}
a.sourceLine::before {
text-decoration: unset !important;
}
}
pre.numberSource a.sourceLine {
left: 0 !important;
text-indent: -5em
}
pre.numberSource {
margin-left: 0 !important;
}
table {
margin: auto;
border-top: 1px solid #666;
border-bottom: 1px solid #666;
}
table thead th {
border-bottom: 1px solid #ddd;
}
thead, tfoot, tr:nth-child(even) {
background: #eee;
}

.kable_wrapper > tbody > tr > td {
vertical-align: top;
}
.footnotes {
font-size: 90%;
}
.footnotes hr::before {
content: "Footnotes:";
}
.footnotes hr {
border: none;
}
.footnote-break {
width: 1in;
}
body {
hyphens: auto;
}
code {
hyphens: none;
}

@media screen {
body {
background-color: var(--background);
margin: var(--screen-pages-spacing) auto 0 auto;
}
.pagedjs_pages {
display: flex;
max-width: calc(var(--pagedjs-width) * 2);
flex: 0;
flex-wrap: wrap;
margin: 0 auto;
}
.pagedjs_page {
background-color: var(--color-paper);
box-shadow: 0 0 0 1px var(--color-mbox);
flex-shrink: 0;
flex-grow: 0;
margin: auto auto var(--screen-pages-spacing) auto;
}
}

@media screen and (min-width: 12.32in) {
.pagedjs_page {
margin: auto 0 var(--screen-pages-spacing) 0;
}
.pagedjs_first_page {
margin-left: var(--pagedjs-width);
}
}

@media screen and (max-width:1180px) {
body {
width: calc(var(--pagedjs-width) + 2 * var(--screen-pages-spacing));
}
}
</style>
<style type="text/css">body {
font-family: Palatino, "Palatino Linotype", "Palatino LT STD", Georgia, 'Source Han Serif', 'Songti SC', serif;
line-height: 1.5em;
}
.title-page {
display: none;
}
.from, .date {
text-align: right;
}
.from p {
text-align: left;
display: inline-block;
}
.logo {
position: running(header-logo);
height: 1cm;
}
.date {
margin-top: 4em;
}
@page {
size: letter;
margin: 4cm 3cm;
@top-left {
content: element(header-logo);
}
@bottom-right {
content: counter(page);
}
}
@media screen and (min-width: 12.32in) {
.pagedjs_page, .pagedjs_first_page {
margin: auto auto 5mm auto;
}
}
</style>
<script>// Configuration script for paged.js

(function() {
  // Retrieve previous config object if defined
  window.PagedConfig = window.PagedConfig || {};
  const {before: beforePaged, after: afterPaged} = window.PagedConfig;

  // utils
  const insertCSS = text => {
    let style = document.createElement('style');
		style.type = 'text/css';
		style.appendChild(document.createTextNode(text));
    document.head.appendChild(style);
  };

  // Util function for front and back covers images
  const insertCSSForCover = type => {
    const links = document.querySelectorAll('link[id^=' + type + ']');
    if (!links.length) return;
    const re = new RegExp(type + '-\\d+');
    let text = ':root {--' + type + ': var(--' + type + '-1);';
    for (const link of links) {
      text += '--' + re.exec(link.id)[0] + ': url("' + link.href + '");';
    }
    text += '}';
    insertCSS(text);
  };

  const insertPageBreaksCSS = () => {
    insertCSS(`
    .page-break-after {break-after: page;}
    .page-break-before {break-before: page;}
    `);
  };

  window.PagedConfig.before = async () => {
    // Front and back covers support
    let frontCover = document.querySelector('.front-cover');
    let backCover = document.querySelector('.back-cover');
    if (frontCover) document.body.prepend(frontCover);
    if (backCover) document.body.append(backCover);
    insertCSSForCover('front-cover');
    insertCSSForCover('back-cover');
    insertPageBreaksCSS();

    if (beforePaged) await beforePaged();
  };

  // from https://stackoverflow.com/q/21647928
  const toUTF16BE = x => {
    let res = '';
    for (i=0; i < x.length; i++) {
      let hex = x.charCodeAt(i).toString(16);
      hex = ('000' + hex).slice(-4);
      res += hex
    }
    res = 'feff' + res ;
    return res;
  }

  const findPage = el => {
    while (el.parentElement) {
      el = el.parentElement;
      if (el.getAttribute('data-page-number')) {
        return parseInt(el.getAttribute('data-page-number'));
      }
    }
    return null;
  };

  const tocEntriesInfos = ul => {
    let result = []; // where we store the results
    // if there is no element, return an empty array
    if (!ul) {
      return result;
    }
    const tocEntries = ul.children; // tocEntries are 'li' elements

    for (const li of tocEntries) {
      // Since parts entries in TOC have no anchor,
      // do not use them in the PDF outline.
      if (li.classList.contains('part')) {
        continue;
      }

      // get the title and encode it in UTF16BE (pdfmark is encoded in UTF16BE with BOM)
      const title = toUTF16BE(li.querySelector('a').textContent);

      // get the page number
      const href = li.querySelector('a').getAttribute('href');
      const el = document.getElementById(href.substring(1));
      const page = findPage(el);

      // get the children
      children = tocEntriesInfos(li.querySelector('ul'));

      result.push({
        title: title,
        page: page,
        children: children
      });
    }

    return result;
  };
  window.PagedConfig.after = (flow) => {
    // force redraw, see https://github.com/rstudio/pagedown/issues/35#issuecomment-475905361
    // and https://stackoverflow.com/a/24753578/6500804
    document.body.style.display = 'none';
    document.body.offsetHeight;
    document.body.style.display = '';

    // run previous PagedConfig.after function if defined
    if (afterPaged) afterPaged(flow);

    // pagedownListener is a binding added by the chrome_print function
    // this binding exists only when chrome_print opens the html file
    if (window.pagedownListener) {
      // the html file is opened for printing
      // call the binding to signal to the R session that Paged.js has finished
      const tocList = flow.source.querySelector('.toc > ul');
      const tocInfos = tocEntriesInfos(tocList);
      pagedownListener(JSON.stringify({
        pagedjs: true,
        pages: flow.total,
        elapsedtime: flow.performance,
        tocInfos: tocInfos
      }));
      return;
    }
    if (sessionStorage.getItem('pagedown-scroll')) {
      // scroll to the last position before the page is reloaded
      window.scrollTo(0, sessionStorage.getItem('pagedown-scroll'));
      return;
    }
    if (window.location.hash) {
      const id = decodeURIComponent(window.location.hash).replace(/^#/, '');
      document.getElementById(id).scrollIntoView({behavior: 'smooth'});
    }
  };
})();
</script>
<script>/**
 * @license Paged.js v0.1.43 | MIT | https://gitlab.pagedmedia.org/tools/pagedjs
 */

(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = global || self, global.PagedPolyfill = factory());
}(this, (function () { 'use strict';

	function createCommonjsModule(fn, module) {
		return module = { exports: {} }, fn(module, module.exports), module.exports;
	}

	function getCjsExportFromNamespace (n) {
		return n && n['default'] || n;
	}

	var isImplemented = function () {
		var assign = Object.assign, obj;
		if (typeof assign !== "function") return false;
		obj = { foo: "raz" };
		assign(obj, { bar: "dwa" }, { trzy: "trzy" });
		return (obj.foo + obj.bar + obj.trzy) === "razdwatrzy";
	};

	var isImplemented$1 = function () {
		try {
			Object.keys("primitive");
			return true;
		} catch (e) {
	 return false;
	}
	};

	// eslint-disable-next-line no-empty-function
	var noop = function () {};

	var _undefined = noop(); // Support ES3 engines

	var isValue = function (val) {
	 return (val !== _undefined) && (val !== null);
	};

	var keys = Object.keys;

	var shim = function (object) {
		return keys(isValue(object) ? Object(object) : object);
	};

	var keys$1 = isImplemented$1()
		? Object.keys
		: shim;

	var validValue = function (value) {
		if (!isValue(value)) throw new TypeError("Cannot use null or undefined");
		return value;
	};

	var max   = Math.max;

	var shim$1 = function (dest, src /*, …srcn*/) {
		var error, i, length = max(arguments.length, 2), assign;
		dest = Object(validValue(dest));
		assign = function (key) {
			try {
				dest[key] = src[key];
			} catch (e) {
				if (!error) error = e;
			}
		};
		for (i = 1; i < length; ++i) {
			src = arguments[i];
			keys$1(src).forEach(assign);
		}
		if (error !== undefined) throw error;
		return dest;
	};

	var assign = isImplemented()
		? Object.assign
		: shim$1;

	var forEach = Array.prototype.forEach, create = Object.create;

	var process = function (src, obj) {
		var key;
		for (key in src) obj[key] = src[key];
	};

	// eslint-disable-next-line no-unused-vars
	var normalizeOptions = function (opts1 /*, …options*/) {
		var result = create(null);
		forEach.call(arguments, function (options) {
			if (!isValue(options)) return;
			process(Object(options), result);
		});
		return result;
	};

	// Deprecated

	var isCallable = function (obj) {
	 return typeof obj === "function";
	};

	var str = "razdwatrzy";

	var isImplemented$2 = function () {
		if (typeof str.contains !== "function") return false;
		return (str.contains("dwa") === true) && (str.contains("foo") === false);
	};

	var indexOf = String.prototype.indexOf;

	var shim$2 = function (searchString/*, position*/) {
		return indexOf.call(this, searchString, arguments[1]) > -1;
	};

	var contains = isImplemented$2()
		? String.prototype.contains
		: shim$2;

	var d_1 = createCommonjsModule(function (module) {

	var d;

	d = module.exports = function (dscr, value/*, options*/) {
		var c, e, w, options, desc;
		if ((arguments.length < 2) || (typeof dscr !== 'string')) {
			options = value;
			value = dscr;
			dscr = null;
		} else {
			options = arguments[2];
		}
		if (dscr == null) {
			c = w = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
			w = contains.call(dscr, 'w');
		}

		desc = { value: value, configurable: c, enumerable: e, writable: w };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};

	d.gs = function (dscr, get, set/*, options*/) {
		var c, e, options, desc;
		if (typeof dscr !== 'string') {
			options = set;
			set = get;
			get = dscr;
			dscr = null;
		} else {
			options = arguments[3];
		}
		if (get == null) {
			get = undefined;
		} else if (!isCallable(get)) {
			options = get;
			get = set = undefined;
		} else if (set == null) {
			set = undefined;
		} else if (!isCallable(set)) {
			options = set;
			set = undefined;
		}
		if (dscr == null) {
			c = true;
			e = false;
		} else {
			c = contains.call(dscr, 'c');
			e = contains.call(dscr, 'e');
		}

		desc = { get: get, set: set, configurable: c, enumerable: e };
		return !options ? desc : assign(normalizeOptions(options), desc);
	};
	});

	var validCallable = function (fn) {
		if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
		return fn;
	};

	var eventEmitter = createCommonjsModule(function (module, exports) {

	var apply = Function.prototype.apply, call = Function.prototype.call
	  , create = Object.create, defineProperty = Object.defineProperty
	  , defineProperties = Object.defineProperties
	  , hasOwnProperty = Object.prototype.hasOwnProperty
	  , descriptor = { configurable: true, enumerable: false, writable: true }

	  , on, once, off, emit, methods, descriptors, base;

	on = function (type, listener) {
		var data;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) {
			data = descriptor.value = create(null);
			defineProperty(this, '__ee__', descriptor);
			descriptor.value = null;
		} else {
			data = this.__ee__;
		}
		if (!data[type]) data[type] = listener;
		else if (typeof data[type] === 'object') data[type].push(listener);
		else data[type] = [data[type], listener];

		return this;
	};

	once = function (type, listener) {
		var once, self;

		validCallable(listener);
		self = this;
		on.call(this, type, once = function () {
			off.call(self, type, once);
			apply.call(listener, this, arguments);
		});

		once.__eeOnceListener__ = listener;
		return this;
	};

	off = function (type, listener) {
		var data, listeners, candidate, i;

		validCallable(listener);

		if (!hasOwnProperty.call(this, '__ee__')) return this;
		data = this.__ee__;
		if (!data[type]) return this;
		listeners = data[type];

		if (typeof listeners === 'object') {
			for (i = 0; (candidate = listeners[i]); ++i) {
				if ((candidate === listener) ||
						(candidate.__eeOnceListener__ === listener)) {
					if (listeners.length === 2) data[type] = listeners[i ? 0 : 1];
					else listeners.splice(i, 1);
				}
			}
		} else {
			if ((listeners === listener) ||
					(listeners.__eeOnceListener__ === listener)) {
				delete data[type];
			}
		}

		return this;
	};

	emit = function (type) {
		var i, l, listener, listeners, args;

		if (!hasOwnProperty.call(this, '__ee__')) return;
		listeners = this.__ee__[type];
		if (!listeners) return;

		if (typeof listeners === 'object') {
			l = arguments.length;
			args = new Array(l - 1);
			for (i = 1; i < l; ++i) args[i - 1] = arguments[i];

			listeners = listeners.slice();
			for (i = 0; (listener = listeners[i]); ++i) {
				apply.call(listener, this, args);
			}
		} else {
			switch (arguments.length) {
			case 1:
				call.call(listeners, this);
				break;
			case 2:
				call.call(listeners, this, arguments[1]);
				break;
			case 3:
				call.call(listeners, this, arguments[1], arguments[2]);
				break;
			default:
				l = arguments.length;
				args = new Array(l - 1);
				for (i = 1; i < l; ++i) {
					args[i - 1] = arguments[i];
				}
				apply.call(listeners, this, args);
			}
		}
	};

	methods = {
		on: on,
		once: once,
		off: off,
		emit: emit
	};

	descriptors = {
		on: d_1(on),
		once: d_1(once),
		off: d_1(off),
		emit: d_1(emit)
	};

	base = defineProperties({}, descriptors);

	module.exports = exports = function (o) {
		return (o == null) ? create(base) : defineProperties(Object(o), descriptors);
	};
	exports.methods = methods;
	});
	var eventEmitter_1 = eventEmitter.methods;

	/**
	 * Hooks allow for injecting functions that must all complete in order before finishing
	 * They will execute in parallel but all must finish before continuing
	 * Functions may return a promise if they are asycn.
	 * From epubjs/src/utils/hooks
	 * @param {any} context scope of this
	 * @example this.content = new Hook(this);
	 */
	class Hook {
		constructor(context){
			this.context = context || this;
			this.hooks = [];
		}

		/**
		 * Adds a function to be run before a hook completes
		 * @example this.content.register(function(){...});
		 * @return {undefined} void
		 */
		register(){
			for(var i = 0; i < arguments.length; ++i) {
				if (typeof arguments[i]  === "function") {
					this.hooks.push(arguments[i]);
				} else {
					// unpack array
					for(var j = 0; j < arguments[i].length; ++j) {
						this.hooks.push(arguments[i][j]);
					}
				}
			}
		}

		/**
		 * Triggers a hook to run all functions
		 * @example this.content.trigger(args).then(function(){...});
		 * @return {Promise} results
		 */
		trigger(){
			var args = arguments;
			var context = this.context;
			var promises = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				if(executing && typeof executing["then"] === "function") {
					// Task is a function that returns a promise
					promises.push(executing);
				}
				// Otherwise Task resolves immediately, add resolved promise with result
				promises.push(new Promise((resolve, reject) => {
					resolve(executing);
				}));
			});


			return Promise.all(promises);
		}

		/**
	   * Triggers a hook to run all functions synchronously
	   * @example this.content.trigger(args).then(function(){...});
	   * @return {Array} results
	   */
		triggerSync(){
			var args = arguments;
			var context = this.context;
			var results = [];

			this.hooks.forEach(function(task) {
				var executing = task.apply(context, args);

				results.push(executing);
			});


			return results;
		}

		// Adds a function to be run before a hook completes
		list(){
			return this.hooks;
		}

		clear(){
			return this.hooks = [];
		}
	}

	function getBoundingClientRect(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getBoundingClientRect !== "undefined") {
			rect = element.getBoundingClientRect();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getBoundingClientRect();
		}
		return rect;
	}

	function getClientRects(element) {
		if (!element) {
			return;
		}
		let rect;
		if (typeof element.getClientRects !== "undefined") {
			rect = element.getClientRects();
		} else {
			let range = document.createRange();
			range.selectNode(element);
			rect = range.getClientRects();
		}
		return rect;
	}

	/**
	 * Generates a UUID
	 * based on: http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript
	 * @returns {string} uuid
	 */
	function UUID() {
		var d = new Date().getTime();
		if (typeof performance !== "undefined" && typeof performance.now === "function") {
			d += performance.now(); //use high-precision timer if available
		}
		return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function (c) {
			var r = (d + Math.random() * 16) % 16 | 0;
			d = Math.floor(d / 16);
			return (c === "x" ? r : (r & 0x3 | 0x8)).toString(16);
		});
	}

	function attr(element, attributes) {
		for (var i = 0; i < attributes.length; i++) {
			if (element.hasAttribute(attributes[i])) {
				return element.getAttribute(attributes[i]);
			}
		}
	}

	/* Based on by https://mths.be/cssescape v1.5.1 by @mathias | MIT license
	 * Allows # and .
	 */
	function querySelectorEscape(value) {
		if (arguments.length == 0) {
			throw new TypeError("`CSS.escape` requires an argument.");
		}
		var string = String(value);

		var length = string.length;
		var index = -1;
		var codeUnit;
		var result = "";
		var firstCodeUnit = string.charCodeAt(0);
		while (++index < length) {
			codeUnit = string.charCodeAt(index);



			// Note: there’s no need to special-case astral symbols, surrogate
			// pairs, or lone surrogates.

			// If the character is NULL (U+0000), then the REPLACEMENT CHARACTER
			// (U+FFFD).
			if (codeUnit == 0x0000) {
				result += "\uFFFD";
				continue;
			}

			if (
				// If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
				// U+007F, […]
				(codeUnit >= 0x0001 && codeUnit <= 0x001F) || codeUnit == 0x007F ||
				// If the character is the first character and is in the range [0-9]
				// (U+0030 to U+0039), […]
				(index == 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039) ||
				// If the character is the second character and is in the range [0-9]
				// (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
				(
					index == 1 &&
					codeUnit >= 0x0030 && codeUnit <= 0x0039 &&
					firstCodeUnit == 0x002D
				)
			) {
				// https://drafts.csswg.org/cssom/#escape-a-character-as-code-point
				result += "\\" + codeUnit.toString(16) + " ";
				continue;
			}

			if (
				// If the character is the first character and is a `-` (U+002D), and
				// there is no second character, […]
				index == 0 &&
				length == 1 &&
				codeUnit == 0x002D
			) {
				result += "\\" + string.charAt(index);
				continue;
			}

			// support for period character in id
			if (codeUnit == 0x002E) {
				if (string.charAt(0) == "#") {
					result += "\\.";
					continue;
				}
			}


			// If the character is not handled by one of the above rules and is
			// greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
			// is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
			// U+005A), or [a-z] (U+0061 to U+007A), […]
			if (
				codeUnit >= 0x0080 ||
				codeUnit == 0x002D ||
				codeUnit == 0x005F ||
				codeUnit == 35 || // Allow #
				codeUnit == 46 || // Allow .
				codeUnit >= 0x0030 && codeUnit <= 0x0039 ||
				codeUnit >= 0x0041 && codeUnit <= 0x005A ||
				codeUnit >= 0x0061 && codeUnit <= 0x007A
			) {
				// the character itself
				result += string.charAt(index);
				continue;
			}

			// Otherwise, the escaped character.
			// https://drafts.csswg.org/cssom/#escape-a-character
			result += "\\" + string.charAt(index);

		}
		return result;
	}

	/**
	 * Creates a new pending promise and provides methods to resolve or reject it.
	 * From: https://developer.mozilla.org/en-US/docs/Mozilla/JavaScript_code_modules/Promise.jsm/Deferred#backwards_forwards_compatible
	 * @returns {object} defered
	 */
	function defer() {
		this.resolve = null;

		this.reject = null;

		this.id = UUID();

		this.promise = new Promise((resolve, reject) => {
			this.resolve = resolve;
			this.reject = reject;
		});
		Object.freeze(this);
	}

	const requestIdleCallback = typeof window !== "undefined" && ("requestIdleCallback" in window ? window.requestIdleCallback : window.requestAnimationFrame);

	function CSSValueToString(obj) {
		return obj.value + (obj.unit || "");
	}

	function isElement(node) {
		return node && node.nodeType === 1;
	}

	function isText(node) {
		return node && node.nodeType === 3;
	}

	function *walk(start, limiter) {
		let node = start;

		while (node) {

			yield node;

			if (node.childNodes.length) {
				node = node.firstChild;
			} else if (node.nextSibling) {
				if (limiter && node === limiter) {
					node = undefined;
					break;
				}
				node = node.nextSibling;
			} else {
				while (node) {
					node = node.parentNode;
					if (limiter && node === limiter) {
						node = undefined;
						break;
					}
					if (node && node.nextSibling) {
						node = node.nextSibling;
						break;
					}

				}
			}
		}
	}

	function nodeAfter(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = nextSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = nextSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function nodeBefore(node, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		let significantNode = previousSignificantNode(node);
		if (significantNode) {
			return significantNode;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				significantNode = previousSignificantNode(node);
				if (significantNode) {
					return significantNode;
				}
			}
		}
	}

	function elementAfter(node, limiter) {
		let after = nodeAfter(node, limiter);

		while (after && after.nodeType !== 1) {
			after = nodeAfter(after, limiter);
		}

		return after;
	}

	function elementBefore(node, limiter) {
		let before = nodeBefore(node, limiter);

		while (before && before.nodeType !== 1) {
			before = nodeBefore(before, limiter);
		}

		return before;
	}

	function displayedElementAfter(node, limiter) {
		let after = elementAfter(node, limiter);

		while (after && after.dataset.undisplayed) {
			after = elementAfter(after);
		}

		return after;
	}

	function displayedElementBefore(node, limiter) {
		let before = elementBefore(node, limiter);

		while (before && before.dataset.undisplayed) {
			before = elementBefore(before);
		}

		return before;
	}

	function rebuildAncestors(node) {
		let parent, ancestor;
		let ancestors = [];
		let added = [];

		let fragment = document.createDocumentFragment();

		// Gather all ancestors
		let element = node;
		while(element.parentNode && element.parentNode.nodeType === 1) {
			ancestors.unshift(element.parentNode);
			element = element.parentNode;
		}

		for (var i = 0; i < ancestors.length; i++) {
			ancestor = ancestors[i];
			parent = ancestor.cloneNode(false);

			parent.setAttribute("data-split-from", parent.getAttribute("data-ref"));
			// ancestor.setAttribute("data-split-to", parent.getAttribute("data-ref"));

			if (parent.hasAttribute("id")) {
				let dataID = parent.getAttribute("id");
				parent.setAttribute("data-id", dataID);
				parent.removeAttribute("id");
			}

			// This is handled by css :not, but also tidied up here
			if (parent.hasAttribute("data-break-before")) {
				parent.removeAttribute("data-break-before");
			}

			if (parent.hasAttribute("data-previous-break-after")) {
				parent.removeAttribute("data-previous-break-after");
			}

			if (added.length) {
				let container = added[added.length-1];
				container.appendChild(parent);
			} else {
				fragment.appendChild(parent);
			}
			added.push(parent);
		}

		added = undefined;
		return fragment;
	}

	/*
	export function split(bound, cutElement, breakAfter) {
			let needsRemoval = [];
			let index = indexOf(cutElement);

			if (!breakAfter && index === 0) {
				return;
			}

			if (breakAfter && index === (cutElement.parentNode.children.length - 1)) {
				return;
			}

			// Create a fragment with rebuilt ancestors
			let fragment = rebuildAncestors(cutElement);

			// Clone cut
			if (!breakAfter) {
				let clone = cutElement.cloneNode(true);
				let ref = cutElement.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(cutElement);
			}

			// Remove all after cut
			let next = nodeAfter(cutElement, bound);
			while (next) {
				let clone = next.cloneNode(true);
				let ref = next.parentNode.getAttribute('data-ref');
				let parent = fragment.querySelector("[data-ref='" + ref + "']");
				parent.appendChild(clone);
				needsRemoval.push(next);
				next = nodeAfter(next, bound);
			}

			// Remove originals
			needsRemoval.forEach((node) => {
				if (node) {
					node.remove();
				}
			});

			// Insert after bounds
			bound.parentNode.insertBefore(fragment, bound.nextSibling);
			return [bound, bound.nextSibling];
	}
	*/

	function needsBreakBefore(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.breakBefore !== "undefined" &&
				(node.dataset.breakBefore === "always" ||
				 node.dataset.breakBefore === "page" ||
				 node.dataset.breakBefore === "left" ||
				 node.dataset.breakBefore === "right" ||
				 node.dataset.breakBefore === "recto" ||
				 node.dataset.breakBefore === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPreviousBreakAfter(node) {
		if( typeof node !== "undefined" &&
				typeof node.dataset !== "undefined" &&
				typeof node.dataset.previousBreakAfter !== "undefined" &&
				(node.dataset.previousBreakAfter === "always" ||
				 node.dataset.previousBreakAfter === "page" ||
				 node.dataset.previousBreakAfter === "left" ||
				 node.dataset.previousBreakAfter === "right" ||
				 node.dataset.previousBreakAfter === "recto" ||
				 node.dataset.previousBreakAfter === "verso")
			 ) {
			return true;
		}

		return false;
	}

	function needsPageBreak(node, previousSignificantNode) {
		if (typeof node === "undefined" || !previousSignificantNode || isIgnorable(node)) {
			return false;
		}
		if (node.dataset && node.dataset.undisplayed) {
			return false;
		}
		const previousSignificantNodePage = previousSignificantNode.dataset ? previousSignificantNode.dataset.page : undefined;
		const currentNodePage = node.dataset ? node.dataset.page : undefined;
		return currentNodePage !== previousSignificantNodePage;
	}

	function *words(node) {
		let currentText = node.nodeValue;
		let max = currentText.length;
		let currentOffset = 0;
		let currentLetter;

		let range;

		while(currentOffset < max) {
			currentLetter = currentText[currentOffset];
			if (/^[\S\u202F\u00A0]$/.test(currentLetter)) {
				if (!range) {
					range = document.createRange();
					range.setStart(node, currentOffset);
				}
			} else {
				if (range) {
					range.setEnd(node, currentOffset);
					yield range;
					range = undefined;
				}
			}

			currentOffset += 1;
		}

		if (range) {
			range.setEnd(node, currentOffset);
			yield range;
			range = undefined;
		}
	}

	function *letters(wordRange) {
		let currentText = wordRange.startContainer;
		let max = currentText.length;
		let currentOffset = wordRange.startOffset;
		// let currentLetter;

		let range;

		while(currentOffset < max) {
			 // currentLetter = currentText[currentOffset];
			 range = document.createRange();
			 range.setStart(currentText, currentOffset);
			 range.setEnd(currentText, currentOffset+1);

			 yield range;

			 currentOffset += 1;
		}
	}

	function isContainer(node) {
		let container;

		if (typeof node.tagName === "undefined") {
			return true;
		}

		if (node.style && node.style.display === "none") {
			return false;
		}

		switch (node.tagName) {
			// Inline
			case "A":
			case "ABBR":
			case "ACRONYM":
			case "B":
			case "BDO":
			case "BIG":
			case "BR":
			case "BUTTON":
			case "CITE":
			case "CODE":
			case "DFN":
			case "EM":
			case "I":
			case "IMG":
			case "INPUT":
			case "KBD":
			case "LABEL":
			case "MAP":
			case "OBJECT":
			case "Q":
			case "SAMP":
			case "SCRIPT":
			case "SELECT":
			case "SMALL":
			case "SPAN":
			case "STRONG":
			case "SUB":
			case "SUP":
			case "TEXTAREA":
			case "TIME":
			case "TT":
			case "VAR":
			case "P":
			case "H1":
			case "H2":
			case "H3":
			case "H4":
			case "H5":
			case "H6":
			case "FIGCAPTION":
			case "BLOCKQUOTE":
			case "PRE":
			case "LI":
			case "TR":
			case "DT":
			case "DD":
			case "VIDEO":
			case "CANVAS":
				container = false;
				break;
			default:
				container = true;
		}

		return container;
	}

	function cloneNode(n, deep=false) {
		return n.cloneNode(deep);
	}

	function findElement(node, doc) {
		const ref = node.getAttribute("data-ref");
		return findRef(ref, doc);
	}

	function findRef(ref, doc) {
		return doc.querySelector(`[data-ref='${ref}']`);
	}

	function validNode(node) {
		if (isText(node)) {
			return true;
		}

		if (isElement(node) && node.dataset.ref) {
			return true;
		}

		return false;
	}

	function prevValidNode(node) {
		while (!validNode(node)) {
			if (node.previousSibling) {
				node = node.previousSibling;
			} else {
				node = node.parentNode;
			}

			if (!node) {
				break;
			}
		}

		return node;
	}


	function indexOf$1(node) {
		let parent = node.parentNode;
		if (!parent) {
			return 0;
		}
		return Array.prototype.indexOf.call(parent.childNodes, node);
	}

	function child(node, index) {
		return node.childNodes[index];
	}

	function hasContent(node) {
		if (isElement(node)) {
			return true;
		} else if (isText(node) &&
				node.textContent.trim().length) {
			return true;
		}
		return false;
	}

	function indexOfTextNode(node, parent) {
		if (!isText(node)) {
			return -1;
		}
		let nodeTextContent = node.textContent;
		let child;
		let index = -1;
		for (var i = 0; i < parent.childNodes.length; i++) {
			child = parent.childNodes[i];
			if (child.nodeType === 3) {
				let text = parent.childNodes[i].textContent;
				if (text.includes(nodeTextContent)) {
					index = i;
					break;
				}
			}
		}

		return index;
	}


	/**
	 * Throughout, whitespace is defined as one of the characters
	 *  "\t" TAB \u0009
	 *  "\n" LF  \u000A
	 *  "\r" CR  \u000D
	 *  " "  SPC \u0020
	 *
	 * This does not use Javascript's "\s" because that includes non-breaking
	 * spaces (and also some other characters).
	 */

	/**
	 * Determine if a node should be ignored by the iterator functions.
	 * taken from https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Whitespace#Whitespace_helper_functions
	 *
	 * @param {Node} node An object implementing the DOM1 |Node| interface.
	 * @return {boolean} true if the node is:
	 *  1) A |Text| node that is all whitespace
	 *  2) A |Comment| node
	 *  and otherwise false.
	 */
	function isIgnorable(node) {
		return (node.nodeType === 8) || // A comment node
			((node.nodeType === 3) && isAllWhitespace(node)); // a text node, all whitespace
	}

	/**
	 * Determine whether a node's text content is entirely whitespace.
	 *
	 * @param {Node} node  A node implementing the |CharacterData| interface (i.e., a |Text|, |Comment|, or |CDATASection| node
	 * @return {boolean} true if all of the text content of |nod| is whitespace, otherwise false.
	 */
	function isAllWhitespace(node) {
		return !(/[^\t\n\r ]/.test(node.textContent));
	}

	/**
	 * Version of |previousSibling| that skips nodes that are entirely
	 * whitespace or comments.  (Normally |previousSibling| is a property
	 * of all DOM nodes that gives the sibling node, the node that is
	 * a child of the same parent, that occurs immediately before the
	 * reference node.)
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest previous sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function previousSignificantNode(sib) {
		while ((sib = sib.previousSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function breakInsideAvoidParentNode(node) {
		while ((node = node.parentNode)) {
			if (node && node.dataset && node.dataset.breakInside === "avoid") {
				return node;
			}
		}
		return null;
	}

	/**
	 * Find a parent with a given node name.
	 * @param {Node} node - initial Node
	 * @param {string} nodeName - node name (eg. "TD", "TABLE", "STRONG"...)
	 * @param {Node} limiter - go up to the parent until there's no more parent or the current node is equals to the limiter
	 * @returns {Node|undefined} - Either:
	 *  1) The closest parent for a the given node name, or
	 *  2) undefined if no such node exists.
	 */
	function parentOf(node, nodeName, limiter) {
		if (limiter && node === limiter) {
			return;
		}
		if (node.parentNode) {
			while ((node = node.parentNode)) {
				if (limiter && node === limiter) {
					return;
				}
				if (node.nodeName === nodeName) {
					return node;
				}
			}
		}
	}

	/**
	 * Version of |nextSibling| that skips nodes that are entirely
	 * whitespace or comments.
	 *
	 * @param {ChildNode} sib  The reference node.
	 * @return {Node|null} Either:
	 *  1) The closest next sibling to |sib| that is not ignorable according to |is_ignorable|, or
	 *  2) null if no such node exists.
	 */
	function nextSignificantNode(sib) {
		while ((sib = sib.nextSibling)) {
			if (!isIgnorable(sib)) return sib;
		}
		return null;
	}

	function filterTree(content, func, what) {
		const treeWalker = document.createTreeWalker(
			content || this.dom,
			what || NodeFilter.SHOW_ALL,
			func ? { acceptNode: func } : null,
			false
		);

		let node;
		let current;
		node = treeWalker.nextNode();
		while(node) {
			current = node;
			node = treeWalker.nextNode();
			current.parentNode.removeChild(current);
		}
	}

	/**
	 * Layout
	 * @class
	 */
	class BreakToken {

		constructor(node, offset) {
			this.node = node;
			this.offset = offset;
		}

		equals(otherBreakToken) {
			if (!otherBreakToken) {
				return false;
			}
			if (this["node"] && otherBreakToken["node"] &&
				this["node"] !== otherBreakToken["node"]) {
				return false;
			}
			if (this["offset"] && otherBreakToken["offset"] &&
				this["offset"] !== otherBreakToken["offset"]) {
				return false;
			}
			return true;
		}

	}

	const MAX_CHARS_PER_BREAK = 1500;

	/**
	 * Layout
	 * @class
	 */
	class Layout {

		constructor(element, hooks, options) {
			this.element = element;

			this.bounds = this.element.getBoundingClientRect();

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.layout = new Hook();
				this.hooks.renderNode = new Hook();
				this.hooks.layoutNode = new Hook();
				this.hooks.beforeOverflow = new Hook();
				this.hooks.onOverflow = new Hook();
				this.hooks.onBreakToken = new Hook();
			}

			this.settings = options || {};

			this.maxChars = this.settings.maxChars || MAX_CHARS_PER_BREAK;
			this.forceRenderBreak = false;
		}

		async renderTo(wrapper, source, breakToken, bounds = this.bounds) {
			let start = this.getStart(source, breakToken);
			let walker = walk(start, source);

			let node;
			let prevNode;
			let done;
			let next;

			let hasRenderedContent = false;
			let newBreakToken;

			let length = 0;

			let prevBreakToken = breakToken || new BreakToken(start);

			while (!done && !newBreakToken) {
				next = walker.next();
				prevNode = node;
				node = next.value;
				done = next.done;

				if (!node) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", prevNode);
						return undefined;
					}
					return newBreakToken;
				}

				this.hooks && this.hooks.layoutNode.trigger(node);

				// Check if the rendered element has a break set
				if (hasRenderedContent && this.shouldBreak(node)) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					length = 0;

					break;
				}

				// Should the Node be a shallow or deep clone
				let shallow = isContainer(node);

				let rendered = this.append(node, wrapper, breakToken, shallow);

				length += rendered.textContent.length;

				// Check if layout has content yet
				if (!hasRenderedContent) {
					hasRenderedContent = hasContent(node);
				}

				// Skip to the next node if a deep clone was rendered
				if (!shallow) {
					walker = walk(nodeAfter(node, source), source);
				}

				if (this.forceRenderBreak) {
					this.hooks && this.hooks.layout.trigger(wrapper, this);

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (!newBreakToken) {
						newBreakToken = this.breakAt(node);
					}

					length = 0;
					this.forceRenderBreak = false;

					break;
				}

				// Only check x characters
				if (length >= this.maxChars) {

					this.hooks && this.hooks.layout.trigger(wrapper, this);

					let imgs = wrapper.querySelectorAll("img");
					if (imgs.length) {
						await this.waitForImages(imgs);
					}

					newBreakToken = this.findBreakToken(wrapper, source, bounds, prevBreakToken);

					if (newBreakToken && newBreakToken.equals(prevBreakToken)) {
						console.warn("Unable to layout item: ", node);
						return undefined;
					}

					if (newBreakToken) {
						length = 0;
					}
				}

			}

			return newBreakToken;
		}

		breakAt(node, offset = 0) {
			let newBreakToken = new BreakToken(
				node,
				offset
			);
			let breakHooks = this.hooks.onBreakToken.triggerSync(newBreakToken, undefined, node, this);
			breakHooks.forEach((newToken) => {
				if (typeof newToken != "undefined") {
					newBreakToken = newToken;
				}
			});

			return newBreakToken;
		}

		shouldBreak(node) {
			let previousSibling = previousSignificantNode(node);
			let parentNode = node.parentNode;
			let parentBreakBefore = needsBreakBefore(node) && parentNode && !previousSibling && needsBreakBefore(parentNode);
			let doubleBreakBefore;

			if (parentBreakBefore) {
				doubleBreakBefore = node.dataset.breakBefore === parentNode.dataset.breakBefore;
			}

			return !doubleBreakBefore && needsBreakBefore(node) || needsPreviousBreakAfter(node) || needsPageBreak(node, previousSibling);
		}

		forceBreak() {
			this.forceRenderBreak = true;
		}

		getStart(source, breakToken) {
			let start;
			let node = breakToken && breakToken.node;

			if (node) {
				start = node;
			} else {
				start = source.firstChild;
			}

			return start;
		}

		append(node, dest, breakToken, shallow = true, rebuild = true) {

			let clone = cloneNode(node, !shallow);

			if (node.parentNode && isElement(node.parentNode)) {
				let parent = findElement(node.parentNode, dest);
				// Rebuild chain
				if (parent) {
					parent.appendChild(clone);
				} else if (rebuild) {
					let fragment = rebuildAncestors(node);
					parent = findElement(node.parentNode, fragment);
					if (!parent) {
						dest.appendChild(clone);
					} else if (breakToken && isText(breakToken.node) && breakToken.offset > 0) {
						clone.textContent = clone.textContent.substring(breakToken.offset);
						parent.appendChild(clone);
					} else {
						parent.appendChild(clone);
					}

					dest.appendChild(fragment);
				} else {
					dest.appendChild(clone);
				}


			} else {
				dest.appendChild(clone);
			}

			let nodeHooks = this.hooks.renderNode.triggerSync(clone, node, this);
			nodeHooks.forEach((newNode) => {
				if (typeof newNode != "undefined") {
					clone = newNode;
				}
			});

			return clone;
		}

		async waitForImages(imgs) {
			let results = Array.from(imgs).map(async (img) => {
				return this.awaitImageLoaded(img);
			});
			await Promise.all(results);
		}

		async awaitImageLoaded(image) {
			return new Promise(resolve => {
				if (image.complete !== true) {
					image.onload = function () {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height);
					};
					image.onerror = function (e) {
						let {width, height} = window.getComputedStyle(image);
						resolve(width, height, e);
					};
				} else {
					let {width, height} = window.getComputedStyle(image);
					resolve(width, height);
				}
			});
		}

		avoidBreakInside(node, limiter) {
			let breakNode;

			if (node === limiter) {
				return;
			}

			while (node.parentNode) {
				node = node.parentNode;

				if (node === limiter) {
					break;
				}

				if (window.getComputedStyle(node)["break-inside"] === "avoid") {
					breakNode = node;
					break;
				}

			}
			return breakNode;
		}

		createBreakToken(overflow, rendered, source) {
			let container = overflow.startContainer;
			let offset = overflow.startOffset;
			let node, renderedNode, parent, index, temp;

			if (isElement(container)) {
				temp = child(container, offset);

				if (isElement(temp)) {
					renderedNode = findElement(temp, rendered);

					if (!renderedNode) {
						// Find closest element with data-ref
						let prevNode = prevValidNode(temp);
						if (!isElement(prevNode)) {
							prevNode = prevNode.parentElement;
						}
						renderedNode = findElement(prevNode, rendered);
						// Check if temp is the last rendered node at its level.
						if (!temp.nextSibling) {
							// We need to ensure that the previous sibling of temp is fully rendered.
							const renderedNodeFromSource = findElement(renderedNode, source);
							const walker = document.createTreeWalker(renderedNodeFromSource, NodeFilter.SHOW_ELEMENT);
							const lastChildOfRenderedNodeFromSource = walker.lastChild();
							const lastChildOfRenderedNodeMatchingFromRendered = findElement(lastChildOfRenderedNodeFromSource, rendered);
							// Check if we found that the last child in source
							if (!lastChildOfRenderedNodeMatchingFromRendered) {
								// Pending content to be rendered before virtual break token
								return;
							}
							// Otherwise we will return a break token as per below
						}
						// renderedNode is actually the last unbroken box that does not overflow.
						// Break Token is therefore the next sibling of renderedNode within source node.
						node = findElement(renderedNode, source).nextSibling;
						offset = 0;
					} else {
						node = findElement(renderedNode, source);
						offset = 0;
					}
				} else {
					renderedNode = findElement(container, rendered);

					if (!renderedNode) {
						renderedNode = findElement(prevValidNode(container), rendered);
					}

					parent = findElement(renderedNode, source);
					index = indexOfTextNode(temp, parent);
					// No seperatation for the first textNode of an element
					if(index === 0) {
						node = parent;
						offset = 0;
					} else {
						node = child(parent, index);
						offset = 0;
					}
				}
			} else {
				renderedNode = findElement(container.parentNode, rendered);

				if (!renderedNode) {
					renderedNode = findElement(prevValidNode(container.parentNode), rendered);
				}

				parent = findElement(renderedNode, source);
				index = indexOfTextNode(container, parent);

				if (index === -1) {
					return;
				}

				node = child(parent, index);

				offset += node.textContent.indexOf(container.textContent);
			}

			if (!node) {
				return;
			}

			return new BreakToken(
				node,
				offset
			);

		}

		findBreakToken(rendered, source, bounds = this.bounds, prevBreakToken, extract = true) {
			let overflow = this.findOverflow(rendered, bounds);
			let breakToken, breakLetter;

			let overflowHooks = this.hooks.onOverflow.triggerSync(overflow, rendered, bounds, this);
			overflowHooks.forEach((newOverflow) => {
				if (typeof newOverflow != "undefined") {
					overflow = newOverflow;
				}
			});

			if (overflow) {
				breakToken = this.createBreakToken(overflow, rendered, source);
				// breakToken is nullable
				let breakHooks = this.hooks.onBreakToken.triggerSync(breakToken, overflow, rendered, this);
				breakHooks.forEach((newToken) => {
					if (typeof newToken != "undefined") {
						breakToken = newToken;
					}
				});

				// Stop removal if we are in a loop
				if (breakToken && breakToken.equals(prevBreakToken)) {
					return breakToken;
				}

				if (breakToken && breakToken["node"] && breakToken["offset"] && breakToken["node"].textContent) {
					breakLetter = breakToken["node"].textContent.charAt(breakToken["offset"]);
				} else {
					breakLetter = undefined;
				}

				if (breakToken && breakToken.node && extract) {
					this.removeOverflow(overflow, breakLetter);
				}

			}
			return breakToken;
		}

		hasOverflow(element, bounds = this.bounds) {
			let constrainingElement = element && element.parentNode; // this gets the element, instead of the wrapper for the width workaround
			let {width} = element.getBoundingClientRect();
			let scrollWidth = constrainingElement ? constrainingElement.scrollWidth : 0;
			return Math.max(Math.floor(width), scrollWidth) > Math.round(bounds.width);
		}

		findOverflow(rendered, bounds = this.bounds) {
			if (!this.hasOverflow(rendered, bounds)) return;

			let start = Math.round(bounds.left);
			let end = Math.round(bounds.right);
			let range;

			let walker = walk(rendered.firstChild, rendered);

			// Find Start
			let next, done, node, offset, skip, breakAvoid, prev, br;
			while (!done) {
				next = walker.next();
				done = next.done;
				node = next.value;
				skip = false;
				breakAvoid = false;
				prev = undefined;
				br = undefined;

				if (node) {
					let pos = getBoundingClientRect(node);
					let left = Math.round(pos.left);
					let right = Math.floor(pos.right);

					if (!range && left >= end) {
						// Check if it is a float
						let isFloat = false;

						// Check if the node is inside a break-inside: avoid table cell
						const insideTableCell = parentOf(node, "TD", rendered);
						if (insideTableCell && window.getComputedStyle(insideTableCell)["break-inside"] === "avoid") {
							// breaking inside a table cell produces unexpected result, as a workaround, we forcibly avoid break inside in a cell.
							prev = insideTableCell;
						} else if (isElement(node)) {
							let styles = window.getComputedStyle(node);
							isFloat = styles.getPropertyValue("float") !== "none";
							skip = styles.getPropertyValue("break-inside") === "avoid";
							breakAvoid = node.dataset.breakBefore === "avoid" || node.dataset.previousBreakAfter === "avoid";
							prev = breakAvoid && nodeBefore(node, rendered);
							br = node.tagName === "BR" || node.tagName === "WBR";
						}

						if (prev) {
							range = document.createRange();
							range.selectNode(prev);
							break;
						}

						if (!br && !isFloat && isElement(node)) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

						if (isText(node) && node.textContent.trim().length) {
							range = document.createRange();
							range.selectNode(node);
							break;
						}

					}

					if (!range && isText(node) &&
						node.textContent.trim().length &&
						!breakInsideAvoidParentNode(node.parentNode)) {

						let rects = getClientRects(node);
						let rect;
						left = 0;
						for (var i = 0; i != rects.length; i++) {
							rect = rects[i];
							if (rect.width > 0 && (!left || rect.left > left)) {
								left = rect.left;
							}
						}

						if (left >= end) {
							range = document.createRange();
							offset = this.textBreak(node, start, end);
							if (!offset) {
								range = undefined;
							} else {
								range.setStart(node, offset);
							}
							break;
						}
					}

					// Skip children
					if (skip || right <= end) {
						next = nodeAfter(node, rendered);
						if (next) {
							walker = walk(next, rendered);
						}

					}

				}
			}

			// Find End
			if (range) {
				range.setEndAfter(rendered.lastChild);
				return range;
			}

		}

		findEndToken(rendered, source, bounds = this.bounds) {
			if (rendered.childNodes.length === 0) {
				return;
			}

			let lastChild = rendered.lastChild;

			let lastNodeIndex;
			while (lastChild && lastChild.lastChild) {
				if (!validNode(lastChild)) {
					// Only get elements with refs
					lastChild = lastChild.previousSibling;
				} else if (!validNode(lastChild.lastChild)) {
					// Deal with invalid dom items
					lastChild = prevValidNode(lastChild.lastChild);
					break;
				} else {
					lastChild = lastChild.lastChild;
				}
			}

			if (isText(lastChild)) {

				if (lastChild.parentNode.dataset.ref) {
					lastNodeIndex = indexOf$1(lastChild);
					lastChild = lastChild.parentNode;
				} else {
					lastChild = lastChild.previousSibling;
				}
			}

			let original = findElement(lastChild, source);

			if (lastNodeIndex) {
				original = original.childNodes[lastNodeIndex];
			}

			let after = nodeAfter(original);

			return this.breakAt(after);
		}

		textBreak(node, start, end) {
			let wordwalker = words(node);
			let left = 0;
			let right = 0;
			let word, next, done, pos;
			let offset;
			while (!done) {
				next = wordwalker.next();
				word = next.value;
				done = next.done;

				if (!word) {
					break;
				}

				pos = getBoundingClientRect(word);

				left = Math.floor(pos.left);
				right = Math.floor(pos.right);

				if (left >= end) {
					offset = word.startOffset;
					break;
				}

				if (right > end) {
					let letterwalker = letters(word);
					let letter, nextLetter, doneLetter;

					while (!doneLetter) {
						nextLetter = letterwalker.next();
						letter = nextLetter.value;
						doneLetter = nextLetter.done;

						if (!letter) {
							break;
						}

						pos = getBoundingClientRect(letter);
						left = Math.floor(pos.left);

						if (left >= end) {
							offset = letter.startOffset;
							done = true;

							break;
						}
					}
				}

			}

			return offset;
		}

		removeOverflow(overflow, breakLetter) {
			let {startContainer} = overflow;
			let extracted = overflow.extractContents();

			this.hyphenateAtBreak(startContainer, breakLetter);

			return extracted;
		}

		hyphenateAtBreak(startContainer, breakLetter) {
			if (isText(startContainer)) {
				let startText = startContainer.textContent;
				let prevLetter = startText[startText.length - 1];

				// Add a hyphen if previous character is a letter or soft hyphen
				if (
					(breakLetter && /^\w|\u00AD$/.test(prevLetter) && /^\w|\u00AD$/.test(breakLetter)) ||
					(!breakLetter && /^\w|\u00AD$/.test(prevLetter))
				) {
					startContainer.parentNode.classList.add("pagedjs_hyphen");
					startContainer.textContent += this.settings.hyphenGlyph || "\u2011";
				}
			}
		}

		equalTokens(a, b) {
			if (!a || !b) {
				return false;
			}
			if (a["node"] && b["node"] && a["node"] !== b["node"]) {
				return false;
			}
			if (a["offset"] && b["offset"] && a["offset"] !== b["offset"]) {
				return false;
			}
			return true;
		}
	}

	eventEmitter(Layout.prototype);

	/**
	 * Render a page
	 * @class
	 */
	class Page {
		constructor(pagesArea, pageTemplate, blank, hooks) {
			this.pagesArea = pagesArea;
			this.pageTemplate = pageTemplate;
			this.blank = blank;

			this.width = undefined;
			this.height = undefined;

			this.hooks = hooks;

			// this.element = this.create(this.pageTemplate);
		}

		create(template, after) {
			//let documentFragment = document.createRange().createContextualFragment( TEMPLATE );
			//let page = documentFragment.children[0];
			let clone = document.importNode(this.pageTemplate.content, true);

			let page, index;
			if (after) {
				this.pagesArea.insertBefore(clone, after.nextElementSibling);
				index = Array.prototype.indexOf.call(this.pagesArea.children, after.nextElementSibling);
				page = this.pagesArea.children[index];
			} else {
				this.pagesArea.appendChild(clone);
				page = this.pagesArea.lastChild;
			}

			let pagebox = page.querySelector(".pagedjs_pagebox");
			let area = page.querySelector(".pagedjs_page_content");


			let size = area.getBoundingClientRect();


			area.style.columnWidth = Math.round(size.width) + "px";
			area.style.columnGap = "calc(var(--pagedjs-margin-right) + var(--pagedjs-margin-left))";
			// area.style.overflow = "scroll";

			this.width = Math.round(size.width);
			this.height = Math.round(size.height);

			this.element = page;
			this.pagebox = pagebox;
			this.area = area;

			return page;
		}

		createWrapper() {
			let wrapper = document.createElement("div");

			this.area.appendChild(wrapper);

			this.wrapper = wrapper;

			return wrapper;
		}

		index(pgnum) {
			this.position = pgnum;

			let page = this.element;
			// let pagebox = this.pagebox;

			let index = pgnum + 1;

			let id = `page-${index}`;

			this.id = id;

			// page.dataset.pageNumber = index;

			page.dataset.pageNumber = index;
			page.setAttribute("id", id);

			if (this.name) {
				page.classList.add("pagedjs_" + this.name + "_page");
			}

			if (this.blank) {
				page.classList.add("pagedjs_blank_page");
			}

			if (pgnum === 0) {
				page.classList.add("pagedjs_first_page");
			}

			if (pgnum % 2 !== 1) {
				page.classList.remove("pagedjs_left_page");
				page.classList.add("pagedjs_right_page");
			} else {
				page.classList.remove("pagedjs_right_page");
				page.classList.add("pagedjs_left_page");
			}
		}

		/*
		size(width, height) {
			if (width === this.width && height === this.height) {
				return;
			}
			this.width = width;
			this.height = height;

			this.element.style.width = Math.round(width) + "px";
			this.element.style.height = Math.round(height) + "px";
			this.element.style.columnWidth = Math.round(width) + "px";
		}
		*/

		async layout(contents, breakToken, maxChars) {

			this.clear();

			this.startToken = breakToken;

			this.layoutMethod = new Layout(this.area, this.hooks, maxChars);

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);
			
			this.addListeners(contents);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		async append(contents, breakToken) {

			if (!this.layoutMethod) {
				return this.layout(contents, breakToken);
			}

			let newBreakToken = await this.layoutMethod.renderTo(this.wrapper, contents, breakToken);

			this.endToken = newBreakToken;

			return newBreakToken;
		}

		getByParent(ref, entries) {
			let e;
			for (var i = 0; i < entries.length; i++) {
				e = entries[i];
				if (e.dataset.ref === ref) {
					return e;
				}
			}
		}

		onOverflow(func) {
			this._onOverflow = func;
		}

		onUnderflow(func) {
			this._onUnderflow = func;
		}

		clear() {
			this.removeListeners();
			this.wrapper && this.wrapper.remove();
			this.createWrapper();
		}

		addListeners(contents) {
			if (typeof ResizeObserver !== "undefined") {
				this.addResizeObserver(contents);
			} else {
				this._checkOverflowAfterResize = this.checkOverflowAfterResize.bind(this, contents);
				this.element.addEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.addEventListener("underflow", this._checkOverflowAfterResize, false);
			}
			// TODO: fall back to mutation observer?

			this._onScroll = function () {
				if (this.listening) {
					this.element.scrollLeft = 0;
				}
			}.bind(this);

			// Keep scroll left from changing
			this.element.addEventListener("scroll", this._onScroll);

			this.listening = true;

			return true;
		}

		removeListeners() {
			this.listening = false;

			if (typeof ResizeObserver !== "undefined" && this.ro) {
				this.ro.disconnect();
			} else if (this.element) {
				this.element.removeEventListener("overflow", this._checkOverflowAfterResize, false);
				this.element.removeEventListener("underflow", this._checkOverflowAfterResize, false);
			}

			this.element && this.element.removeEventListener("scroll", this._onScroll);

		}

		addResizeObserver(contents) {
			let wrapper = this.wrapper;
			let prevHeight = wrapper.getBoundingClientRect().height;
			this.ro = new ResizeObserver(entries => {

				if (!this.listening) {
					return;
				}
				requestAnimationFrame(() => {
					for (let entry of entries) {
						const cr = entry.contentRect;

						if (cr.height > prevHeight) {
							this.checkOverflowAfterResize(contents);
							prevHeight = wrapper.getBoundingClientRect().height;
						} else if (cr.height < prevHeight) { // TODO: calc line height && (prevHeight - cr.height) >= 22
							this.checkUnderflowAfterResize(contents);
							prevHeight = cr.height;
						}
					}
				});
			});

			this.ro.observe(wrapper);
		}

		checkOverflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let newBreakToken = this.layoutMethod.findBreakToken(this.wrapper, contents, this.startToken);

			if (newBreakToken) {
				this.endToken = newBreakToken;
				this._onOverflow && this._onOverflow(newBreakToken);
			}
		}

		checkUnderflowAfterResize(contents) {
			if (!this.listening || !this.layoutMethod) {
				return;
			}

			let endToken = this.layoutMethod.findEndToken(this.wrapper, contents);

			if (endToken) {
				this._onUnderflow && this._onUnderflow(endToken);
			}
		}


		destroy() {
			this.removeListeners();

			this.element.remove();

			this.element = undefined;
			this.wrapper = undefined;
		}
	}

	eventEmitter(Page.prototype);

	/**
	 * Render a flow of text offscreen
	 * @class
	 */
	class ContentParser {

		constructor(content, cb) {
			if (content && content.nodeType) {
				// handle dom
				this.dom = this.add(content);
			} else if (typeof content === "string") {
				this.dom = this.parse(content);
			}

			return this.dom;
		}

		parse(markup, mime) {
			let range = document.createRange();
			let fragment = range.createContextualFragment(markup);

			this.addRefs(fragment);

			return fragment;
		}

		add(contents) {
			// let fragment = document.createDocumentFragment();
			//
			// let children = [...contents.childNodes];
			// for (let child of children) {
			// 	let clone = child.cloneNode(true);
			// 	fragment.appendChild(clone);
			// }

			this.addRefs(contents);

			return contents;
		}

		addRefs(content) {
			var treeWalker = document.createTreeWalker(
				content,
				NodeFilter.SHOW_ELEMENT,
				null,
				false
			);

			let node = treeWalker.nextNode();
			while(node) {

				if (!node.hasAttribute("data-ref")) {
					let uuid = UUID();
					node.setAttribute("data-ref", uuid);
				}

				if (node.id) {
					node.setAttribute("data-id", node.id);
				}

				// node.setAttribute("data-children", node.childNodes.length);

				// node.setAttribute("data-text", node.textContent.trim().length);
				node = treeWalker.nextNode();
			}
		}

		find(ref) {
			return this.refs[ref];
		}

		destroy() {
			this.refs = undefined;
			this.dom = undefined;
		}
	}

	/**
	 * Queue for handling tasks one at a time
	 * @class
	 * @param {scope} context what this will resolve to in the tasks
	 */
	class Queue {
		constructor(context){
			this._q = [];
			this.context = context;
			this.tick = requestAnimationFrame;
			this.running = false;
			this.paused = false;
		}

		/**
		 * Add an item to the queue
		 * @return {Promise} enqueued
		 */
		enqueue() {
			var deferred, promise;
			var queued;
			var task = [].shift.call(arguments);
			var args = arguments;

			// Handle single args without context
			// if(args && !Array.isArray(args)) {
			//   args = [args];
			// }
			if(!task) {
				throw new Error("No Task Provided");
			}

			if(typeof task === "function"){

				deferred = new defer();
				promise = deferred.promise;

				queued = {
					"task" : task,
					"args"     : args,
					//"context"  : context,
					"deferred" : deferred,
					"promise" : promise
				};

			} else {
				// Task is a promise
				queued = {
					"promise" : task
				};

			}

			this._q.push(queued);

			// Wait to start queue flush
			if (this.paused == false && !this.running) {
				this.run();
			}

			return queued.promise;
		}

		/**
		 * Run one item
		 * @return {Promise} dequeued
		 */
		dequeue(){
			var inwait, task, result;

			if(this._q.length && !this.paused) {
				inwait = this._q.shift();
				task = inwait.task;
				if(task){
					// console.log(task)

					result = task.apply(this.context, inwait.args);

					if(result && typeof result["then"] === "function") {
						// Task is a function that returns a promise
						return result.then(function(){
							inwait.deferred.resolve.apply(this.context, arguments);
						}.bind(this), function() {
							inwait.deferred.reject.apply(this.context, arguments);
						}.bind(this));
					} else {
						// Task resolves immediately
						inwait.deferred.resolve.apply(this.context, result);
						return inwait.promise;
					}



				} else if(inwait.promise) {
					// Task is a promise
					return inwait.promise;
				}

			} else {
				inwait = new defer();
				inwait.deferred.resolve();
				return inwait.promise;
			}

		}

		// Run All Immediately
		dump(){
			while(this._q.length) {
				this.dequeue();
			}
		}

		/**
		 * Run all tasks sequentially, at convince
		 * @return {Promise} all run
		 */
		run(){

			if(!this.running){
				this.running = true;
				this.defered = new defer();
			}

			this.tick.call(window, () => {

				if(this._q.length) {

					this.dequeue()
						.then(function(){
							this.run();
						}.bind(this));

				} else {
					this.defered.resolve();
					this.running = undefined;
				}

			});

			// Unpause
			if(this.paused == true) {
				this.paused = false;
			}

			return this.defered.promise;
		}

		/**
		 * Flush all, as quickly as possible
		 * @return {Promise} ran
		 */
		flush(){

			if(this.running){
				return this.running;
			}

			if(this._q.length) {
				this.running = this.dequeue()
					.then(function(){
						this.running = undefined;
						return this.flush();
					}.bind(this));

				return this.running;
			}

		}

		/**
		 * Clear all items in wait
		 * @return {void}
		 */
		clear(){
			this._q = [];
		}

		/**
		 * Get the number of tasks in the queue
		 * @return {number} tasks
		 */
		length(){
			return this._q.length;
		}

		/**
		 * Pause a running queue
		 * @return {void}
		 */
		pause(){
			this.paused = true;
		}

		/**
		 * End the queue
		 * @return {void}
		 */
		stop(){
			this._q = [];
			this.running = false;
			this.paused = true;
		}
	}

	const TEMPLATE = `
<div class="pagedjs_page">
	<div class="pagedjs_sheet">
		<div class="pagedjs_bleed pagedjs_bleed-top">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-bottom">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-left">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>		<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_bleed pagedjs_bleed-right">
			<div class="pagedjs_marks-crop"></div>
			<div class="pagedjs_marks-middle">
				<div class="pagedjs_marks-cross"></div>
			</div>
			<div class="pagedjs_marks-crop"></div>
		</div>
		<div class="pagedjs_pagebox">
			<div class="pagedjs_margin-top-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top">
				<div class="pagedjs_margin pagedjs_margin-top-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-top-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-top-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-top-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-right">
				<div class="pagedjs_margin pagedjs_margin-right-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-right-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-left">
				<div class="pagedjs_margin pagedjs_margin-left-top"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-middle"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-left-bottom"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-left-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-left-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom">
				<div class="pagedjs_margin pagedjs_margin-bottom-left"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-center"><div class="pagedjs_margin-content"></div></div>
				<div class="pagedjs_margin pagedjs_margin-bottom-right"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_margin-bottom-right-corner-holder">
				<div class="pagedjs_margin pagedjs_margin-bottom-right-corner"><div class="pagedjs_margin-content"></div></div>
			</div>
			<div class="pagedjs_area">
				<div class="pagedjs_page_content"></div>
			</div>
		</div>
	</div>
</div>`;

	/**
	 * Chop up text into flows
	 * @class
	 */
	class Chunker {
		constructor(content, renderTo, options) {
			// this.preview = preview;

			this.settings = options || {};

			this.hooks = {};
			this.hooks.beforeParsed = new Hook(this);
			this.hooks.filter = new Hook(this);
			this.hooks.afterParsed = new Hook(this);
			this.hooks.beforePageLayout = new Hook(this);
			this.hooks.layout = new Hook(this);
			this.hooks.renderNode = new Hook(this);
			this.hooks.layoutNode = new Hook(this);
			this.hooks.onOverflow = new Hook(this);
			this.hooks.onBreakToken = new Hook();
			this.hooks.afterPageLayout = new Hook(this);
			this.hooks.afterRendered = new Hook(this);

			this.pages = [];
			this.total = 0;

			this.q = new Queue(this);
			this.stopped = false;
			this.rendered = false;

			this.content = content;

			this.charsPerBreak = [];
			this.maxChars;

			if (content) {
				this.flow(content, renderTo);
			}
		}

		setup(renderTo) {
			this.pagesArea = document.createElement("div");
			this.pagesArea.classList.add("pagedjs_pages");

			if (renderTo) {
				renderTo.appendChild(this.pagesArea);
			} else {
				document.querySelector("body").appendChild(this.pagesArea);
			}

			this.pageTemplate = document.createElement("template");
			this.pageTemplate.innerHTML = TEMPLATE;

		}

		async flow(content, renderTo) {
			let parsed;

			await this.hooks.beforeParsed.trigger(content, this);

			parsed = new ContentParser(content);

			this.hooks.filter.triggerSync(parsed);

			this.source = parsed;
			this.breakToken = undefined;

			if (this.pagesArea && this.pageTemplate) {
				this.q.clear();
				this.removePages();
			} else {
				this.setup(renderTo);
			}

			this.emit("rendering", parsed);

			await this.hooks.afterParsed.trigger(parsed, this);

			await this.loadFonts();

			let rendered = await this.render(parsed, this.breakToken);
			while (rendered.canceled) {
				this.start();
				rendered = await this.render(parsed, this.breakToken);
			}

			this.rendered = true;
			this.pagesArea.style.setProperty("--pagedjs-page-count", this.total);

			await this.hooks.afterRendered.trigger(this.pages, this);

			this.emit("rendered", this.pages);



			return this;
		}

		// oversetPages() {
		// 	let overset = [];
		// 	for (let i = 0; i < this.pages.length; i++) {
		// 		let page = this.pages[i];
		// 		if (page.overset) {
		// 			overset.push(page);
		// 			// page.overset = false;
		// 		}
		// 	}
		// 	return overset;
		// }
		//
		// async handleOverset(parsed) {
		// 	let overset = this.oversetPages();
		// 	if (overset.length) {
		// 		console.log("overset", overset);
		// 		let index = this.pages.indexOf(overset[0]) + 1;
		// 		console.log("INDEX", index);
		//
		// 		// Remove pages
		// 		// this.removePages(index);
		//
		// 		// await this.render(parsed, overset[0].overset);
		//
		// 		// return this.handleOverset(parsed);
		// 	}
		// }

		async render(parsed, startAt) {
			let renderer = this.layout(parsed, startAt, this.settings);

			let done = false;
			let result;
			while (!done) {
				result = await this.q.enqueue(() => { return this.renderAsync(renderer); });
				done = result.done;
			}

			return result;
		}

		start() {
			this.rendered = false;
			this.stopped = false;
		}

		stop() {
			this.stopped = true;
			// this.q.clear();
		}

		renderOnIdle(renderer) {
			return new Promise(resolve => {
				requestIdleCallback(async () => {
					if (this.stopped) {
						return resolve({ done: true, canceled: true });
					}
					let result = await renderer.next();
					if (this.stopped) {
						resolve({ done: true, canceled: true });
					} else {
						resolve(result);
					}
				});
			});
		}

		async renderAsync(renderer) {
			if (this.stopped) {
				return { done: true, canceled: true };
			}
			let result = await renderer.next();
			if (this.stopped) {
				return { done: true, canceled: true };
			} else {
				return result;
			}
		}

		async handleBreaks(node) {
			let currentPage = this.total + 1;
			let currentPosition = currentPage % 2 === 0 ? "left" : "right";
			// TODO: Recto and Verso should reverse for rtl languages
			let currentSide = currentPage % 2 === 0 ? "verso" : "recto";
			let previousBreakAfter;
			let breakBefore;
			let page;

			if (currentPage === 1) {
				return;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.previousBreakAfter !== "undefined") {
				previousBreakAfter = node.dataset.previousBreakAfter;
			}

			if (node &&
					typeof node.dataset !== "undefined" &&
					typeof node.dataset.breakBefore !== "undefined") {
				breakBefore = node.dataset.breakBefore;
			}

			if( previousBreakAfter &&
					(previousBreakAfter === "left" || previousBreakAfter === "right") &&
					previousBreakAfter !== currentPosition) {
				page = this.addPage(true);
			} else if( previousBreakAfter &&
					(previousBreakAfter === "verso" || previousBreakAfter === "recto") &&
					previousBreakAfter !== currentSide) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "left" || breakBefore === "right") &&
					breakBefore !== currentPosition) {
				page = this.addPage(true);
			} else if( breakBefore &&
					(breakBefore === "verso" || breakBefore === "recto") &&
					breakBefore !== currentSide) {
				page = this.addPage(true);
			}

			if (page) {
				await this.hooks.beforePageLayout.trigger(page, undefined, undefined, this);
				this.emit("page", page);
				// await this.hooks.layout.trigger(page.element, page, undefined, this);
				await this.hooks.afterPageLayout.trigger(page.element, page, undefined, this);
				this.emit("renderedPage", page);
			}
		}

		async *layout(content, startAt) {
			let breakToken = startAt || false;

			while (breakToken !== undefined && ( true)) {

				if (breakToken && breakToken.node) {
					await this.handleBreaks(breakToken.node);
				} else {
					await this.handleBreaks(content.firstChild);
				}

				let page = this.addPage();

				await this.hooks.beforePageLayout.trigger(page, content, breakToken, this);
				this.emit("page", page);

				// Layout content in the page, starting from the breakToken
				breakToken = await page.layout(content, breakToken, this.maxChars);

				await this.hooks.afterPageLayout.trigger(page.element, page, breakToken, this);
				this.emit("renderedPage", page);

				this.recoredCharLength(page.wrapper.textContent.length);

				yield breakToken;

				// Stop if we get undefined, showing we have reached the end of the content
			}


		}

		recoredCharLength(length) {
			if (length === 0) {
				return;
			}

			this.charsPerBreak.push(length);

			// Keep the length of the last few breaks
			if (this.charsPerBreak.length > 4) {
				this.charsPerBreak.shift();
			}

			this.maxChars = this.charsPerBreak.reduce((a, b) => a + b, 0) / (this.charsPerBreak.length);
		}

		removePages(fromIndex=0) {

			if (fromIndex >= this.pages.length) {
				return;
			}

			// Remove pages
			for (let i = fromIndex; i < this.pages.length; i++) {
				this.pages[i].destroy();
			}

			if (fromIndex > 0) {
				this.pages.splice(fromIndex);
			} else {
				this.pages = [];
			}

			this.total = this.pages.length;
		}

		addPage(blank) {
			let lastPage = this.pages[this.pages.length - 1];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			this.pages.push(page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(this.total);

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					console.warn("overflow on", page.id, overflowToken);

					// Only reflow while rendering
					if (this.rendered) {
						return;
					}

					let index = this.pages.indexOf(page) + 1;

					// Stop the rendering
					this.stop();

					// Set the breakToken to resume at
					this.breakToken = overflowToken;

					// Remove pages
					this.removePages(index);

					if (this.rendered === true) {
						this.rendered = false;

						this.q.enqueue(async () => {

							this.start();

							await this.render(this.source, this.breakToken);

							this.rendered = true;

						});
					}


				});

				page.onUnderflow((overflowToken) => {
					// console.log("underflow on", page.id, overflowToken);

					// page.append(this.source, overflowToken);

				});
			}

			this.total = this.pages.length;

			return page;
		}
		/*
		insertPage(index, blank) {
			let lastPage = this.pages[index];
			// Create a new page from the template
			let page = new Page(this.pagesArea, this.pageTemplate, blank, this.hooks);

			let total = this.pages.splice(index, 0, page);

			// Create the pages
			page.create(undefined, lastPage && lastPage.element);

			page.index(index + 1);

			for (let i = index + 2; i < this.pages.length; i++) {
				this.pages[i].index(i);
			}

			if (!blank) {
				// Listen for page overflow
				page.onOverflow((overflowToken) => {
					if (total < this.pages.length) {
						this.pages[total].layout(this.source, overflowToken);
					} else {
						let newPage = this.addPage();
						newPage.layout(this.source, overflowToken);
					}
				});

				page.onUnderflow(() => {
					// console.log("underflow on", page.id);
				});
			}

			this.total += 1;

			return page;
		}
		*/



		loadFonts() {
			let fontPromises = [];
			(document.fonts || []).forEach((fontFace) => {
				if (fontFace.status !== "loaded") {
					let fontLoaded = fontFace.load().then((r) => {
						return fontFace.family;
					}, (r) => {
						console.warn("Failed to preload font-family:", fontFace.family);
						return fontFace.family;
					});
					fontPromises.push(fontLoaded);
				}
			});
			return Promise.all(fontPromises).catch((err) => {
				console.warn(err);
			});
		}

		destroy() {
			this.pagesArea.remove();
			this.pageTemplate.remove();
		}

	}

	eventEmitter(Chunker.prototype);

	//
	//                              list
	//                            ┌──────┐
	//             ┌──────────────┼─head │
	//             │              │ tail─┼──────────────┐
	//             │              └──────┘              │
	//             ▼                                    ▼
	//            item        item        item        item
	//          ┌──────┐    ┌──────┐    ┌──────┐    ┌──────┐
	//  null ◀──┼─prev │◀───┼─prev │◀───┼─prev │◀───┼─prev │
	//          │ next─┼───▶│ next─┼───▶│ next─┼───▶│ next─┼──▶ null
	//          ├──────┤    ├──────┤    ├──────┤    ├──────┤
	//          │ data │    │ data │    │ data │    │ data │
	//          └──────┘    └──────┘    └──────┘    └──────┘
	//

	function createItem(data) {
	    return {
	        prev: null,
	        next: null,
	        data: data
	    };
	}

	function allocateCursor(node, prev, next) {
	    var cursor;

	    if (cursors !== null) {
	        cursor = cursors;
	        cursors = cursors.cursor;
	        cursor.prev = prev;
	        cursor.next = next;
	        cursor.cursor = node.cursor;
	    } else {
	        cursor = {
	            prev: prev,
	            next: next,
	            cursor: node.cursor
	        };
	    }

	    node.cursor = cursor;

	    return cursor;
	}

	function releaseCursor(node) {
	    var cursor = node.cursor;

	    node.cursor = cursor.cursor;
	    cursor.prev = null;
	    cursor.next = null;
	    cursor.cursor = cursors;
	    cursors = cursor;
	}

	var cursors = null;
	var List = function() {
	    this.cursor = null;
	    this.head = null;
	    this.tail = null;
	};

	List.createItem = createItem;
	List.prototype.createItem = createItem;

	List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
	    var cursor = this.cursor;

	    while (cursor !== null) {
	        if (cursor.prev === prevOld) {
	            cursor.prev = prevNew;
	        }

	        if (cursor.next === nextOld) {
	            cursor.next = nextNew;
	        }

	        cursor = cursor.cursor;
	    }
	};

	List.prototype.getSize = function() {
	    var size = 0;
	    var cursor = this.head;

	    while (cursor) {
	        size++;
	        cursor = cursor.next;
	    }

	    return size;
	};

	List.prototype.fromArray = function(array) {
	    var cursor = null;

	    this.head = null;

	    for (var i = 0; i < array.length; i++) {
	        var item = createItem(array[i]);

	        if (cursor !== null) {
	            cursor.next = item;
	        } else {
	            this.head = item;
	        }

	        item.prev = cursor;
	        cursor = item;
	    }

	    this.tail = cursor;

	    return this;
	};

	List.prototype.toArray = function() {
	    var cursor = this.head;
	    var result = [];

	    while (cursor) {
	        result.push(cursor.data);
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.toJSON = List.prototype.toArray;

	List.prototype.isEmpty = function() {
	    return this.head === null;
	};

	List.prototype.first = function() {
	    return this.head && this.head.data;
	};

	List.prototype.last = function() {
	    return this.tail && this.tail.data;
	};

	List.prototype.each = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, this.head);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEach = List.prototype.each;

	List.prototype.eachRight = function(fn, context) {
	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, this.tail, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        fn.call(context, item.data, item, this);
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.forEachRight = List.prototype.eachRight;

	List.prototype.nextUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, null, start);

	    while (cursor.next !== null) {
	        item = cursor.next;
	        cursor.next = item.next;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.prevUntil = function(start, fn, context) {
	    if (start === null) {
	        return;
	    }

	    var item;

	    if (context === undefined) {
	        context = this;
	    }

	    // push cursor
	    var cursor = allocateCursor(this, start, null);

	    while (cursor.prev !== null) {
	        item = cursor.prev;
	        cursor.prev = item.prev;

	        if (fn.call(context, item.data, item, this)) {
	            break;
	        }
	    }

	    // pop cursor
	    releaseCursor(this);
	};

	List.prototype.some = function(fn, context) {
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            return true;
	        }

	        cursor = cursor.next;
	    }

	    return false;
	};

	List.prototype.map = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        result.appendData(fn.call(context, cursor.data, cursor, this));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.filter = function(fn, context) {
	    var result = new List();
	    var cursor = this.head;

	    if (context === undefined) {
	        context = this;
	    }

	    while (cursor !== null) {
	        if (fn.call(context, cursor.data, cursor, this)) {
	            result.appendData(cursor.data);
	        }
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.clear = function() {
	    this.head = null;
	    this.tail = null;
	};

	List.prototype.copy = function() {
	    var result = new List();
	    var cursor = this.head;

	    while (cursor !== null) {
	        result.insert(createItem(cursor.data));
	        cursor = cursor.next;
	    }

	    return result;
	};

	List.prototype.prepend = function(item) {
	    //      head
	    //    ^
	    // item
	    this.updateCursors(null, item, this.head, item);

	    // insert to the beginning of the list
	    if (this.head !== null) {
	        // new item <- first item
	        this.head.prev = item;

	        // new item -> first item
	        item.next = this.head;
	    } else {
	        // if list has no head, then it also has no tail
	        // in this case tail points to the new item
	        this.tail = item;
	    }

	    // head always points to new item
	    this.head = item;

	    return this;
	};

	List.prototype.prependData = function(data) {
	    return this.prepend(createItem(data));
	};

	List.prototype.append = function(item) {
	    return this.insert(item);
	};

	List.prototype.appendData = function(data) {
	    return this.insert(createItem(data));
	};

	List.prototype.insert = function(item, before) {
	    if (before !== undefined && before !== null) {
	        // prev   before
	        //      ^
	        //     item
	        this.updateCursors(before.prev, item, before, item);

	        if (before.prev === null) {
	            // insert to the beginning of list
	            if (this.head !== before) {
	                throw new Error('before doesn\'t belong to list');
	            }

	            // since head points to before therefore list doesn't empty
	            // no need to check tail
	            this.head = item;
	            before.prev = item;
	            item.next = before;

	            this.updateCursors(null, item);
	        } else {

	            // insert between two items
	            before.prev.next = item;
	            item.prev = before.prev;

	            before.prev = item;
	            item.next = before;
	        }
	    } else {
	        // tail
	        //      ^
	        //      item
	        this.updateCursors(this.tail, item, null, item);

	        // insert to the ending of the list
	        if (this.tail !== null) {
	            // last item -> new item
	            this.tail.next = item;

	            // last item <- new item
	            item.prev = this.tail;
	        } else {
	            // if list has no tail, then it also has no head
	            // in this case head points to new item
	            this.head = item;
	        }

	        // tail always points to new item
	        this.tail = item;
	    }

	    return this;
	};

	List.prototype.insertData = function(data, before) {
	    return this.insert(createItem(data), before);
	};

	List.prototype.remove = function(item) {
	    //      item
	    //       ^
	    // prev     next
	    this.updateCursors(item, item.prev, item, item.next);

	    if (item.prev !== null) {
	        item.prev.next = item.next;
	    } else {
	        if (this.head !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.head = item.next;
	    }

	    if (item.next !== null) {
	        item.next.prev = item.prev;
	    } else {
	        if (this.tail !== item) {
	            throw new Error('item doesn\'t belong to list');
	        }

	        this.tail = item.prev;
	    }

	    item.prev = null;
	    item.next = null;

	    return item;
	};

	List.prototype.push = function(data) {
	    this.insert(createItem(data));
	};

	List.prototype.pop = function() {
	    if (this.tail !== null) {
	        return this.remove(this.tail);
	    }
	};

	List.prototype.unshift = function(data) {
	    this.prepend(createItem(data));
	};

	List.prototype.shift = function() {
	    if (this.head !== null) {
	        return this.remove(this.head);
	    }
	};

	List.prototype.prependList = function(list) {
	    return this.insertList(list, this.head);
	};

	List.prototype.appendList = function(list) {
	    return this.insertList(list);
	};

	List.prototype.insertList = function(list, before) {
	    // ignore empty lists
	    if (list.head === null) {
	        return this;
	    }

	    if (before !== undefined && before !== null) {
	        this.updateCursors(before.prev, list.tail, before, list.head);

	        // insert in the middle of dist list
	        if (before.prev !== null) {
	            // before.prev <-> list.head
	            before.prev.next = list.head;
	            list.head.prev = before.prev;
	        } else {
	            this.head = list.head;
	        }

	        before.prev = list.tail;
	        list.tail.next = before;
	    } else {
	        this.updateCursors(this.tail, list.tail, null, list.head);

	        // insert to end of the list
	        if (this.tail !== null) {
	            // if destination list has a tail, then it also has a head,
	            // but head doesn't change

	            // dest tail -> source head
	            this.tail.next = list.head;

	            // dest tail <- source head
	            list.head.prev = this.tail;
	        } else {
	            // if list has no a tail, then it also has no a head
	            // in this case points head to new item
	            this.head = list.head;
	        }

	        // tail always start point to new item
	        this.tail = list.tail;
	    }

	    list.head = null;
	    list.tail = null;

	    return this;
	};

	List.prototype.replace = function(oldItem, newItemOrList) {
	    if ('head' in newItemOrList) {
	        this.insertList(newItemOrList, oldItem);
	    } else {
	        this.insert(newItemOrList, oldItem);
	    }

	    this.remove(oldItem);
	};

	var List_1 = List;

	var createCustomError = function createCustomError(name, message) {
	    // use Object.create(), because some VMs prevent setting line/column otherwise
	    // (iOS Safari 10 even throws an exception)
	    var error = Object.create(SyntaxError.prototype);
	    var errorStack = new Error();

	    error.name = name;
	    error.message = message;

	    Object.defineProperty(error, 'stack', {
	        get: function() {
	            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, name + ': ' + message + '\n');
	        }
	    });

	    return error;
	};

	var MAX_LINE_LENGTH = 100;
	var OFFSET_CORRECTION = 60;
	var TAB_REPLACEMENT = '    ';

	function sourceFragment(error, extraLines) {
	    function processLines(start, end) {
	        return lines.slice(start, end).map(function(line, idx) {
	            var num = String(start + idx + 1);

	            while (num.length < maxNumLength) {
	                num = ' ' + num;
	            }

	            return num + ' |' + line;
	        }).join('\n');
	    }

	    var lines = error.source.split(/\r\n?|\n|\f/);
	    var line = error.line;
	    var column = error.column;
	    var startLine = Math.max(1, line - extraLines) - 1;
	    var endLine = Math.min(line + extraLines, lines.length + 1);
	    var maxNumLength = Math.max(4, String(endLine).length) + 1;
	    var cutLeft = 0;

	    // column correction according to replaced tab before column
	    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

	    if (column > MAX_LINE_LENGTH) {
	        cutLeft = column - OFFSET_CORRECTION + 3;
	        column = OFFSET_CORRECTION - 2;
	    }

	    for (var i = startLine; i <= endLine; i++) {
	        if (i >= 0 && i < lines.length) {
	            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
	            lines[i] =
	                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
	                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
	                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
	        }
	    }

	    return [
	        processLines(startLine, line),
	        new Array(column + maxNumLength + 2).join('-') + '^',
	        processLines(line, endLine)
	    ].filter(Boolean).join('\n');
	}

	var SyntaxError$1 = function(message, source, offset, line, column) {
	    var error = createCustomError('SyntaxError', message);

	    error.source = source;
	    error.offset = offset;
	    error.line = line;
	    error.column = column;

	    error.sourceFragment = function(extraLines) {
	        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
	    };
	    Object.defineProperty(error, 'formattedMessage', {
	        get: function() {
	            return (
	                'Parse error: ' + error.message + '\n' +
	                sourceFragment(error, 2)
	            );
	        }
	    });

	    // for backward capability
	    error.parseError = {
	        offset: offset,
	        line: line,
	        column: column
	    };

	    return error;
	};

	var _SyntaxError = SyntaxError$1;

	// CSS Syntax Module Level 3
	// https://www.w3.org/TR/css-syntax-3/
	var TYPE = {
	    EOF: 0,                 // <EOF-token>
	    Ident: 1,               // <ident-token>
	    Function: 2,            // <function-token>
	    AtKeyword: 3,           // <at-keyword-token>
	    Hash: 4,                // <hash-token>
	    String: 5,              // <string-token>
	    BadString: 6,           // <bad-string-token>
	    Url: 7,                 // <url-token>
	    BadUrl: 8,              // <bad-url-token>
	    Delim: 9,               // <delim-token>
	    Number: 10,             // <number-token>
	    Percentage: 11,         // <percentage-token>
	    Dimension: 12,          // <dimension-token>
	    WhiteSpace: 13,         // <whitespace-token>
	    CDO: 14,                // <CDO-token>
	    CDC: 15,                // <CDC-token>
	    Colon: 16,              // <colon-token>     :
	    Semicolon: 17,          // <semicolon-token> ;
	    Comma: 18,              // <comma-token>     ,
	    LeftSquareBracket: 19,  // <[-token>
	    RightSquareBracket: 20, // <]-token>
	    LeftParenthesis: 21,    // <(-token>
	    RightParenthesis: 22,   // <)-token>
	    LeftCurlyBracket: 23,   // <{-token>
	    RightCurlyBracket: 24,  // <}-token>
	    Comment: 25
	};

	var NAME = Object.keys(TYPE).reduce(function(result, key) {
	    result[TYPE[key]] = key;
	    return result;
	}, {});

	var _const = {
	    TYPE: TYPE,
	    NAME: NAME
	};

	var EOF = 0;

	// https://drafts.csswg.org/css-syntax-3/
	// § 4.2. Definitions

	// digit
	// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
	function isDigit(code) {
	    return code >= 0x0030 && code <= 0x0039;
	}

	// hex digit
	// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
	// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
	function isHexDigit(code) {
	    return (
	        isDigit(code) || // 0 .. 9
	        (code >= 0x0041 && code <= 0x0046) || // A .. F
	        (code >= 0x0061 && code <= 0x0066)    // a .. f
	    );
	}

	// uppercase letter
	// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
	function isUppercaseLetter(code) {
	    return code >= 0x0041 && code <= 0x005A;
	}

	// lowercase letter
	// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
	function isLowercaseLetter(code) {
	    return code >= 0x0061 && code <= 0x007A;
	}

	// letter
	// An uppercase letter or a lowercase letter.
	function isLetter(code) {
	    return isUppercaseLetter(code) || isLowercaseLetter(code);
	}

	// non-ASCII code point
	// A code point with a value equal to or greater than U+0080 <control>.
	function isNonAscii(code) {
	    return code >= 0x0080;
	}

	// name-start code point
	// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	function isNameStart(code) {
	    return isLetter(code) || isNonAscii(code) || code === 0x005F;
	}

	// name code point
	// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
	function isName(code) {
	    return isNameStart(code) || isDigit(code) || code === 0x002D;
	}

	// non-printable code point
	// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
	// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
	function isNonPrintable(code) {
	    return (
	        (code >= 0x0000 && code <= 0x0008) ||
	        (code === 0x000B) ||
	        (code >= 0x000E && code <= 0x001F) ||
	        (code === 0x007F)
	    );
	}

	// newline
	// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
	// as they are converted to U+000A LINE FEED during preprocessing.
	// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
	function isNewline(code) {
	    return code === 0x000A || code === 0x000D || code === 0x000C;
	}

	// whitespace
	// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
	function isWhiteSpace(code) {
	    return isNewline(code) || code === 0x0020 || code === 0x0009;
	}

	// § 4.3.8. Check if two code points are a valid escape
	function isValidEscape(first, second) {
	    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
	    if (first !== 0x005C) {
	        return false;
	    }

	    // Otherwise, if the second code point is a newline or EOF, return false.
	    if (isNewline(second) || second === EOF) {
	        return false;
	    }

	    // Otherwise, return true.
	    return true;
	}

	// § 4.3.9. Check if three code points would start an identifier
	function isIdentifierStart(first, second, third) {
	    // Look at the first code point:

	    // U+002D HYPHEN-MINUS
	    if (first === 0x002D) {
	        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
	        // or the second and third code points are a valid escape, return true. Otherwise, return false.
	        return (
	            isNameStart(second) ||
	            second === 0x002D ||
	            isValidEscape(second, third)
	        );
	    }

	    // name-start code point
	    if (isNameStart(first)) {
	        // Return true.
	        return true;
	    }

	    // U+005C REVERSE SOLIDUS (\)
	    if (first === 0x005C) {
	        // If the first and second code points are a valid escape, return true. Otherwise, return false.
	        return isValidEscape(first, second);
	    }

	    // anything else
	    // Return false.
	    return false;
	}

	// § 4.3.10. Check if three code points would start a number
	function isNumberStart(first, second, third) {
	    // Look at the first code point:

	    // U+002B PLUS SIGN (+)
	    // U+002D HYPHEN-MINUS (-)
	    if (first === 0x002B || first === 0x002D) {
	        // If the second code point is a digit, return true.
	        if (isDigit(second)) {
	            return 2;
	        }

	        // Otherwise, if the second code point is a U+002E FULL STOP (.)
	        // and the third code point is a digit, return true.
	        // Otherwise, return false.
	        return second === 0x002E && isDigit(third) ? 3 : 0;
	    }

	    // U+002E FULL STOP (.)
	    if (first === 0x002E) {
	        // If the second code point is a digit, return true. Otherwise, return false.
	        return isDigit(second) ? 2 : 0;
	    }

	    // digit
	    if (isDigit(first)) {
	        // Return true.
	        return 1;
	    }

	    // anything else
	    // Return false.
	    return 0;
	}

	//
	// Misc
	//

	// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
	function isBOM(code) {
	    // UTF-16BE
	    if (code === 0xFEFF) {
	        return 1;
	    }

	    // UTF-16LE
	    if (code === 0xFFFE) {
	        return 1;
	    }

	    return 0;
	}

	// Fast code category
	//
	// https://drafts.csswg.org/css-syntax/#tokenizer-definitions
	// > non-ASCII code point
	// >   A code point with a value equal to or greater than U+0080 <control>
	// > name-start code point
	// >   A letter, a non-ASCII code point, or U+005F LOW LINE (_).
	// > name code point
	// >   A name-start code point, a digit, or U+002D HYPHEN-MINUS (-)
	// That means only ASCII code points has a special meaning and we define a maps for 0..127 codes only
	var CATEGORY = new Array(0x80);
	charCodeCategory.Eof = 0x80;
	charCodeCategory.WhiteSpace = 0x82;
	charCodeCategory.Digit = 0x83;
	charCodeCategory.NameStart = 0x84;
	charCodeCategory.NonPrintable = 0x85;

	for (var i = 0; i < CATEGORY.length; i++) {
	    switch (true) {
	        case isWhiteSpace(i):
	            CATEGORY[i] = charCodeCategory.WhiteSpace;
	            break;

	        case isDigit(i):
	            CATEGORY[i] = charCodeCategory.Digit;
	            break;

	        case isNameStart(i):
	            CATEGORY[i] = charCodeCategory.NameStart;
	            break;

	        case isNonPrintable(i):
	            CATEGORY[i] = charCodeCategory.NonPrintable;
	            break;

	        default:
	            CATEGORY[i] = i || charCodeCategory.Eof;
	    }
	}

	function charCodeCategory(code) {
	    return code < 0x80 ? CATEGORY[code] : charCodeCategory.NameStart;
	}
	var charCodeDefinitions = {
	    isDigit: isDigit,
	    isHexDigit: isHexDigit,
	    isUppercaseLetter: isUppercaseLetter,
	    isLowercaseLetter: isLowercaseLetter,
	    isLetter: isLetter,
	    isNonAscii: isNonAscii,
	    isNameStart: isNameStart,
	    isName: isName,
	    isNonPrintable: isNonPrintable,
	    isNewline: isNewline,
	    isWhiteSpace: isWhiteSpace,
	    isValidEscape: isValidEscape,
	    isIdentifierStart: isIdentifierStart,
	    isNumberStart: isNumberStart,

	    isBOM: isBOM,
	    charCodeCategory: charCodeCategory
	};

	var isDigit$1 = charCodeDefinitions.isDigit;
	var isHexDigit$1 = charCodeDefinitions.isHexDigit;
	var isUppercaseLetter$1 = charCodeDefinitions.isUppercaseLetter;
	var isName$1 = charCodeDefinitions.isName;
	var isWhiteSpace$1 = charCodeDefinitions.isWhiteSpace;
	var isValidEscape$1 = charCodeDefinitions.isValidEscape;

	function getCharCode(source, offset) {
	    return offset < source.length ? source.charCodeAt(offset) : 0;
	}

	function getNewlineLength(source, offset, code) {
	    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
	        return 2;
	    }

	    return 1;
	}

	function cmpChar(testStr, offset, referenceCode) {
	    var code = testStr.charCodeAt(offset);

	    // code.toLowerCase() for A..Z
	    if (isUppercaseLetter$1(code)) {
	        code = code | 32;
	    }

	    return code === referenceCode;
	}

	function cmpStr(testStr, start, end, referenceStr) {
	    if (end - start !== referenceStr.length) {
	        return false;
	    }

	    if (start < 0 || end > testStr.length) {
	        return false;
	    }

	    for (var i = start; i < end; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i - start);

	        // testCode.toLowerCase() for A..Z
	        if (isUppercaseLetter$1(testCode)) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function findWhiteSpaceStart(source, offset) {
	    for (; offset >= 0; offset--) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset + 1;
	}

	function findWhiteSpaceEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isWhiteSpace$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	function findDecimalNumberEnd(source, offset) {
	    for (; offset < source.length; offset++) {
	        if (!isDigit$1(source.charCodeAt(offset))) {
	            break;
	        }
	    }

	    return offset;
	}

	// § 4.3.7. Consume an escaped code point
	function consumeEscaped(source, offset) {
	    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
	    // that the next input code point has already been verified to be part of a valid escape.
	    offset += 2;

	    // hex digit
	    if (isHexDigit$1(getCharCode(source, offset - 1))) {
	        // Consume as many hex digits as possible, but no more than 5.
	        // Note that this means 1-6 hex digits have been consumed in total.
	        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
	            if (!isHexDigit$1(getCharCode(source, offset))) {
	                break;
	            }
	        }

	        // If the next input code point is whitespace, consume it as well.
	        var code = getCharCode(source, offset);
	        if (isWhiteSpace$1(code)) {
	            offset += getNewlineLength(source, offset, code);
	        }
	    }

	    return offset;
	}

	// §4.3.11. Consume a name
	// Note: This algorithm does not do the verification of the first few code points that are necessary
	// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
	// ensure that the stream starts with an identifier before calling this algorithm.
	function consumeName(source, offset) {
	    // Let result initially be an empty string.
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // name code point
	        if (isName$1(code)) {
	            // Append the code point to result.
	            continue;
	        }

	        // the stream starts with a valid escape
	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point. Append the returned code point to result.
	            offset = consumeEscaped(source, offset) - 1;
	            continue;
	        }

	        // anything else
	        // Reconsume the current input code point. Return result.
	        break;
	    }

	    return offset;
	}

	// §4.3.12. Consume a number
	function consumeNumber(source, offset) {
	    var code = source.charCodeAt(offset);

	    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
	    // consume it and append it to repr.
	    if (code === 0x002B || code === 0x002D) {
	        code = source.charCodeAt(offset += 1);
	    }

	    // 3. While the next input code point is a digit, consume it and append it to repr.
	    if (isDigit$1(code)) {
	        offset = findDecimalNumberEnd(source, offset + 1);
	        code = source.charCodeAt(offset);
	    }

	    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
	    if (code === 0x002E && isDigit$1(source.charCodeAt(offset + 1))) {
	        // 4.1 Consume them.
	        // 4.2 Append them to repr.
	        code = source.charCodeAt(offset += 2);

	        // 4.3 Set type to "number".
	        // TODO

	        // 4.4 While the next input code point is a digit, consume it and append it to repr.

	        offset = findDecimalNumberEnd(source, offset);
	    }

	    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
	    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
	    if (cmpChar(source, offset, 101 /* e */)) {
	        var sign = 0;
	        code = source.charCodeAt(offset + 1);

	        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
	        if (code === 0x002D || code === 0x002B) {
	            sign = 1;
	            code = source.charCodeAt(offset + 2);
	        }

	        // ... followed by a digit
	        if (isDigit$1(code)) {
	            // 5.1 Consume them.
	            // 5.2 Append them to repr.

	            // 5.3 Set type to "number".
	            // TODO

	            // 5.4 While the next input code point is a digit, consume it and append it to repr.
	            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
	        }
	    }

	    return offset;
	}

	// § 4.3.14. Consume the remnants of a bad url
	// ... its sole use is to consume enough of the input stream to reach a recovery point
	// where normal tokenizing can resume.
	function consumeBadUrlRemnants(source, offset) {
	    // Repeatedly consume the next input code point from the stream:
	    for (; offset < source.length; offset++) {
	        var code = source.charCodeAt(offset);

	        // U+0029 RIGHT PARENTHESIS ())
	        // EOF
	        if (code === 0x0029) {
	            // Return.
	            offset++;
	            break;
	        }

	        if (isValidEscape$1(code, getCharCode(source, offset + 1))) {
	            // Consume an escaped code point.
	            // Note: This allows an escaped right parenthesis ("\)") to be encountered
	            // without ending the <bad-url-token>. This is otherwise identical to
	            // the "anything else" clause.
	            offset = consumeEscaped(source, offset);
	        }
	    }

	    return offset;
	}

	var utils = {
	    consumeEscaped: consumeEscaped,
	    consumeName: consumeName,
	    consumeNumber: consumeNumber,
	    consumeBadUrlRemnants: consumeBadUrlRemnants,

	    cmpChar: cmpChar,
	    cmpStr: cmpStr,

	    getNewlineLength: getNewlineLength,
	    findWhiteSpaceStart: findWhiteSpaceStart,
	    findWhiteSpaceEnd: findWhiteSpaceEnd
	};

	var TYPE$1 = _const.TYPE;
	var NAME$1 = _const.NAME;


	var cmpStr$1 = utils.cmpStr;

	var EOF$1 = TYPE$1.EOF;
	var WHITESPACE = TYPE$1.WhiteSpace;
	var COMMENT = TYPE$1.Comment;

	var OFFSET_MASK = 0x00FFFFFF;
	var TYPE_SHIFT = 24;

	var TokenStream = function() {
	    this.offsetAndType = null;
	    this.balance = null;

	    this.reset();
	};

	TokenStream.prototype = {
	    reset: function() {
	        this.eof = false;
	        this.tokenIndex = -1;
	        this.tokenType = 0;
	        this.tokenStart = this.firstCharOffset;
	        this.tokenEnd = this.firstCharOffset;
	    },

	    lookupType: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset] >> TYPE_SHIFT;
	        }

	        return EOF$1;
	    },
	    lookupOffset: function(offset) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return this.offsetAndType[offset - 1] & OFFSET_MASK;
	        }

	        return this.source.length;
	    },
	    lookupValue: function(offset, referenceStr) {
	        offset += this.tokenIndex;

	        if (offset < this.tokenCount) {
	            return cmpStr$1(
	                this.source,
	                this.offsetAndType[offset - 1] & OFFSET_MASK,
	                this.offsetAndType[offset] & OFFSET_MASK,
	                referenceStr
	            );
	        }

	        return false;
	    },
	    getTokenStart: function(tokenIndex) {
	        if (tokenIndex === this.tokenIndex) {
	            return this.tokenStart;
	        }

	        if (tokenIndex > 0) {
	            return tokenIndex < this.tokenCount
	                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
	                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
	        }

	        return this.firstCharOffset;
	    },

	    // TODO: -> skipUntilBalanced
	    getRawLength: function(startToken, mode) {
	        var cursor = startToken;
	        var balanceEnd;
	        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
	        var type;

	        loop:
	        for (; cursor < this.tokenCount; cursor++) {
	            balanceEnd = this.balance[cursor];

	            // stop scanning on balance edge that points to offset before start token
	            if (balanceEnd < startToken) {
	                break loop;
	            }

	            type = this.offsetAndType[cursor] >> TYPE_SHIFT;

	            // check token is stop type
	            switch (mode(type, this.source, offset)) {
	                case 1:
	                    break loop;

	                case 2:
	                    cursor++;
	                    break loop;

	                default:
	                    offset = this.offsetAndType[cursor] & OFFSET_MASK;

	                    // fast forward to the end of balanced block
	                    if (this.balance[balanceEnd] === cursor) {
	                        cursor = balanceEnd;
	                    }
	            }
	        }

	        return cursor - this.tokenIndex;
	    },
	    isBalanceEdge: function(pos) {
	        return this.balance[this.tokenIndex] < pos;
	    },
	    isDelim: function(code, offset) {
	        if (offset) {
	            return (
	                this.lookupType(offset) === TYPE$1.Delim &&
	                this.source.charCodeAt(this.lookupOffset(offset)) === code
	            );
	        }

	        return (
	            this.tokenType === TYPE$1.Delim &&
	            this.source.charCodeAt(this.tokenStart) === code
	        );
	    },

	    getTokenValue: function() {
	        return this.source.substring(this.tokenStart, this.tokenEnd);
	    },
	    getTokenLength: function() {
	        return this.tokenEnd - this.tokenStart;
	    },
	    substrToCursor: function(start) {
	        return this.source.substring(start, this.tokenStart);
	    },

	    skipWS: function() {
	        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
	            if ((this.offsetAndType[i] >> TYPE_SHIFT) !== WHITESPACE) {
	                break;
	            }
	        }

	        if (skipTokenCount > 0) {
	            this.skip(skipTokenCount);
	        }
	    },
	    skipSC: function() {
	        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
	            this.next();
	        }
	    },
	    skip: function(tokenCount) {
	        var next = this.tokenIndex + tokenCount;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.next();
	        }
	    },
	    next: function() {
	        var next = this.tokenIndex + 1;

	        if (next < this.tokenCount) {
	            this.tokenIndex = next;
	            this.tokenStart = this.tokenEnd;
	            next = this.offsetAndType[next];
	            this.tokenType = next >> TYPE_SHIFT;
	            this.tokenEnd = next & OFFSET_MASK;
	        } else {
	            this.tokenIndex = this.tokenCount;
	            this.eof = true;
	            this.tokenType = EOF$1;
	            this.tokenStart = this.tokenEnd = this.source.length;
	        }
	    },

	    dump: function() {
	        var offset = this.firstCharOffset;

	        return Array.prototype.slice.call(this.offsetAndType, 0, this.tokenCount).map(function(item, idx) {
	            var start = offset;
	            var end = item & OFFSET_MASK;

	            offset = end;

	            return {
	                idx: idx,
	                type: NAME$1[item >> TYPE_SHIFT],
	                chunk: this.source.substring(start, end),
	                balance: this.balance[idx]
	            };
	        }, this);
	    }
	};

	var TokenStream_1 = TokenStream;

	function noop$1(value) {
	    return value;
	}

	function generateMultiplier(multiplier) {
	    if (multiplier.min === 0 && multiplier.max === 0) {
	        return '*';
	    }

	    if (multiplier.min === 0 && multiplier.max === 1) {
	        return '?';
	    }

	    if (multiplier.min === 1 && multiplier.max === 0) {
	        return multiplier.comma ? '#' : '+';
	    }

	    if (multiplier.min === 1 && multiplier.max === 1) {
	        return '';
	    }

	    return (
	        (multiplier.comma ? '#' : '') +
	        (multiplier.min === multiplier.max
	            ? '{' + multiplier.min + '}'
	            : '{' + multiplier.min + ',' + (multiplier.max !== 0 ? multiplier.max : '') + '}'
	        )
	    );
	}

	function generateTypeOpts(node) {
	    switch (node.type) {
	        case 'Range':
	            return (
	                ' [' +
	                (node.min === null ? '-∞' : node.min) +
	                ',' +
	                (node.max === null ? '∞' : node.max) +
	                ']'
	            );

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }
	}

	function generateSequence(node, decorate, forceBraces, compact) {
	    var combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
	    var result = node.terms.map(function(term) {
	        return generate(term, decorate, forceBraces, compact);
	    }).join(combinator);

	    if (node.explicit || forceBraces) {
	        result = (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
	    }

	    return result;
	}

	function generate(node, decorate, forceBraces, compact) {
	    var result;

	    switch (node.type) {
	        case 'Group':
	            result =
	                generateSequence(node, decorate, forceBraces, compact) +
	                (node.disallowEmpty ? '!' : '');
	            break;

	        case 'Multiplier':
	            // return since node is a composition
	            return (
	                generate(node.term, decorate, forceBraces, compact) +
	                decorate(generateMultiplier(node), node)
	            );

	        case 'Type':
	            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
	            break;

	        case 'Property':
	            result = '<\'' + node.name + '\'>';
	            break;

	        case 'Keyword':
	            result = node.name;
	            break;

	        case 'AtKeyword':
	            result = '@' + node.name;
	            break;

	        case 'Function':
	            result = node.name + '(';
	            break;

	        case 'String':
	        case 'Token':
	            result = node.value;
	            break;

	        case 'Comma':
	            result = ',';
	            break;

	        default:
	            throw new Error('Unknown node type `' + node.type + '`');
	    }

	    return decorate(result, node);
	}

	var generate_1 = function(node, options) {
	    var decorate = noop$1;
	    var forceBraces = false;
	    var compact = false;

	    if (typeof options === 'function') {
	        decorate = options;
	    } else if (options) {
	        forceBraces = Boolean(options.forceBraces);
	        compact = Boolean(options.compact);
	        if (typeof options.decorate === 'function') {
	            decorate = options.decorate;
	        }
	    }

	    return generate(node, decorate, forceBraces, compact);
	};

	function fromMatchResult(matchResult) {
	    var tokens = matchResult.tokens;
	    var longestMatch = matchResult.longestMatch;
	    var node = longestMatch < tokens.length ? tokens[longestMatch].node : null;
	    var mismatchOffset = -1;
	    var entries = 0;
	    var css = '';

	    for (var i = 0; i < tokens.length; i++) {
	        if (i === longestMatch) {
	            mismatchOffset = css.length;
	        }

	        if (node !== null && tokens[i].node === node) {
	            if (i <= longestMatch) {
	                entries++;
	            } else {
	                entries = 0;
	            }
	        }

	        css += tokens[i].value;
	    }

	    return {
	        node: node,
	        css: css,
	        mismatchOffset: mismatchOffset === -1 ? css.length : mismatchOffset,
	        last: node === null || entries > 1
	    };
	}

	function getLocation(node, point) {
	    var loc = node && node.loc && node.loc[point];

	    if (loc) {
	        return {
	            offset: loc.offset,
	            line: loc.line,
	            column: loc.column
	        };
	    }

	    return null;
	}

	var SyntaxReferenceError = function(type, referenceName) {
	    var error = createCustomError(
	        'SyntaxReferenceError',
	        type + (referenceName ? ' `' + referenceName + '`' : '')
	    );

	    error.reference = referenceName;

	    return error;
	};

	var MatchError = function(message, syntax, node, matchResult) {
	    var error = createCustomError('SyntaxMatchError', message);
	    var details = fromMatchResult(matchResult);
	    var mismatchOffset = details.mismatchOffset || 0;
	    var badNode = details.node || node;
	    var end = getLocation(badNode, 'end');
	    var start = details.last ? end : getLocation(badNode, 'start');
	    var css = details.css;

	    error.rawMessage = message;
	    error.syntax = syntax ? generate_1(syntax) : '<generic>';
	    error.css = css;
	    error.mismatchOffset = mismatchOffset;
	    error.loc = {
	        source: (badNode && badNode.loc && badNode.loc.source) || '<unknown>',
	        start: start,
	        end: end
	    };
	    error.line = start ? start.line : undefined;
	    error.column = start ? start.column : undefined;
	    error.offset = start ? start.offset : undefined;
	    error.message = message + '\n' +
	        '  syntax: ' + error.syntax + '\n' +
	        '   value: ' + (error.css || '<empty string>') + '\n' +
	        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

	    return error;
	};

	var error = {
	    SyntaxReferenceError: SyntaxReferenceError,
	    MatchError: MatchError
	};

	var hasOwnProperty = Object.prototype.hasOwnProperty;
	var keywords = Object.create(null);
	var properties = Object.create(null);
	var HYPHENMINUS = 45; // '-'.charCodeAt()

	function isCustomProperty(str, offset) {
	    offset = offset || 0;

	    return str.length - offset >= 2 &&
	           str.charCodeAt(offset) === HYPHENMINUS &&
	           str.charCodeAt(offset + 1) === HYPHENMINUS;
	}

	function getVendorPrefix(str, offset) {
	    offset = offset || 0;

	    // verdor prefix should be at least 3 chars length
	    if (str.length - offset >= 3) {
	        // vendor prefix starts with hyper minus following non-hyper minus
	        if (str.charCodeAt(offset) === HYPHENMINUS &&
	            str.charCodeAt(offset + 1) !== HYPHENMINUS) {
	            // vendor prefix should contain a hyper minus at the ending
	            var secondDashIndex = str.indexOf('-', offset + 2);

	            if (secondDashIndex !== -1) {
	                return str.substring(offset, secondDashIndex + 1);
	            }
	        }
	    }

	    return '';
	}

	function getKeywordDescriptor(keyword) {
	    if (hasOwnProperty.call(keywords, keyword)) {
	        return keywords[keyword];
	    }

	    var name = keyword.toLowerCase();

	    if (hasOwnProperty.call(keywords, name)) {
	        return keywords[keyword] = keywords[name];
	    }

	    var custom = isCustomProperty(name, 0);
	    var vendor = !custom ? getVendorPrefix(name, 0) : '';

	    return keywords[keyword] = Object.freeze({
	        basename: name.substr(vendor.length),
	        name: name,
	        vendor: vendor,
	        prefix: vendor,
	        custom: custom
	    });
	}

	function getPropertyDescriptor(property) {
	    if (hasOwnProperty.call(properties, property)) {
	        return properties[property];
	    }

	    var name = property;
	    var hack = property[0];

	    if (hack === '/') {
	        hack = property[1] === '/' ? '//' : '/';
	    } else if (hack !== '_' &&
	               hack !== '*' &&
	               hack !== '$' &&
	               hack !== '#' &&
	               hack !== '+' &&
	               hack !== '&') {
	        hack = '';
	    }

	    var custom = isCustomProperty(name, hack.length);

	    // re-use result when possible (the same as for lower case)
	    if (!custom) {
	        name = name.toLowerCase();
	        if (hasOwnProperty.call(properties, name)) {
	            return properties[property] = properties[name];
	        }
	    }

	    var vendor = !custom ? getVendorPrefix(name, hack.length) : '';
	    var prefix = name.substr(0, hack.length + vendor.length);

	    return properties[property] = Object.freeze({
	        basename: name.substr(prefix.length),
	        name: name.substr(hack.length),
	        hack: hack,
	        vendor: vendor,
	        prefix: prefix,
	        custom: custom
	    });
	}

	var names = {
	    keyword: getKeywordDescriptor,
	    property: getPropertyDescriptor,
	    isCustomProperty: isCustomProperty,
	    vendorPrefix: getVendorPrefix
	};

	var MIN_SIZE = 16 * 1024;
	var SafeUint32Array = typeof Uint32Array !== 'undefined' ? Uint32Array : Array; // fallback on Array when TypedArray is not supported

	var adoptBuffer = function adoptBuffer(buffer, size) {
	    if (buffer === null || buffer.length < size) {
	        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
	    }

	    return buffer;
	};

	var TYPE$2 = _const.TYPE;


	var isNewline$1 = charCodeDefinitions.isNewline;
	var isName$2 = charCodeDefinitions.isName;
	var isValidEscape$2 = charCodeDefinitions.isValidEscape;
	var isNumberStart$1 = charCodeDefinitions.isNumberStart;
	var isIdentifierStart$1 = charCodeDefinitions.isIdentifierStart;
	var charCodeCategory$1 = charCodeDefinitions.charCodeCategory;
	var isBOM$1 = charCodeDefinitions.isBOM;


	var cmpStr$2 = utils.cmpStr;
	var getNewlineLength$1 = utils.getNewlineLength;
	var findWhiteSpaceEnd$1 = utils.findWhiteSpaceEnd;
	var consumeEscaped$1 = utils.consumeEscaped;
	var consumeName$1 = utils.consumeName;
	var consumeNumber$1 = utils.consumeNumber;
	var consumeBadUrlRemnants$1 = utils.consumeBadUrlRemnants;

	var OFFSET_MASK$1 = 0x00FFFFFF;
	var TYPE_SHIFT$1 = 24;

	function tokenize(source, stream) {
	    function getCharCode(offset) {
	        return offset < sourceLength ? source.charCodeAt(offset) : 0;
	    }

	    // § 4.3.3. Consume a numeric token
	    function consumeNumericToken() {
	        // Consume a number and let number be the result.
	        offset = consumeNumber$1(source, offset);

	        // If the next 3 input code points would start an identifier, then:
	        if (isIdentifierStart$1(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
	            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
	            // Consume a name. Set the <dimension-token>’s unit to the returned value.
	            // Return the <dimension-token>.
	            type = TYPE$2.Dimension;
	            offset = consumeName$1(source, offset);
	            return;
	        }

	        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
	        if (getCharCode(offset) === 0x0025) {
	            // Create a <percentage-token> with the same value as number, and return it.
	            type = TYPE$2.Percentage;
	            offset++;
	            return;
	        }

	        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
	        type = TYPE$2.Number;
	    }

	    // § 4.3.4. Consume an ident-like token
	    function consumeIdentLikeToken() {
	        const nameStartOffset = offset;

	        // Consume a name, and let string be the result.
	        offset = consumeName$1(source, offset);

	        // If string’s value is an ASCII case-insensitive match for "url",
	        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        if (cmpStr$2(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
	            // While the next two input code points are whitespace, consume the next input code point.
	            offset = findWhiteSpaceEnd$1(source, offset + 1);

	            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
	            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
	            // then create a <function-token> with its value set to string and return it.
	            if (getCharCode(offset) === 0x0022 ||
	                getCharCode(offset) === 0x0027) {
	                type = TYPE$2.Function;
	                offset = nameStartOffset + 4;
	                return;
	            }

	            // Otherwise, consume a url token, and return it.
	            consumeUrlToken();
	            return;
	        }

	        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
	        // Create a <function-token> with its value set to string and return it.
	        if (getCharCode(offset) === 0x0028) {
	            type = TYPE$2.Function;
	            offset++;
	            return;
	        }

	        // Otherwise, create an <ident-token> with its value set to string and return it.
	        type = TYPE$2.Ident;
	    }

	    // § 4.3.5. Consume a string token
	    function consumeStringToken(endingCodePoint) {
	        // This algorithm may be called with an ending code point, which denotes the code point
	        // that ends the string. If an ending code point is not specified,
	        // the current input code point is used.
	        if (!endingCodePoint) {
	            endingCodePoint = getCharCode(offset++);
	        }

	        // Initially create a <string-token> with its value set to the empty string.
	        type = TYPE$2.String;

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // ending code point
	                case endingCodePoint:
	                    // Return the <string-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <string-token>.
	                    return;

	                // newline
	                case charCodeCategory$1.WhiteSpace:
	                    if (isNewline$1(code)) {
	                        // This is a parse error. Reconsume the current input code point,
	                        // create a <bad-string-token>, and return it.
	                        offset += getNewlineLength$1(source, offset, code);
	                        type = TYPE$2.BadString;
	                        return;
	                    }
	                    break;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the next input code point is EOF, do nothing.
	                    if (offset === source.length - 1) {
	                        break;
	                    }

	                    var nextCode = getCharCode(offset + 1);

	                    // Otherwise, if the next input code point is a newline, consume it.
	                    if (isNewline$1(nextCode)) {
	                        offset += getNewlineLength$1(source, offset + 1, nextCode);
	                    } else if (isValidEscape$2(code, nextCode)) {
	                        // Otherwise, (the stream starts with a valid escape) consume
	                        // an escaped code point and append the returned code point to
	                        // the <string-token>’s value.
	                        offset = consumeEscaped$1(source, offset) - 1;
	                    }
	                    break;

	                // anything else
	                // Append the current input code point to the <string-token>’s value.
	            }
	        }
	    }

	    // § 4.3.6. Consume a url token
	    // Note: This algorithm assumes that the initial "url(" has already been consumed.
	    // This algorithm also assumes that it’s being called to consume an "unquoted" value, like url(foo).
	    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
	    // automatically handles this distinction; this algorithm shouldn’t be called directly otherwise.
	    function consumeUrlToken() {
	        // Initially create a <url-token> with its value set to the empty string.
	        type = TYPE$2.Url;

	        // Consume as much whitespace as possible.
	        offset = findWhiteSpaceEnd$1(source, offset);

	        // Repeatedly consume the next input code point from the stream:
	        for (; offset < source.length; offset++) {
	            var code = source.charCodeAt(offset);

	            switch (charCodeCategory$1(code)) {
	                // U+0029 RIGHT PARENTHESIS ())
	                case 0x0029:
	                    // Return the <url-token>.
	                    offset++;
	                    return;

	                // EOF
	                case charCodeCategory$1.Eof:
	                    // This is a parse error. Return the <url-token>.
	                    return;

	                // whitespace
	                case charCodeCategory$1.WhiteSpace:
	                    // Consume as much whitespace as possible.
	                    offset = findWhiteSpaceEnd$1(source, offset);

	                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
	                    // consume it and return the <url-token>
	                    // (if EOF was encountered, this is a parse error);
	                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
	                        if (offset < source.length) {
	                            offset++;
	                        }
	                        return;
	                    }

	                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
	                    // and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+0022 QUOTATION MARK (")
	                // U+0027 APOSTROPHE (')
	                // U+0028 LEFT PARENTHESIS (()
	                // non-printable code point
	                case 0x0022:
	                case 0x0027:
	                case 0x0028:
	                case charCodeCategory$1.NonPrintable:
	                    // This is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // U+005C REVERSE SOLIDUS (\)
	                case 0x005C:
	                    // If the stream starts with a valid escape, consume an escaped code point and
	                    // append the returned code point to the <url-token>’s value.
	                    if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                        offset = consumeEscaped$1(source, offset) - 1;
	                        break;
	                    }

	                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
	                    // create a <bad-url-token>, and return it.
	                    offset = consumeBadUrlRemnants$1(source, offset);
	                    type = TYPE$2.BadUrl;
	                    return;

	                // anything else
	                // Append the current input code point to the <url-token>’s value.
	            }
	        }
	    }

	    if (!stream) {
	        stream = new TokenStream_1();
	    }

	    // ensure source is a string
	    source = String(source || '');

	    var sourceLength = source.length;
	    var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1); // +1 because of eof-token
	    var balance = adoptBuffer(stream.balance, sourceLength + 1);
	    var tokenCount = 0;
	    var start = isBOM$1(getCharCode(0));
	    var offset = start;
	    var balanceCloseType = 0;
	    var balanceStart = 0;
	    var balancePrev = 0;

	    // https://drafts.csswg.org/css-syntax-3/#consume-token
	    // § 4.3.1. Consume a token
	    while (offset < sourceLength) {
	        var code = source.charCodeAt(offset);
	        var type = 0;

	        balance[tokenCount] = sourceLength;

	        switch (charCodeCategory$1(code)) {
	            // whitespace
	            case charCodeCategory$1.WhiteSpace:
	                // Consume as much whitespace as possible. Return a <whitespace-token>.
	                type = TYPE$2.WhiteSpace;
	                offset = findWhiteSpaceEnd$1(source, offset + 1);
	                break;

	            // U+0022 QUOTATION MARK (")
	            case 0x0022:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0023 NUMBER SIGN (#)
	            case 0x0023:
	                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
	                if (isName$2(getCharCode(offset + 1)) || isValidEscape$2(getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // Create a <hash-token>.
	                    type = TYPE$2.Hash;

	                    // If the next 3 input code points would start an identifier, set the <hash-token>’s type flag to "id".
	                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    //     // TODO: set id flag
	                    // }

	                    // Consume a name, and set the <hash-token>’s value to the returned string.
	                    offset = consumeName$1(source, offset + 1);

	                    // Return the <hash-token>.
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0027 APOSTROPHE (')
	            case 0x0027:
	                // Consume a string token and return it.
	                consumeStringToken();
	                break;

	            // U+0028 LEFT PARENTHESIS (()
	            case 0x0028:
	                // Return a <(-token>.
	                type = TYPE$2.LeftParenthesis;
	                offset++;
	                break;

	            // U+0029 RIGHT PARENTHESIS ())
	            case 0x0029:
	                // Return a <)-token>.
	                type = TYPE$2.RightParenthesis;
	                offset++;
	                break;

	            // U+002B PLUS SIGN (+)
	            case 0x002B:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+002C COMMA (,)
	            case 0x002C:
	                // Return a <comma-token>.
	                type = TYPE$2.Comma;
	                offset++;
	                break;

	            // U+002D HYPHEN-MINUS (-)
	            case 0x002D:
	                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
	                    if (getCharCode(offset + 1) === 0x002D &&
	                        getCharCode(offset + 2) === 0x003E) {
	                        type = TYPE$2.CDC;
	                        offset = offset + 3;
	                    } else {
	                        // Otherwise, if the input stream starts with an identifier, ...
	                        if (isIdentifierStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                            // ... reconsume the current input code point, consume an ident-like token, and return it.
	                            consumeIdentLikeToken();
	                        } else {
	                            // Otherwise, return a <delim-token> with its value set to the current input code point.
	                            type = TYPE$2.Delim;
	                            offset++;
	                        }
	                    }
	                }
	                break;

	            // U+002E FULL STOP (.)
	            case 0x002E:
	                // If the input stream starts with a number, ...
	                if (isNumberStart$1(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
	                    // ... reconsume the current input code point, consume a numeric token, and return it.
	                    consumeNumericToken();
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+002F SOLIDUS (/)
	            case 0x002F:
	                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
	                if (getCharCode(offset + 1) === 0x002A) {
	                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
	                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
	                    type = TYPE$2.Comment;
	                    offset = source.indexOf('*/', offset + 2) + 2;
	                    if (offset === 1) {
	                        offset = source.length;
	                    }
	                } else {
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+003A COLON (:)
	            case 0x003A:
	                // Return a <colon-token>.
	                type = TYPE$2.Colon;
	                offset++;
	                break;

	            // U+003B SEMICOLON (;)
	            case 0x003B:
	                // Return a <semicolon-token>.
	                type = TYPE$2.Semicolon;
	                offset++;
	                break;

	            // U+003C LESS-THAN SIGN (<)
	            case 0x003C:
	                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
	                if (getCharCode(offset + 1) === 0x0021 &&
	                    getCharCode(offset + 2) === 0x002D &&
	                    getCharCode(offset + 3) === 0x002D) {
	                    // ... consume them and return a <CDO-token>.
	                    type = TYPE$2.CDO;
	                    offset = offset + 4;
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+0040 COMMERCIAL AT (@)
	            case 0x0040:
	                // If the next 3 input code points would start an identifier, ...
	                if (isIdentifierStart$1(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
	                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
	                    type = TYPE$2.AtKeyword;
	                    offset = consumeName$1(source, offset + 1);
	                } else {
	                    // Otherwise, return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }

	                break;

	            // U+005B LEFT SQUARE BRACKET ([)
	            case 0x005B:
	                // Return a <[-token>.
	                type = TYPE$2.LeftSquareBracket;
	                offset++;
	                break;

	            // U+005C REVERSE SOLIDUS (\)
	            case 0x005C:
	                // If the input stream starts with a valid escape, ...
	                if (isValidEscape$2(code, getCharCode(offset + 1))) {
	                    // ... reconsume the current input code point, consume an ident-like token, and return it.
	                    consumeIdentLikeToken();
	                } else {
	                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
	                    type = TYPE$2.Delim;
	                    offset++;
	                }
	                break;

	            // U+005D RIGHT SQUARE BRACKET (])
	            case 0x005D:
	                // Return a <]-token>.
	                type = TYPE$2.RightSquareBracket;
	                offset++;
	                break;

	            // U+007B LEFT CURLY BRACKET ({)
	            case 0x007B:
	                // Return a <{-token>.
	                type = TYPE$2.LeftCurlyBracket;
	                offset++;
	                break;

	            // U+007D RIGHT CURLY BRACKET (})
	            case 0x007D:
	                // Return a <}-token>.
	                type = TYPE$2.RightCurlyBracket;
	                offset++;
	                break;

	            // digit
	            case charCodeCategory$1.Digit:
	                // Reconsume the current input code point, consume a numeric token, and return it.
	                consumeNumericToken();
	                break;

	            // name-start code point
	            case charCodeCategory$1.NameStart:
	                // Reconsume the current input code point, consume an ident-like token, and return it.
	                consumeIdentLikeToken();
	                break;

	            // EOF
	            case charCodeCategory$1.Eof:
	                // Return an <EOF-token>.
	                break;

	            // anything else
	            default:
	                // Return a <delim-token> with its value set to the current input code point.
	                type = TYPE$2.Delim;
	                offset++;
	        }

	        switch (type) {
	            case balanceCloseType:
	                balancePrev = balanceStart & OFFSET_MASK$1;
	                balanceStart = balance[balancePrev];
	                balanceCloseType = balanceStart >> TYPE_SHIFT$1;
	                balance[tokenCount] = balancePrev;
	                balance[balancePrev++] = tokenCount;
	                for (; balancePrev < tokenCount; balancePrev++) {
	                    if (balance[balancePrev] === sourceLength) {
	                        balance[balancePrev] = tokenCount;
	                    }
	                }
	                break;

	            case TYPE$2.LeftParenthesis:
	            case TYPE$2.Function:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightParenthesis;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftSquareBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightSquareBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;

	            case TYPE$2.LeftCurlyBracket:
	                balance[tokenCount] = balanceStart;
	                balanceCloseType = TYPE$2.RightCurlyBracket;
	                balanceStart = (balanceCloseType << TYPE_SHIFT$1) | tokenCount;
	                break;
	        }

	        offsetAndType[tokenCount++] = (type << TYPE_SHIFT$1) | offset;
	    }

	    // finalize buffers
	    offsetAndType[tokenCount] = (TYPE$2.EOF << TYPE_SHIFT$1) | offset; // <EOF-token>
	    balance[tokenCount] = sourceLength;
	    balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
	    while (balanceStart !== 0) {
	        balancePrev = balanceStart & OFFSET_MASK$1;
	        balanceStart = balance[balancePrev];
	        balance[balancePrev] = sourceLength;
	    }

	    // update stream
	    stream.source = source;
	    stream.firstCharOffset = start;
	    stream.offsetAndType = offsetAndType;
	    stream.tokenCount = tokenCount;
	    stream.balance = balance;
	    stream.reset();
	    stream.next();

	    return stream;
	}

	// extend tokenizer with constants
	Object.keys(_const).forEach(function(key) {
	    tokenize[key] = _const[key];
	});

	// extend tokenizer with static methods from utils
	Object.keys(charCodeDefinitions).forEach(function(key) {
	    tokenize[key] = charCodeDefinitions[key];
	});
	Object.keys(utils).forEach(function(key) {
	    tokenize[key] = utils[key];
	});

	var tokenizer = tokenize;

	var isDigit$2 = tokenizer.isDigit;
	var cmpChar$1 = tokenizer.cmpChar;
	var TYPE$3 = tokenizer.TYPE;

	var DELIM = TYPE$3.Delim;
	var WHITESPACE$1 = TYPE$3.WhiteSpace;
	var COMMENT$1 = TYPE$3.Comment;
	var IDENT = TYPE$3.Ident;
	var NUMBER = TYPE$3.Number;
	var DIMENSION = TYPE$3.Dimension;
	var PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$1 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN = true;
	var ALLOW_SIGN = false;

	function isDelim(token, code) {
	    return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
	}

	function skipSC(token, offset, getNextToken) {
	    while (token !== null && (token.type === WHITESPACE$1 || token.type === COMMENT$1)) {
	        token = getNextToken(++offset);
	    }

	    return offset;
	}

	function checkInteger(token, valueOffset, disallowSign, offset) {
	    if (!token) {
	        return 0;
	    }

	    var code = token.value.charCodeAt(valueOffset);

	    if (code === PLUSSIGN || code === HYPHENMINUS$1) {
	        if (disallowSign) {
	            // Number sign is not allowed
	            return 0;
	        }
	        valueOffset++;
	    }

	    for (; valueOffset < token.value.length; valueOffset++) {
	        if (!isDigit$2(token.value.charCodeAt(valueOffset))) {
	            // Integer is expected
	            return 0;
	        }
	    }

	    return offset + 1;
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB(token, offset_, getNextToken) {
	    var sign = false;
	    var offset = skipSC(token, offset_, getNextToken);

	    token = getNextToken(offset);

	    if (token === null) {
	        return offset_;
	    }

	    if (token.type !== NUMBER) {
	        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS$1)) {
	            sign = true;
	            offset = skipSC(getNextToken(++offset), offset, getNextToken);
	            token = getNextToken(offset);

	            if (token === null && token.type !== NUMBER) {
	                return 0;
	            }
	        } else {
	            return offset_;
	        }
	    }

	    if (!sign) {
	        var code = token.value.charCodeAt(0);
	        if (code !== PLUSSIGN && code !== HYPHENMINUS$1) {
	            // Number sign is expected
	            return 0;
	        }
	    }

	    return checkInteger(token, sign ? 0 : 1, sign, offset);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var genericAnPlusB = function anPlusB(token, getNextToken) {
	    /* eslint-disable brace-style*/
	    var offset = 0;

	    if (!token) {
	        return 0;
	    }

	    // <integer>
	    if (token.type === NUMBER) {
	        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
	    }

	    // -n
	    // -n <signed-integer>
	    // -n ['+' | '-'] <signless-integer>
	    // -n- <signless-integer>
	    // <dashndashdigit-ident>
	    else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS$1) {
	        // expect 1st char is N
	        if (!cmpChar$1(token.value, 1, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // -n
	            // -n <signed-integer>
	            // -n ['+' | '-'] <signless-integer>
	            case 2:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // -n- <signless-integer>
	            case 3:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // <dashndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(2) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 3, DISALLOW_SIGN, offset);
	        }
	    }

	    // '+'? n
	    // '+'? n <signed-integer>
	    // '+'? n ['+' | '-'] <signless-integer>
	    // '+'? n- <signless-integer>
	    // '+'? <ndashdigit-ident>
	    else if (token.type === IDENT || (isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT)) {
	        // just ignore a plus
	        if (token.type !== IDENT) {
	            token = getNextToken(++offset);
	        }

	        if (token === null || !cmpChar$1(token.value, 0, N)) {
	            return 0;
	        }

	        switch (token.value.length) {
	            // '+'? n
	            // '+'? n <signed-integer>
	            // '+'? n ['+' | '-'] <signless-integer>
	            case 1:
	                return consumeB(getNextToken(++offset), offset, getNextToken);

	            // '+'? n- <signless-integer>
	            case 2:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);

	            // '+'? <ndashdigit-ident>
	            default:
	                if (token.value.charCodeAt(1) !== HYPHENMINUS$1) {
	                    return 0;
	                }

	                return checkInteger(token, 2, DISALLOW_SIGN, offset);
	        }
	    }

	    // <ndashdigit-dimension>
	    // <ndash-dimension> <signless-integer>
	    // <n-dimension>
	    // <n-dimension> <signed-integer>
	    // <n-dimension> ['+' | '-'] <signless-integer>
	    else if (token.type === DIMENSION) {
	        var code = token.value.charCodeAt(0);
	        var sign = code === PLUSSIGN || code === HYPHENMINUS$1 ? 1 : 0;

	        for (var i = sign; i < token.value.length; i++) {
	            if (!isDigit$2(token.value.charCodeAt(i))) {
	                break;
	            }
	        }

	        if (i === sign) {
	            // Integer is expected
	            return 0;
	        }

	        if (!cmpChar$1(token.value, i, N)) {
	            return 0;
	        }

	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        if (i + 1 === token.value.length) {
	            return consumeB(getNextToken(++offset), offset, getNextToken);
	        } else {
	            if (token.value.charCodeAt(i + 1) !== HYPHENMINUS$1) {
	                return 0;
	            }

	            // <ndash-dimension> <signless-integer>
	            if (i + 2 === token.value.length) {
	                offset = skipSC(getNextToken(++offset), offset, getNextToken);
	                token = getNextToken(offset);

	                return checkInteger(token, 0, DISALLOW_SIGN, offset);
	            }
	            // <ndashdigit-dimension>
	            else {
	                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
	            }
	        }
	    }

	    return 0;
	};

	var isHexDigit$2 = tokenizer.isHexDigit;
	var cmpChar$2 = tokenizer.cmpChar;
	var TYPE$4 = tokenizer.TYPE;

	var IDENT$1 = TYPE$4.Ident;
	var DELIM$1 = TYPE$4.Delim;
	var NUMBER$1 = TYPE$4.Number;
	var DIMENSION$1 = TYPE$4.Dimension;
	var PLUSSIGN$1 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$2 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
	var U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function isDelim$1(token, code) {
	    return token !== null && token.type === DELIM$1 && token.value.charCodeAt(0) === code;
	}

	function startsWith(token, code) {
	    return token.value.charCodeAt(0) === code;
	}

	function hexSequence(token, offset, allowDash) {
	    for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
	        var code = token.value.charCodeAt(pos);

	        if (code === HYPHENMINUS$2 && allowDash && hexlen !== 0) {
	            if (hexSequence(token, offset + hexlen + 1, false) > 0) {
	                return 6; // dissallow following question marks
	            }

	            return 0; // dash at the ending of a hex sequence is not allowed
	        }

	        if (!isHexDigit$2(code)) {
	            return 0; // not a hex digit
	        }

	        if (++hexlen > 6) {
	            return 0; // too many hex digits
	        }    }

	    return hexlen;
	}

	function withQuestionMarkSequence(consumed, length, getNextToken) {
	    if (!consumed) {
	        return 0; // nothing consumed
	    }

	    while (isDelim$1(getNextToken(length), QUESTIONMARK)) {
	        if (++consumed > 6) {
	            return 0; // too many question marks
	        }

	        length++;
	    }

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	var genericUrange = function urange(token, getNextToken) {
	    var length = 0;

	    // should start with `u` or `U`
	    if (token === null || token.type !== IDENT$1 || !cmpChar$2(token.value, 0, U)) {
	        return 0;
	    }

	    token = getNextToken(++length);
	    if (token === null) {
	        return 0;
	    }

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (isDelim$1(token, PLUSSIGN$1)) {
	        token = getNextToken(++length);
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === IDENT$1) {
	            // u '+' <ident-token> '?'*
	            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
	        }

	        if (isDelim$1(token, QUESTIONMARK)) {
	            // u '+' '?'+
	            return withQuestionMarkSequence(1, ++length, getNextToken);
	        }

	        // Hex digit or question mark is expected
	        return 0;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (token.type === NUMBER$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        var consumedHexLength = hexSequence(token, 1, true);
	        if (consumedHexLength === 0) {
	            return 0;
	        }

	        token = getNextToken(++length);
	        if (token === null) {
	            // u <number-token> <eof>
	            return length;
	        }

	        if (token.type === DIMENSION$1 || token.type === NUMBER$1) {
	            // u <number-token> <dimension-token>
	            // u <number-token> <number-token>
	            if (!startsWith(token, HYPHENMINUS$2) || !hexSequence(token, 1, false)) {
	                return 0;
	            }

	            return length + 1;
	        }

	        // u <number-token> '?'*
	        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
	    }

	    // u <dimension-token> '?'*
	    if (token.type === DIMENSION$1) {
	        if (!startsWith(token, PLUSSIGN$1)) {
	            return 0;
	        }

	        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
	    }

	    return 0;
	};

	var isIdentifierStart$2 = tokenizer.isIdentifierStart;
	var isHexDigit$3 = tokenizer.isHexDigit;
	var isDigit$3 = tokenizer.isDigit;
	var cmpStr$3 = tokenizer.cmpStr;
	var consumeNumber$2 = tokenizer.consumeNumber;
	var TYPE$5 = tokenizer.TYPE;



	var cssWideKeywords = ['unset', 'initial', 'inherit'];
	var calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];

	// https://www.w3.org/TR/css-values-3/#lengths
	var LENGTH = {
	    // absolute length units
	    'px': true,
	    'mm': true,
	    'cm': true,
	    'in': true,
	    'pt': true,
	    'pc': true,
	    'q': true,

	    // relative length units
	    'em': true,
	    'ex': true,
	    'ch': true,
	    'rem': true,

	    // viewport-percentage lengths
	    'vh': true,
	    'vw': true,
	    'vmin': true,
	    'vmax': true,
	    'vm': true
	};

	var ANGLE = {
	    'deg': true,
	    'grad': true,
	    'rad': true,
	    'turn': true
	};

	var TIME = {
	    's': true,
	    'ms': true
	};

	var FREQUENCY = {
	    'hz': true,
	    'khz': true
	};

	// https://www.w3.org/TR/css-values-3/#resolution (https://drafts.csswg.org/css-values/#resolution)
	var RESOLUTION = {
	    'dpi': true,
	    'dpcm': true,
	    'dppx': true,
	    'x': true      // https://github.com/w3c/csswg-drafts/issues/461
	};

	// https://drafts.csswg.org/css-grid/#fr-unit
	var FLEX = {
	    'fr': true
	};

	// https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
	var DECIBEL = {
	    'db': true
	};

	// https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch
	var SEMITONES = {
	    'st': true
	};

	// safe char code getter
	function charCode(str, index) {
	    return index < str.length ? str.charCodeAt(index) : 0;
	}

	function eqStr(actual, expected) {
	    return cmpStr$3(actual, 0, actual.length, expected);
	}

	function eqStrAny(actual, expected) {
	    for (var i = 0; i < expected.length; i++) {
	        if (eqStr(actual, expected[i])) {
	            return true;
	        }
	    }

	    return false;
	}

	// IE postfix hack, i.e. 123\0 or 123px\9
	function isPostfixIeHack(str, offset) {
	    if (offset !== str.length - 2) {
	        return false;
	    }

	    return (
	        str.charCodeAt(offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
	        isDigit$3(str.charCodeAt(offset + 1))
	    );
	}

	function outOfRange(opts, value, numEnd) {
	    if (opts && opts.type === 'Range') {
	        var num = Number(
	            numEnd !== undefined && numEnd !== value.length
	                ? value.substr(0, numEnd)
	                : value
	        );

	        if (isNaN(num)) {
	            return true;
	        }

	        if (opts.min !== null && num < opts.min) {
	            return true;
	        }

	        if (opts.max !== null && num > opts.max) {
	            return true;
	        }
	    }

	    return false;
	}

	function consumeFunction(token, getNextToken) {
	    var startIdx = token.index;
	    var length = 0;

	    // balanced token consuming
	    do {
	        length++;

	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// TODO: implement
	// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
	// https://drafts.csswg.org/css-values/#calc-notation
	function calc(next) {
	    return function(token, getNextToken, opts) {
	        if (token === null) {
	            return 0;
	        }

	        if (token.type === TYPE$5.Function && eqStrAny(token.value, calcFunctionNames)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	function tokenType(expectedTokenType) {
	    return function(token) {
	        if (token === null || token.type !== expectedTokenType) {
	            return 0;
	        }

	        return 1;
	    };
	}

	function func(name) {
	    name = name + '(';

	    return function(token, getNextToken) {
	        if (token !== null && eqStr(token.value, name)) {
	            return consumeFunction(token, getNextToken);
	        }

	        return 0;
	    };
	}

	// =========================
	// Complex types
	//

	// https://drafts.csswg.org/css-values-4/#custom-idents
	// 4.2. Author-defined Identifiers: the <custom-ident> type
	// Some properties accept arbitrary author-defined identifiers as a component value.
	// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
	// that would not be misinterpreted as a pre-defined keyword in that property’s value definition.
	//
	// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
	function customIdent(token) {
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    var name = token.value.toLowerCase();

	    // The CSS-wide keywords are not valid <custom-ident>s
	    if (eqStrAny(name, cssWideKeywords)) {
	        return 0;
	    }

	    // The default keyword is reserved and is also not a valid <custom-ident>
	    if (eqStr(name, 'default')) {
	        return 0;
	    }

	    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
	    // Specifications using <custom-ident> must specify clearly what other keywords
	    // are excluded from <custom-ident>, if any—for example by saying that any pre-defined keywords
	    // in that property’s value definition are excluded. Excluded keywords are excluded
	    // in all ASCII case permutations.

	    return 1;
	}

	// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
	// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
	// The <custom-property-name> production corresponds to this: it’s defined as any valid identifier
	// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
	// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
	function customPropertyName(token) {
	    // ... defined as any valid identifier
	    if (token === null || token.type !== TYPE$5.Ident) {
	        return 0;
	    }

	    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
	    if (charCode(token.value, 0) !== 0x002D || charCode(token.value, 1) !== 0x002D) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-color-4/#hex-notation
	// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
	// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
	// letters a-f (the case of the letters doesn’t matter - #00ff00 is identical to #00FF00).
	function hexColor(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    var length = token.value.length;

	    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
	    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
	        return 0;
	    }

	    for (var i = 1; i < length; i++) {
	        if (!isHexDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    return 1;
	}

	function idSelector(token) {
	    if (token === null || token.type !== TYPE$5.Hash) {
	        return 0;
	    }

	    if (!isIdentifierStart$2(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
	        return 0;
	    }

	    return 1;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// It represents the entirety of what a valid declaration can have as its value.
	function declarationValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var length = 0;
	    var level = 0;
	    var startIdx = token.index;

	    // The <declaration-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                level--;
	                break;

	            // ... or top-level <semicolon-token> tokens
	            case TYPE$5.Semicolon:
	                if (level === 0) {
	                    break scan;
	                }

	                break;

	            // ... or <delim-token> tokens with a value of "!"
	            case TYPE$5.Delim:
	                if (token.value === '!' && level === 0) {
	                    break scan;
	                }

	                break;

	            case TYPE$5.Function:
	            case TYPE$5.LeftParenthesis:
	            case TYPE$5.LeftSquareBracket:
	            case TYPE$5.LeftCurlyBracket:
	                level++;
	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// https://drafts.csswg.org/css-syntax/#any-value
	// The <any-value> production is identical to <declaration-value>, but also
	// allows top-level <semicolon-token> tokens and <delim-token> tokens
	// with a value of "!". It represents the entirety of what valid CSS can be in any context.
	function anyValue(token, getNextToken) {
	    if (!token) {
	        return 0;
	    }

	    var startIdx = token.index;
	    var length = 0;

	    // The <any-value> production matches any sequence of one or more tokens,
	    // so long as the sequence ...
	    scan:
	    do {
	        switch (token.type) {
	            // ... does not contain <bad-string-token>, <bad-url-token>,
	            case TYPE$5.BadString:
	            case TYPE$5.BadUrl:
	                break scan;

	            // ... unmatched <)-token>, <]-token>, or <}-token>,
	            case TYPE$5.RightCurlyBracket:
	            case TYPE$5.RightParenthesis:
	            case TYPE$5.RightSquareBracket:
	                if (token.balance > token.index || token.balance < startIdx) {
	                    break scan;
	                }

	                break;
	        }

	        length++;

	        // until balance closing
	        if (token.balance <= startIdx) {
	            break;
	        }
	    } while (token = getNextToken(length));

	    return length;
	}

	// =========================
	// Dimensions
	//

	function dimension(type) {
	    return function(token, getNextToken, opts) {
	        if (token === null || token.type !== TYPE$5.Dimension) {
	            return 0;
	        }

	        var numberEnd = consumeNumber$2(token.value, 0);

	        // check unit
	        if (type !== null) {
	            // check for IE postfix hack, i.e. 123px\0 or 123px\9
	            var reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
	            var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
	                ? token.value.substr(numberEnd)
	                : token.value.substring(numberEnd, reverseSolidusOffset);

	            if (type.hasOwnProperty(unit.toLowerCase()) === false) {
	                return 0;
	            }
	        }

	        // check range if specified
	        if (outOfRange(opts, token.value, numberEnd)) {
	            return 0;
	        }

	        return 1;
	    };
	}

	// =========================
	// Percentage
	//

	// §5.5. Percentages: the <percentage> type
	// https://drafts.csswg.org/css-values-4/#percentages
	function percentage(token, getNextToken, opts) {
	    // ... corresponds to the <percentage-token> production
	    if (token === null || token.type !== TYPE$5.Percentage) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, token.value.length - 1)) {
	        return 0;
	    }

	    return 1;
	}

	// =========================
	// Numeric
	//

	// https://drafts.csswg.org/css-values-4/#numbers
	// The value <zero> represents a literal number with the value 0. Expressions that merely
	// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
	// only literal <number-token>s do.
	function zero(next) {
	    if (typeof next !== 'function') {
	        next = function() {
	            return 0;
	        };
	    }

	    return function(token, getNextToken, opts) {
	        if (token !== null && token.type === TYPE$5.Number) {
	            if (Number(token.value) === 0) {
	                return 1;
	            }
	        }

	        return next(token, getNextToken, opts);
	    };
	}

	// § 5.3. Real Numbers: the <number> type
	// https://drafts.csswg.org/css-values-4/#numbers
	// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
	// ... It corresponds to the <number-token> production
	function number(token, getNextToken, opts) {
	    if (token === null) {
	        return 0;
	    }

	    var numberEnd = consumeNumber$2(token.value, 0);
	    var isNumber = numberEnd === token.value.length;
	    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
	        return 0;
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, numberEnd)) {
	        return 0;
	    }

	    return 1;
	}

	// §5.2. Integers: the <integer> type
	// https://drafts.csswg.org/css-values-4/#integers
	function integer(token, getNextToken, opts) {
	    // ... corresponds to a subset of the <number-token> production
	    if (token === null || token.type !== TYPE$5.Number) {
	        return 0;
	    }

	    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integer’s sign.
	    var i = token.value.charCodeAt(0) === 0x002B ||       // U+002B PLUS SIGN (+)
	            token.value.charCodeAt(0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

	    // When written literally, an integer is one or more decimal digits 0 through 9 ...
	    for (; i < token.value.length; i++) {
	        if (!isDigit$3(token.value.charCodeAt(i))) {
	            return 0;
	        }
	    }

	    // check range if specified
	    if (outOfRange(opts, token.value, i)) {
	        return 0;
	    }

	    return 1;
	}

	var generic = {
	    // token types
	    'ident-token': tokenType(TYPE$5.Ident),
	    'function-token': tokenType(TYPE$5.Function),
	    'at-keyword-token': tokenType(TYPE$5.AtKeyword),
	    'hash-token': tokenType(TYPE$5.Hash),
	    'string-token': tokenType(TYPE$5.String),
	    'bad-string-token': tokenType(TYPE$5.BadString),
	    'url-token': tokenType(TYPE$5.Url),
	    'bad-url-token': tokenType(TYPE$5.BadUrl),
	    'delim-token': tokenType(TYPE$5.Delim),
	    'number-token': tokenType(TYPE$5.Number),
	    'percentage-token': tokenType(TYPE$5.Percentage),
	    'dimension-token': tokenType(TYPE$5.Dimension),
	    'whitespace-token': tokenType(TYPE$5.WhiteSpace),
	    'CDO-token': tokenType(TYPE$5.CDO),
	    'CDC-token': tokenType(TYPE$5.CDC),
	    'colon-token': tokenType(TYPE$5.Colon),
	    'semicolon-token': tokenType(TYPE$5.Semicolon),
	    'comma-token': tokenType(TYPE$5.Comma),
	    '[-token': tokenType(TYPE$5.LeftSquareBracket),
	    ']-token': tokenType(TYPE$5.RightSquareBracket),
	    '(-token': tokenType(TYPE$5.LeftParenthesis),
	    ')-token': tokenType(TYPE$5.RightParenthesis),
	    '{-token': tokenType(TYPE$5.LeftCurlyBracket),
	    '}-token': tokenType(TYPE$5.RightCurlyBracket),

	    // token type aliases
	    'string': tokenType(TYPE$5.String),
	    'ident': tokenType(TYPE$5.Ident),

	    // complex types
	    'custom-ident': customIdent,
	    'custom-property-name': customPropertyName,
	    'hex-color': hexColor,
	    'id-selector': idSelector, // element( <id-selector> )
	    'an-plus-b': genericAnPlusB,
	    'urange': genericUrange,
	    'declaration-value': declarationValue,
	    'any-value': anyValue,

	    // dimensions
	    'dimension': calc(dimension(null)),
	    'angle': calc(dimension(ANGLE)),
	    'decibel': calc(dimension(DECIBEL)),
	    'frequency': calc(dimension(FREQUENCY)),
	    'flex': calc(dimension(FLEX)),
	    'length': calc(zero(dimension(LENGTH))),
	    'resolution': calc(dimension(RESOLUTION)),
	    'semitones': calc(dimension(SEMITONES)),
	    'time': calc(dimension(TIME)),

	    // percentage
	    'percentage': calc(percentage),

	    // numeric
	    'zero': zero(),
	    'number': calc(number),
	    'integer': calc(integer),

	    // old IE stuff
	    '-ms-legacy-expression': func('expression')
	};

	var _SyntaxError$1 = function SyntaxError(message, input, offset) {
	    var error = createCustomError('SyntaxError', message);

	    error.input = input;
	    error.offset = offset;
	    error.rawMessage = message;
	    error.message = error.rawMessage + '\n' +
	        '  ' + error.input + '\n' +
	        '--' + new Array((error.offset || error.input.length) + 1).join('-') + '^';

	    return error;
	};

	var TAB = 9;
	var N$1 = 10;
	var F = 12;
	var R = 13;
	var SPACE = 32;

	var Tokenizer = function(str) {
	    this.str = str;
	    this.pos = 0;
	};

	Tokenizer.prototype = {
	    charCodeAt: function(pos) {
	        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
	    },
	    charCode: function() {
	        return this.charCodeAt(this.pos);
	    },
	    nextCharCode: function() {
	        return this.charCodeAt(this.pos + 1);
	    },
	    nextNonWsCode: function(pos) {
	        return this.charCodeAt(this.findWsEnd(pos));
	    },
	    findWsEnd: function(pos) {
	        for (; pos < this.str.length; pos++) {
	            var code = this.str.charCodeAt(pos);
	            if (code !== R && code !== N$1 && code !== F && code !== SPACE && code !== TAB) {
	                break;
	            }
	        }

	        return pos;
	    },
	    substringToPos: function(end) {
	        return this.str.substring(this.pos, this.pos = end);
	    },
	    eat: function(code) {
	        if (this.charCode() !== code) {
	            this.error('Expect `' + String.fromCharCode(code) + '`');
	        }

	        this.pos++;
	    },
	    peek: function() {
	        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
	    },
	    error: function(message) {
	        throw new _SyntaxError$1(message, this.str, this.pos);
	    }
	};

	var tokenizer$1 = Tokenizer;

	var TAB$1 = 9;
	var N$2 = 10;
	var F$1 = 12;
	var R$1 = 13;
	var SPACE$1 = 32;
	var EXCLAMATIONMARK = 33;    // !
	var NUMBERSIGN = 35;         // #
	var AMPERSAND = 38;          // &
	var APOSTROPHE = 39;         // '
	var LEFTPARENTHESIS = 40;    // (
	var RIGHTPARENTHESIS = 41;   // )
	var ASTERISK = 42;           // *
	var PLUSSIGN$2 = 43;           // +
	var COMMA = 44;              // ,
	var HYPERMINUS = 45;         // -
	var LESSTHANSIGN = 60;       // <
	var GREATERTHANSIGN = 62;    // >
	var QUESTIONMARK$1 = 63;       // ?
	var COMMERCIALAT = 64;       // @
	var LEFTSQUAREBRACKET = 91;  // [
	var RIGHTSQUAREBRACKET = 93; // ]
	var LEFTCURLYBRACKET = 123;  // {
	var VERTICALLINE = 124;      // |
	var RIGHTCURLYBRACKET = 125; // }
	var INFINITY = 8734;         // ∞
	var NAME_CHAR = createCharMap(function(ch) {
	    return /[a-zA-Z0-9\-]/.test(ch);
	});
	var COMBINATOR_PRECEDENCE = {
	    ' ': 1,
	    '&&': 2,
	    '||': 3,
	    '|': 4
	};

	function createCharMap(fn) {
	    var array = typeof Uint32Array === 'function' ? new Uint32Array(128) : new Array(128);
	    for (var i = 0; i < 128; i++) {
	        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
	    }
	    return array;
	}

	function scanSpaces(tokenizer) {
	    return tokenizer.substringToPos(
	        tokenizer.findWsEnd(tokenizer.pos)
	    );
	}

	function scanWord(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code >= 128 || NAME_CHAR[code] === 0) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a keyword');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanNumber(tokenizer) {
	    var end = tokenizer.pos;

	    for (; end < tokenizer.str.length; end++) {
	        var code = tokenizer.str.charCodeAt(end);
	        if (code < 48 || code > 57) {
	            break;
	        }
	    }

	    if (tokenizer.pos === end) {
	        tokenizer.error('Expect a number');
	    }

	    return tokenizer.substringToPos(end);
	}

	function scanString(tokenizer) {
	    var end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

	    if (end === -1) {
	        tokenizer.pos = tokenizer.str.length;
	        tokenizer.error('Expect an apostrophe');
	    }

	    return tokenizer.substringToPos(end + 1);
	}

	function readMultiplierRange(tokenizer) {
	    var min = null;
	    var max = null;

	    tokenizer.eat(LEFTCURLYBRACKET);

	    min = scanNumber(tokenizer);

	    if (tokenizer.charCode() === COMMA) {
	        tokenizer.pos++;
	        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
	            max = scanNumber(tokenizer);
	        }
	    } else {
	        max = min;
	    }

	    tokenizer.eat(RIGHTCURLYBRACKET);

	    return {
	        min: Number(min),
	        max: max ? Number(max) : 0
	    };
	}

	function readMultiplier(tokenizer) {
	    var range = null;
	    var comma = false;

	    switch (tokenizer.charCode()) {
	        case ASTERISK:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 0
	            };

	            break;

	        case PLUSSIGN$2:
	            tokenizer.pos++;

	            range = {
	                min: 1,
	                max: 0
	            };

	            break;

	        case QUESTIONMARK$1:
	            tokenizer.pos++;

	            range = {
	                min: 0,
	                max: 1
	            };

	            break;

	        case NUMBERSIGN:
	            tokenizer.pos++;

	            comma = true;

	            if (tokenizer.charCode() === LEFTCURLYBRACKET) {
	                range = readMultiplierRange(tokenizer);
	            } else {
	                range = {
	                    min: 1,
	                    max: 0
	                };
	            }

	            break;

	        case LEFTCURLYBRACKET:
	            range = readMultiplierRange(tokenizer);
	            break;

	        default:
	            return null;
	    }

	    return {
	        type: 'Multiplier',
	        comma: comma,
	        min: range.min,
	        max: range.max,
	        term: null
	    };
	}

	function maybeMultiplied(tokenizer, node) {
	    var multiplier = readMultiplier(tokenizer);

	    if (multiplier !== null) {
	        multiplier.term = node;
	        return multiplier;
	    }

	    return node;
	}

	function maybeToken(tokenizer) {
	    var ch = tokenizer.peek();

	    if (ch === '') {
	        return null;
	    }

	    return {
	        type: 'Token',
	        value: ch
	    };
	}

	function readProperty(tokenizer) {
	    var name;

	    tokenizer.eat(LESSTHANSIGN);
	    tokenizer.eat(APOSTROPHE);

	    name = scanWord(tokenizer);

	    tokenizer.eat(APOSTROPHE);
	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Property',
	        name: name
	    });
	}

	// https://drafts.csswg.org/css-values-3/#numeric-ranges
	// 4.1. Range Restrictions and Range Definition Notation
	//
	// Range restrictions can be annotated in the numeric type notation using CSS bracketed
	// range notation—[min,max]—within the angle brackets, after the identifying keyword,
	// indicating a closed range between (and including) min and max.
	// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
	function readTypeRange(tokenizer) {
	    // use null for Infinity to make AST format JSON serializable/deserializable
	    var min = null; // -Infinity
	    var max = null; // Infinity
	    var sign = 1;

	    tokenizer.eat(LEFTSQUAREBRACKET);

	    if (tokenizer.charCode() === HYPERMINUS) {
	        tokenizer.peek();
	        sign = -1;
	    }

	    if (sign == -1 && tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        min = sign * Number(scanNumber(tokenizer));
	    }

	    scanSpaces(tokenizer);
	    tokenizer.eat(COMMA);
	    scanSpaces(tokenizer);

	    if (tokenizer.charCode() === INFINITY) {
	        tokenizer.peek();
	    } else {
	        sign = 1;

	        if (tokenizer.charCode() === HYPERMINUS) {
	            tokenizer.peek();
	            sign = -1;
	        }

	        max = sign * Number(scanNumber(tokenizer));
	    }

	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    // If no range is indicated, either by using the bracketed range notation
	    // or in the property description, then [−∞,∞] is assumed.
	    if (min === null && max === null) {
	        return null;
	    }

	    return {
	        type: 'Range',
	        min: min,
	        max: max
	    };
	}

	function readType(tokenizer) {
	    var name;
	    var opts = null;

	    tokenizer.eat(LESSTHANSIGN);
	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS &&
	        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
	        tokenizer.pos += 2;
	        name += '()';
	    }

	    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
	        scanSpaces(tokenizer);
	        opts = readTypeRange(tokenizer);
	    }

	    tokenizer.eat(GREATERTHANSIGN);

	    return maybeMultiplied(tokenizer, {
	        type: 'Type',
	        name: name,
	        opts: opts
	    });
	}

	function readKeywordOrFunction(tokenizer) {
	    var name;

	    name = scanWord(tokenizer);

	    if (tokenizer.charCode() === LEFTPARENTHESIS) {
	        tokenizer.pos++;

	        return {
	            type: 'Function',
	            name: name
	        };
	    }

	    return maybeMultiplied(tokenizer, {
	        type: 'Keyword',
	        name: name
	    });
	}

	function regroupTerms(terms, combinators) {
	    function createGroup(terms, combinator) {
	        return {
	            type: 'Group',
	            terms: terms,
	            combinator: combinator,
	            disallowEmpty: false,
	            explicit: false
	        };
	    }

	    combinators = Object.keys(combinators).sort(function(a, b) {
	        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
	    });

	    while (combinators.length > 0) {
	        var combinator = combinators.shift();
	        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
	            var term = terms[i];
	            if (term.type === 'Combinator') {
	                if (term.value === combinator) {
	                    if (subgroupStart === -1) {
	                        subgroupStart = i - 1;
	                    }
	                    terms.splice(i, 1);
	                    i--;
	                } else {
	                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
	                        terms.splice(
	                            subgroupStart,
	                            i - subgroupStart,
	                            createGroup(terms.slice(subgroupStart, i), combinator)
	                        );
	                        i = subgroupStart + 1;
	                    }
	                    subgroupStart = -1;
	                }
	            }
	        }

	        if (subgroupStart !== -1 && combinators.length) {
	            terms.splice(
	                subgroupStart,
	                i - subgroupStart,
	                createGroup(terms.slice(subgroupStart, i), combinator)
	            );
	        }
	    }

	    return combinator;
	}

	function readImplicitGroup(tokenizer) {
	    var terms = [];
	    var combinators = {};
	    var token;
	    var prevToken = null;
	    var prevTokenPos = tokenizer.pos;

	    while (token = peek(tokenizer)) {
	        if (token.type !== 'Spaces') {
	            if (token.type === 'Combinator') {
	                // check for combinator in group beginning and double combinator sequence
	                if (prevToken === null || prevToken.type === 'Combinator') {
	                    tokenizer.pos = prevTokenPos;
	                    tokenizer.error('Unexpected combinator');
	                }

	                combinators[token.value] = true;
	            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
	                combinators[' '] = true;  // a b
	                terms.push({
	                    type: 'Combinator',
	                    value: ' '
	                });
	            }

	            terms.push(token);
	            prevToken = token;
	            prevTokenPos = tokenizer.pos;
	        }
	    }

	    // check for combinator in group ending
	    if (prevToken !== null && prevToken.type === 'Combinator') {
	        tokenizer.pos -= prevTokenPos;
	        tokenizer.error('Unexpected combinator');
	    }

	    return {
	        type: 'Group',
	        terms: terms,
	        combinator: regroupTerms(terms, combinators) || ' ',
	        disallowEmpty: false,
	        explicit: false
	    };
	}

	function readGroup(tokenizer) {
	    var result;

	    tokenizer.eat(LEFTSQUAREBRACKET);
	    result = readImplicitGroup(tokenizer);
	    tokenizer.eat(RIGHTSQUAREBRACKET);

	    result.explicit = true;

	    if (tokenizer.charCode() === EXCLAMATIONMARK) {
	        tokenizer.pos++;
	        result.disallowEmpty = true;
	    }

	    return result;
	}

	function peek(tokenizer) {
	    var code = tokenizer.charCode();

	    if (code < 128 && NAME_CHAR[code] === 1) {
	        return readKeywordOrFunction(tokenizer);
	    }

	    switch (code) {
	        case RIGHTSQUAREBRACKET:
	            // don't eat, stop scan a group
	            break;

	        case LEFTSQUAREBRACKET:
	            return maybeMultiplied(tokenizer, readGroup(tokenizer));

	        case LESSTHANSIGN:
	            return tokenizer.nextCharCode() === APOSTROPHE
	                ? readProperty(tokenizer)
	                : readType(tokenizer);

	        case VERTICALLINE:
	            return {
	                type: 'Combinator',
	                value: tokenizer.substringToPos(
	                    tokenizer.nextCharCode() === VERTICALLINE
	                        ? tokenizer.pos + 2
	                        : tokenizer.pos + 1
	                )
	            };

	        case AMPERSAND:
	            tokenizer.pos++;
	            tokenizer.eat(AMPERSAND);

	            return {
	                type: 'Combinator',
	                value: '&&'
	            };

	        case COMMA:
	            tokenizer.pos++;
	            return {
	                type: 'Comma'
	            };

	        case APOSTROPHE:
	            return maybeMultiplied(tokenizer, {
	                type: 'String',
	                value: scanString(tokenizer)
	            });

	        case SPACE$1:
	        case TAB$1:
	        case N$2:
	        case R$1:
	        case F$1:
	            return {
	                type: 'Spaces',
	                value: scanSpaces(tokenizer)
	            };

	        case COMMERCIALAT:
	            code = tokenizer.nextCharCode();

	            if (code < 128 && NAME_CHAR[code] === 1) {
	                tokenizer.pos++;
	                return {
	                    type: 'AtKeyword',
	                    name: scanWord(tokenizer)
	                };
	            }

	            return maybeToken(tokenizer);

	        case ASTERISK:
	        case PLUSSIGN$2:
	        case QUESTIONMARK$1:
	        case NUMBERSIGN:
	        case EXCLAMATIONMARK:
	            // prohibited tokens (used as a multiplier start)
	            break;

	        case LEFTCURLYBRACKET:
	            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
	            // check next char isn't a number, because it's likely a disjoined multiplier
	            code = tokenizer.nextCharCode();

	            if (code < 48 || code > 57) {
	                return maybeToken(tokenizer);
	            }

	            break;

	        default:
	            return maybeToken(tokenizer);
	    }
	}

	function parse(source) {
	    var tokenizer = new tokenizer$1(source);
	    var result = readImplicitGroup(tokenizer);

	    if (tokenizer.pos !== source.length) {
	        tokenizer.error('Unexpected input');
	    }

	    // reduce redundant groups with single group term
	    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
	        result = result.terms[0];
	    }

	    return result;
	}

	// warm up parse to elimitate code branches that never execute
	// fix soft deoptimizations (insufficient type feedback)
	parse('[a&&<b>#|<\'c\'>*||e() f{2} /,(% g#{1,2} h{2,})]!');

	var parse_1 = parse;

	var noop$2 = function() {};

	function ensureFunction(value) {
	    return typeof value === 'function' ? value : noop$2;
	}

	var walk$1 = function(node, options, context) {
	    function walk(node) {
	        enter.call(context, node);

	        switch (node.type) {
	            case 'Group':
	                node.terms.forEach(walk);
	                break;

	            case 'Multiplier':
	                walk(node.term);
	                break;

	            case 'Type':
	            case 'Property':
	            case 'Keyword':
	            case 'AtKeyword':
	            case 'Function':
	            case 'String':
	            case 'Token':
	            case 'Comma':
	                break;

	            default:
	                throw new Error('Unknown type: ' + node.type);
	        }

	        leave.call(context, node);
	    }

	    var enter = noop$2;
	    var leave = noop$2;

	    if (typeof options === 'function') {
	        enter = options;
	    } else if (options) {
	        enter = ensureFunction(options.enter);
	        leave = ensureFunction(options.leave);
	    }

	    if (enter === noop$2 && leave === noop$2) {
	        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	    }

	    walk(node);
	};

	var tokenStream = new TokenStream_1();
	var astToTokens = {
	    decorator: function(handlers) {
	        var curNode = null;
	        var prev = { len: 0, node: null };
	        var nodes = [prev];
	        var buffer = '';

	        return {
	            children: handlers.children,
	            node: function(node) {
	                var tmp = curNode;
	                curNode = node;
	                handlers.node.call(this, node);
	                curNode = tmp;
	            },
	            chunk: function(chunk) {
	                buffer += chunk;
	                if (prev.node !== curNode) {
	                    nodes.push({
	                        len: chunk.length,
	                        node: curNode
	                    });
	                } else {
	                    prev.len += chunk.length;
	                }
	            },
	            result: function() {
	                return prepareTokens(buffer, nodes);
	            }
	        };
	    }
	};

	function prepareTokens(str, nodes) {
	    var tokens = [];
	    var nodesOffset = 0;
	    var nodesIndex = 0;
	    var currentNode = nodes ? nodes[nodesIndex].node : null;

	    tokenizer(str, tokenStream);

	    while (!tokenStream.eof) {
	        if (nodes) {
	            while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
	                nodesOffset += nodes[nodesIndex++].len;
	                currentNode = nodes[nodesIndex].node;
	            }
	        }

	        tokens.push({
	            type: tokenStream.tokenType,
	            value: tokenStream.getTokenValue(),
	            index: tokenStream.tokenIndex, // TODO: remove it, temporary solution
	            balance: tokenStream.balance[tokenStream.tokenIndex], // TODO: remove it, temporary solution
	            node: currentNode
	        });
	        tokenStream.next();
	        // console.log({ ...tokens[tokens.length - 1], node: undefined });
	    }

	    return tokens;
	}

	var prepareTokens_1 = function(value, syntax) {
	    if (typeof value === 'string') {
	        return prepareTokens(value, null);
	    }

	    return syntax.generate(value, astToTokens);
	};

	var MATCH = { type: 'Match' };
	var MISMATCH = { type: 'Mismatch' };
	var DISALLOW_EMPTY = { type: 'DisallowEmpty' };
	var LEFTPARENTHESIS$1 = 40;  // (
	var RIGHTPARENTHESIS$1 = 41; // )

	function createCondition(match, thenBranch, elseBranch) {
	    // reduce node count
	    if (thenBranch === MATCH && elseBranch === MISMATCH) {
	        return match;
	    }

	    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
	        return match;
	    }

	    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
	        thenBranch = match.then;
	        match = match.match;
	    }

	    return {
	        type: 'If',
	        match: match,
	        then: thenBranch,
	        else: elseBranch
	    };
	}

	function isFunctionType(name) {
	    return (
	        name.length > 2 &&
	        name.charCodeAt(name.length - 2) === LEFTPARENTHESIS$1 &&
	        name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS$1
	    );
	}

	function isEnumCapatible(term) {
	    return (
	        term.type === 'Keyword' ||
	        term.type === 'AtKeyword' ||
	        term.type === 'Function' ||
	        term.type === 'Type' && isFunctionType(term.name)
	    );
	}

	function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
	    switch (combinator) {
	        case ' ':
	            // Juxtaposing components means that all of them must occur, in the given order.
	            //
	            // a b c
	            // =
	            // match a
	            //   then match b
	            //     then match c
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            //   else MISMATCH
	            var result = MATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                result = createCondition(
	                    term,
	                    result,
	                    MISMATCH
	                );
	            }
	            return result;

	        case '|':
	            // A bar (|) separates two or more alternatives: exactly one of them must occur.
	            //
	            // a | b | c
	            // =
	            // match a
	            //   then MATCH
	            //   else match b
	            //     then MATCH
	            //     else match c
	            //       then MATCH
	            //       else MISMATCH

	            var result = MISMATCH;
	            var map = null;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];

	                // reduce sequence of keywords into a Enum
	                if (isEnumCapatible(term)) {
	                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
	                        map = Object.create(null);
	                        result = createCondition(
	                            {
	                                type: 'Enum',
	                                map: map
	                            },
	                            MATCH,
	                            result
	                        );
	                    }

	                    if (map !== null) {
	                        var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
	                        if (key in map === false) {
	                            map[key] = term;
	                            continue;
	                        }
	                    }
	                }

	                map = null;

	                // create a new conditonal node
	                result = createCondition(
	                    term,
	                    MATCH,
	                    result
	                );
	            }
	            return result;

	        case '&&':
	            // A double ampersand (&&) separates two or more components,
	            // all of which must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since &&-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: true
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a && b && c
	            // =
	            // match a
	            //   then [b && c]
	            //   else match b
	            //     then [a && c]
	            //     else match c
	            //       then [a && b]
	            //       else MISMATCH
	            //
	            // a && b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MISMATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MISMATCH
	            //     else MISMATCH
	            var result = MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        false
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;

	        case '||':
	            // A double bar (||) separates two or more options:
	            // one or more of them must occur, in any order.

	            // Use MatchOnce for groups with a large number of terms,
	            // since ||-groups produces at least N!-node trees
	            if (terms.length > 5) {
	                return {
	                    type: 'MatchOnce',
	                    terms: terms,
	                    all: false
	                };
	            }

	            // Use a combination tree for groups with small number of terms
	            //
	            // a || b || c
	            // =
	            // match a
	            //   then [b || c]
	            //   else match b
	            //     then [a || c]
	            //     else match c
	            //       then [a || b]
	            //       else MISMATCH
	            //
	            // a || b
	            // =
	            // match a
	            //   then match b
	            //     then MATCH
	            //     else MATCH
	            //   else match b
	            //     then match a
	            //       then MATCH
	            //       else MATCH
	            //     else MISMATCH
	            var result = atLeastOneTermMatched ? MATCH : MISMATCH;

	            for (var i = terms.length - 1; i >= 0; i--) {
	                var term = terms[i];
	                var thenClause;

	                if (terms.length > 1) {
	                    thenClause = buildGroupMatchGraph(
	                        combinator,
	                        terms.filter(function(newGroupTerm) {
	                            return newGroupTerm !== term;
	                        }),
	                        true
	                    );
	                } else {
	                    thenClause = MATCH;
	                }

	                result = createCondition(
	                    term,
	                    thenClause,
	                    result
	                );
	            }
	            return result;
	    }
	}

	function buildMultiplierMatchGraph(node) {
	    var result = MATCH;
	    var matchTerm = buildMatchGraph(node.term);

	    if (node.max === 0) {
	        // disable repeating of empty match to prevent infinite loop
	        matchTerm = createCondition(
	            matchTerm,
	            DISALLOW_EMPTY,
	            MISMATCH
	        );

	        // an occurrence count is not limited, make a cycle;
	        // to collect more terms on each following matching mismatch
	        result = createCondition(
	            matchTerm,
	            null, // will be a loop
	            MISMATCH
	        );

	        result.then = createCondition(
	            MATCH,
	            MATCH,
	            result // make a loop
	        );

	        if (node.comma) {
	            result.then.else = createCondition(
	                { type: 'Comma', syntax: node },
	                result,
	                MISMATCH
	            );
	        }
	    } else {
	        // create a match node chain for [min .. max] interval with optional matches
	        for (var i = node.min || 1; i <= node.max; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                createCondition(
	                    MATCH,
	                    MATCH,
	                    result
	                ),
	                MISMATCH
	            );
	        }
	    }

	    if (node.min === 0) {
	        // allow zero match
	        result = createCondition(
	            MATCH,
	            MATCH,
	            result
	        );
	    } else {
	        // create a match node chain to collect [0 ... min - 1] required matches
	        for (var i = 0; i < node.min - 1; i++) {
	            if (node.comma && result !== MATCH) {
	                result = createCondition(
	                    { type: 'Comma', syntax: node },
	                    result,
	                    MISMATCH
	                );
	            }

	            result = createCondition(
	                matchTerm,
	                result,
	                MISMATCH
	            );
	        }
	    }

	    return result;
	}

	function buildMatchGraph(node) {
	    if (typeof node === 'function') {
	        return {
	            type: 'Generic',
	            fn: node
	        };
	    }

	    switch (node.type) {
	        case 'Group':
	            var result = buildGroupMatchGraph(
	                node.combinator,
	                node.terms.map(buildMatchGraph),
	                false
	            );

	            if (node.disallowEmpty) {
	                result = createCondition(
	                    result,
	                    DISALLOW_EMPTY,
	                    MISMATCH
	                );
	            }

	            return result;

	        case 'Multiplier':
	            return buildMultiplierMatchGraph(node);

	        case 'Type':
	        case 'Property':
	            return {
	                type: node.type,
	                name: node.name,
	                syntax: node
	            };

	        case 'Keyword':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'AtKeyword':
	            return {
	                type: node.type,
	                name: '@' + node.name.toLowerCase(),
	                syntax: node
	            };

	        case 'Function':
	            return {
	                type: node.type,
	                name: node.name.toLowerCase() + '(',
	                syntax: node
	            };

	        case 'String':
	            // convert a one char length String to a Token
	            if (node.value.length === 3) {
	                return {
	                    type: 'Token',
	                    value: node.value.charAt(1),
	                    syntax: node
	                };
	            }

	            // otherwise use it as is
	            return {
	                type: node.type,
	                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
	                syntax: node
	            };

	        case 'Token':
	            return {
	                type: node.type,
	                value: node.value,
	                syntax: node
	            };

	        case 'Comma':
	            return {
	                type: node.type,
	                syntax: node
	            };

	        default:
	            throw new Error('Unknown node type:', node.type);
	    }
	}

	var matchGraph = {
	    MATCH: MATCH,
	    MISMATCH: MISMATCH,
	    DISALLOW_EMPTY: DISALLOW_EMPTY,
	    buildMatchGraph: function(syntaxTree, ref) {
	        if (typeof syntaxTree === 'string') {
	            syntaxTree = parse_1(syntaxTree);
	        }

	        return {
	            type: 'MatchGraph',
	            match: buildMatchGraph(syntaxTree),
	            syntax: ref || null,
	            source: syntaxTree
	        };
	    }
	};

	var hasOwnProperty$1 = Object.prototype.hasOwnProperty;

	var MATCH$1 = matchGraph.MATCH;
	var MISMATCH$1 = matchGraph.MISMATCH;
	var DISALLOW_EMPTY$1 = matchGraph.DISALLOW_EMPTY;
	var TYPE$6 = _const.TYPE;

	var STUB = 0;
	var TOKEN = 1;
	var OPEN_SYNTAX = 2;
	var CLOSE_SYNTAX = 3;

	var EXIT_REASON_MATCH = 'Match';
	var EXIT_REASON_MISMATCH = 'Mismatch';
	var EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

	var ITERATION_LIMIT = 15000;
	var totalIterationCount = 0;

	function reverseList(list) {
	    var prev = null;
	    var next = null;
	    var item = list;

	    while (item !== null) {
	        next = item.prev;
	        item.prev = prev;
	        prev = item;
	        item = next;
	    }

	    return prev;
	}

	function areStringsEqualCaseInsensitive(testStr, referenceStr) {
	    if (testStr.length !== referenceStr.length) {
	        return false;
	    }

	    for (var i = 0; i < testStr.length; i++) {
	        var testCode = testStr.charCodeAt(i);
	        var referenceCode = referenceStr.charCodeAt(i);

	        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
	        if (testCode >= 0x0041 && testCode <= 0x005A) {
	            testCode = testCode | 32;
	        }

	        if (testCode !== referenceCode) {
	            return false;
	        }
	    }

	    return true;
	}

	function isCommaContextStart(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.Comma ||
	        token.type === TYPE$6.Function ||
	        token.type === TYPE$6.LeftParenthesis ||
	        token.type === TYPE$6.LeftSquareBracket ||
	        token.type === TYPE$6.LeftCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function isCommaContextEnd(token) {
	    if (token === null) {
	        return true;
	    }

	    return (
	        token.type === TYPE$6.RightParenthesis ||
	        token.type === TYPE$6.RightSquareBracket ||
	        token.type === TYPE$6.RightCurlyBracket ||
	        token.type === TYPE$6.Delim
	    );
	}

	function internalMatch(tokens, state, syntaxes) {
	    function moveToNextToken() {
	        do {
	            tokenIndex++;
	            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
	        } while (token !== null && (token.type === TYPE$6.WhiteSpace || token.type === TYPE$6.Comment));
	    }

	    function getNextToken(offset) {
	        var nextIndex = tokenIndex + offset;

	        return nextIndex < tokens.length ? tokens[nextIndex] : null;
	    }

	    function stateSnapshotFromSyntax(nextState, prev) {
	        return {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            thenStack: thenStack,
	            tokenIndex: tokenIndex,
	            prev: prev
	        };
	    }

	    function pushThenStack(nextState) {
	        thenStack = {
	            nextState: nextState,
	            matchStack: matchStack,
	            syntaxStack: syntaxStack,
	            prev: thenStack
	        };
	    }

	    function pushElseStack(nextState) {
	        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
	    }

	    function addTokenToMatch() {
	        matchStack = {
	            type: TOKEN,
	            syntax: state.syntax,
	            token: token,
	            prev: matchStack
	        };

	        moveToNextToken();
	        syntaxStash = null;

	        if (tokenIndex > longestMatch) {
	            longestMatch = tokenIndex;
	        }
	    }

	    function openSyntax() {
	        syntaxStack = {
	            syntax: state.syntax,
	            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
	            prev: syntaxStack
	        };

	        matchStack = {
	            type: OPEN_SYNTAX,
	            syntax: state.syntax,
	            token: matchStack.token,
	            prev: matchStack
	        };
	    }

	    function closeSyntax() {
	        if (matchStack.type === OPEN_SYNTAX) {
	            matchStack = matchStack.prev;
	        } else {
	            matchStack = {
	                type: CLOSE_SYNTAX,
	                syntax: syntaxStack.syntax,
	                token: matchStack.token,
	                prev: matchStack
	            };
	        }

	        syntaxStack = syntaxStack.prev;
	    }

	    var syntaxStack = null;
	    var thenStack = null;
	    var elseStack = null;

	    // null – stashing allowed, nothing stashed
	    // false – stashing disabled, nothing stashed
	    // anithing else – fail stashable syntaxes, some syntax stashed
	    var syntaxStash = null;

	    var iterationCount = 0; // count iterations and prevent infinite loop
	    var exitReason = null;

	    var token = null;
	    var tokenIndex = -1;
	    var longestMatch = 0;
	    var matchStack = {
	        type: STUB,
	        syntax: null,
	        token: null,
	        prev: null
	    };

	    moveToNextToken();

	    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
	        // function mapList(list, fn) {
	        //     var result = [];
	        //     while (list) {
	        //         result.unshift(fn(list));
	        //         list = list.prev;
	        //     }
	        //     return result;
	        // }
	        // console.log('--\n',
	        //     '#' + iterationCount,
	        //     require('util').inspect({
	        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
	        //         token: token && token.value,
	        //         tokenIndex,
	        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
	        //     }, { depth: null })
	        // );
	        switch (state.type) {
	            case 'Match':
	                if (thenStack === null) {
	                    // turn to MISMATCH when some tokens left unmatched
	                    if (token !== null) {
	                        // doesn't mismatch if just one token left and it's an IE hack
	                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
	                            state = MISMATCH$1;
	                            break;
	                        }
	                    }

	                    // break the main loop, return a result - MATCH
	                    exitReason = EXIT_REASON_MATCH;
	                    break;
	                }

	                // go to next syntax (`then` branch)
	                state = thenStack.nextState;

	                // check match is not empty
	                if (state === DISALLOW_EMPTY$1) {
	                    if (thenStack.matchStack === matchStack) {
	                        state = MISMATCH$1;
	                        break;
	                    } else {
	                        state = MATCH$1;
	                    }
	                }

	                // close syntax if needed
	                while (thenStack.syntaxStack !== syntaxStack) {
	                    closeSyntax();
	                }

	                // pop stack
	                thenStack = thenStack.prev;
	                break;

	            case 'Mismatch':
	                // when some syntax is stashed
	                if (syntaxStash !== null && syntaxStash !== false) {
	                    // there is no else branches or a branch reduce match stack
	                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
	                        // restore state from the stash
	                        elseStack = syntaxStash;
	                        syntaxStash = false; // disable stashing
	                    }
	                } else if (elseStack === null) {
	                    // no else branches -> break the main loop
	                    // return a result - MISMATCH
	                    exitReason = EXIT_REASON_MISMATCH;
	                    break;
	                }

	                // go to next syntax (`else` branch)
	                state = elseStack.nextState;

	                // restore all the rest stack states
	                thenStack = elseStack.thenStack;
	                syntaxStack = elseStack.syntaxStack;
	                matchStack = elseStack.matchStack;
	                tokenIndex = elseStack.tokenIndex;
	                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

	                // pop stack
	                elseStack = elseStack.prev;
	                break;

	            case 'MatchGraph':
	                state = state.match;
	                break;

	            case 'If':
	                // IMPORTANT: else stack push must go first,
	                // since it stores the state of thenStack before changes
	                if (state.else !== MISMATCH$1) {
	                    pushElseStack(state.else);
	                }

	                if (state.then !== MATCH$1) {
	                    pushThenStack(state.then);
	                }

	                state = state.match;
	                break;

	            case 'MatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state,
	                    index: 0,
	                    mask: 0
	                };
	                break;

	            case 'MatchOnceBuffer':
	                var terms = state.syntax.terms;

	                if (state.index === terms.length) {
	                    // no matches at all or it's required all terms to be matched
	                    if (state.mask === 0 || state.syntax.all) {
	                        state = MISMATCH$1;
	                        break;
	                    }

	                    // a partial match is ok
	                    state = MATCH$1;
	                    break;
	                }

	                // all terms are matched
	                if (state.mask === (1 << terms.length) - 1) {
	                    state = MATCH$1;
	                    break;
	                }

	                for (; state.index < terms.length; state.index++) {
	                    var matchFlag = 1 << state.index;

	                    if ((state.mask & matchFlag) === 0) {
	                        // IMPORTANT: else stack push must go first,
	                        // since it stores the state of thenStack before changes
	                        pushElseStack(state);
	                        pushThenStack({
	                            type: 'AddMatchOnce',
	                            syntax: state.syntax,
	                            mask: state.mask | matchFlag
	                        });

	                        // match
	                        state = terms[state.index++];
	                        break;
	                    }
	                }
	                break;

	            case 'AddMatchOnce':
	                state = {
	                    type: 'MatchOnceBuffer',
	                    syntax: state.syntax,
	                    index: 0,
	                    mask: state.mask
	                };
	                break;

	            case 'Enum':
	                if (token !== null) {
	                    var name = token.value.toLowerCase();

	                    // drop \0 and \9 hack from keyword name
	                    if (name.indexOf('\\') !== -1) {
	                        name = name.replace(/\\[09].*$/, '');
	                    }

	                    if (hasOwnProperty$1.call(state.map, name)) {
	                        state = state.map[name];
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Generic':
	                var opts = syntaxStack !== null ? syntaxStack.opts : null;
	                var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

	                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            case 'Type':
	            case 'Property':
	                var syntaxDict = state.type === 'Type' ? 'types' : 'properties';
	                var dictSyntax = hasOwnProperty$1.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

	                if (!dictSyntax || !dictSyntax.match) {
	                    throw new Error(
	                        'Bad syntax reference: ' +
	                        (state.type === 'Type'
	                            ? '<' + state.name + '>'
	                            : '<\'' + state.name + '\'>')
	                    );
	                }

	                // stash a syntax for types with low priority
	                if (syntaxStash !== false && token !== null && state.type === 'Type') {
	                    var lowPriorityMatching =
	                        // https://drafts.csswg.org/css-values-4/#custom-idents
	                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
	                        // can only claim the keyword if no other unfulfilled production can claim it.
	                        (state.name === 'custom-ident' && token.type === TYPE$6.Ident) ||

	                        // https://drafts.csswg.org/css-values-4/#lengths
	                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
	                        // it must parse as a <number>
	                        (state.name === 'length' && token.value === '0');

	                    if (lowPriorityMatching) {
	                        if (syntaxStash === null) {
	                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
	                        }

	                        state = MISMATCH$1;
	                        break;
	                    }
	                }

	                openSyntax();
	                state = dictSyntax.match;
	                break;

	            case 'Keyword':
	                var name = state.name;

	                if (token !== null) {
	                    var keywordName = token.value;

	                    // drop \0 and \9 hack from keyword name
	                    if (keywordName.indexOf('\\') !== -1) {
	                        keywordName = keywordName.replace(/\\[09].*$/, '');
	                    }

	                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
	                        addTokenToMatch();
	                        state = MATCH$1;
	                        break;
	                    }
	                }

	                state = MISMATCH$1;
	                break;

	            case 'AtKeyword':
	            case 'Function':
	                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Token':
	                if (token !== null && token.value === state.value) {
	                    addTokenToMatch();
	                    state = MATCH$1;
	                    break;
	                }

	                state = MISMATCH$1;
	                break;

	            case 'Comma':
	                if (token !== null && token.type === TYPE$6.Comma) {
	                    if (isCommaContextStart(matchStack.token)) {
	                        state = MISMATCH$1;
	                    } else {
	                        addTokenToMatch();
	                        state = isCommaContextEnd(token) ? MISMATCH$1 : MATCH$1;
	                    }
	                } else {
	                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH$1 : MISMATCH$1;
	                }

	                break;

	            case 'String':
	                var string = '';

	                for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
	                    string += tokens[lastTokenIndex].value;
	                }

	                if (areStringsEqualCaseInsensitive(string, state.value)) {
	                    while (tokenIndex < lastTokenIndex) {
	                        addTokenToMatch();
	                    }

	                    state = MATCH$1;
	                } else {
	                    state = MISMATCH$1;
	                }

	                break;

	            default:
	                throw new Error('Unknown node type: ' + state.type);
	        }
	    }

	    totalIterationCount += iterationCount;

	    switch (exitReason) {
	        case null:
	            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
	            exitReason = EXIT_REASON_ITERATION_LIMIT;
	            matchStack = null;
	            break;

	        case EXIT_REASON_MATCH:
	            while (syntaxStack !== null) {
	                closeSyntax();
	            }
	            break;

	        default:
	            matchStack = null;
	    }

	    return {
	        tokens: tokens,
	        reason: exitReason,
	        iterations: iterationCount,
	        match: matchStack,
	        longestMatch: longestMatch
	    };
	}

	function matchAsList(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match !== null) {
	        var item = reverseList(matchResult.match).prev;

	        matchResult.match = [];

	        while (item !== null) {
	            switch (item.type) {
	                case STUB:
	                    break;

	                case OPEN_SYNTAX:
	                case CLOSE_SYNTAX:
	                    matchResult.match.push({
	                        type: item.type,
	                        syntax: item.syntax
	                    });
	                    break;

	                default:
	                    matchResult.match.push({
	                        token: item.token.value,
	                        node: item.token.node
	                    });
	                    break;
	            }

	            item = item.prev;
	        }
	    }

	    return matchResult;
	}

	function matchAsTree(tokens, matchGraph, syntaxes) {
	    var matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

	    if (matchResult.match === null) {
	        return matchResult;
	    }

	    var item = matchResult.match;
	    var host = matchResult.match = {
	        syntax: matchGraph.syntax || null,
	        match: []
	    };
	    var hostStack = [host];

	    // revert a list and start with 2nd item since 1st is a stub item
	    item = reverseList(item).prev;

	    // build a tree
	    while (item !== null) {
	        switch (item.type) {
	            case OPEN_SYNTAX:
	                host.match.push(host = {
	                    syntax: item.syntax,
	                    match: []
	                });
	                hostStack.push(host);
	                break;

	            case CLOSE_SYNTAX:
	                hostStack.pop();
	                host = hostStack[hostStack.length - 1];
	                break;

	            default:
	                host.match.push({
	                    syntax: item.syntax || null,
	                    token: item.token.value,
	                    node: item.token.node
	                });
	        }

	        item = item.prev;
	    }

	    return matchResult;
	}

	var match = {
	    matchAsList: matchAsList,
	    matchAsTree: matchAsTree,
	    getTotalIterationCount: function() {
	        return totalIterationCount;
	    }
	};

	function getTrace(node) {
	    function shouldPutToTrace(syntax) {
	        if (syntax === null) {
	            return false;
	        }

	        return (
	            syntax.type === 'Type' ||
	            syntax.type === 'Property' ||
	            syntax.type === 'Keyword'
	        );
	    }

	    function hasMatch(matchNode) {
	        if (Array.isArray(matchNode.match)) {
	            // use for-loop for better perfomance
	            for (var i = 0; i < matchNode.match.length; i++) {
	                if (hasMatch(matchNode.match[i])) {
	                    if (shouldPutToTrace(matchNode.syntax)) {
	                        result.unshift(matchNode.syntax);
	                    }

	                    return true;
	                }
	            }
	        } else if (matchNode.node === node) {
	            result = shouldPutToTrace(matchNode.syntax)
	                ? [matchNode.syntax]
	                : [];

	            return true;
	        }

	        return false;
	    }

	    var result = null;

	    if (this.matched !== null) {
	        hasMatch(this.matched);
	    }

	    return result;
	}

	function testNode(match, node, fn) {
	    var trace = getTrace.call(match, node);

	    if (trace === null) {
	        return false;
	    }

	    return trace.some(fn);
	}

	function isType(node, type) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Type' && matchNode.name === type;
	    });
	}

	function isProperty(node, property) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Property' && matchNode.name === property;
	    });
	}

	function isKeyword(node) {
	    return testNode(this, node, function(matchNode) {
	        return matchNode.type === 'Keyword';
	    });
	}

	var trace = {
	    getTrace: getTrace,
	    isType: isType,
	    isProperty: isProperty,
	    isKeyword: isKeyword
	};

	function getFirstMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getFirstMatchNode(matchNode.match[0]);
	}

	function getLastMatchNode(matchNode) {
	    if ('node' in matchNode) {
	        return matchNode.node;
	    }

	    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
	}

	function matchFragments(lexer, ast, match, type, name) {
	    function findFragments(matchNode) {
	        if (matchNode.syntax !== null &&
	            matchNode.syntax.type === type &&
	            matchNode.syntax.name === name) {
	            var start = getFirstMatchNode(matchNode);
	            var end = getLastMatchNode(matchNode);

	            lexer.syntax.walk(ast, function(node, item, list) {
	                if (node === start) {
	                    var nodes = new List_1();

	                    do {
	                        nodes.appendData(item.data);

	                        if (item.data === end) {
	                            break;
	                        }

	                        item = item.next;
	                    } while (item !== null);

	                    fragments.push({
	                        parent: list,
	                        nodes: nodes
	                    });
	                }
	            });
	        }

	        if (Array.isArray(matchNode.match)) {
	            matchNode.match.forEach(findFragments);
	        }
	    }

	    var fragments = [];

	    if (match.matched !== null) {
	        findFragments(match.matched);
	    }

	    return fragments;
	}

	var search = {
	    matchFragments: matchFragments
	};

	var hasOwnProperty$2 = Object.prototype.hasOwnProperty;

	function isValidNumber(value) {
	    // Number.isInteger(value) && value >= 0
	    return (
	        typeof value === 'number' &&
	        isFinite(value) &&
	        Math.floor(value) === value &&
	        value >= 0
	    );
	}

	function isValidLocation(loc) {
	    return (
	        Boolean(loc) &&
	        isValidNumber(loc.offset) &&
	        isValidNumber(loc.line) &&
	        isValidNumber(loc.column)
	    );
	}

	function createNodeStructureChecker(type, fields) {
	    return function checkNode(node, warn) {
	        if (!node || node.constructor !== Object) {
	            return warn(node, 'Type of node should be an Object');
	        }

	        for (var key in node) {
	            var valid = true;

	            if (hasOwnProperty$2.call(node, key) === false) {
	                continue;
	            }

	            if (key === 'type') {
	                if (node.type !== type) {
	                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
	                }
	            } else if (key === 'loc') {
	                if (node.loc === null) {
	                    continue;
	                } else if (node.loc && node.loc.constructor === Object) {
	                    if (typeof node.loc.source !== 'string') {
	                        key += '.source';
	                    } else if (!isValidLocation(node.loc.start)) {
	                        key += '.start';
	                    } else if (!isValidLocation(node.loc.end)) {
	                        key += '.end';
	                    } else {
	                        continue;
	                    }
	                }

	                valid = false;
	            } else if (fields.hasOwnProperty(key)) {
	                for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
	                    var fieldType = fields[key][i];

	                    switch (fieldType) {
	                        case String:
	                            valid = typeof node[key] === 'string';
	                            break;

	                        case Boolean:
	                            valid = typeof node[key] === 'boolean';
	                            break;

	                        case null:
	                            valid = node[key] === null;
	                            break;

	                        default:
	                            if (typeof fieldType === 'string') {
	                                valid = node[key] && node[key].type === fieldType;
	                            } else if (Array.isArray(fieldType)) {
	                                valid = node[key] instanceof List_1;
	                            }
	                    }
	                }
	            } else {
	                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
	            }

	            if (!valid) {
	                warn(node, 'Bad value for `' + type + '.' + key + '`');
	            }
	        }

	        for (var key in fields) {
	            if (hasOwnProperty$2.call(fields, key) &&
	                hasOwnProperty$2.call(node, key) === false) {
	                warn(node, 'Field `' + type + '.' + key + '` is missed');
	            }
	        }
	    };
	}

	function processStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var fields = {
	        type: String,
	        loc: true
	    };
	    var docs = {
	        type: '"' + name + '"'
	    };

	    for (var key in structure) {
	        if (hasOwnProperty$2.call(structure, key) === false) {
	            continue;
	        }

	        var docsTypes = [];
	        var fieldTypes = fields[key] = Array.isArray(structure[key])
	            ? structure[key].slice()
	            : [structure[key]];

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === String || fieldType === Boolean) {
	                docsTypes.push(fieldType.name);
	            } else if (fieldType === null) {
	                docsTypes.push('null');
	            } else if (typeof fieldType === 'string') {
	                docsTypes.push('<' + fieldType + '>');
	            } else if (Array.isArray(fieldType)) {
	                docsTypes.push('List'); // TODO: use type enum
	            } else {
	                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
	            }
	        }

	        docs[key] = docsTypes.join(' | ');
	    }

	    return {
	        docs: docs,
	        check: createNodeStructureChecker(name, fields)
	    };
	}

	var structure = {
	    getStructureFromConfig: function(config) {
	        var structure = {};

	        if (config.node) {
	            for (var name in config.node) {
	                if (hasOwnProperty$2.call(config.node, name)) {
	                    var nodeType = config.node[name];

	                    if (nodeType.structure) {
	                        structure[name] = processStructure(name, nodeType);
	                    } else {
	                        throw new Error('Missed `structure` field in `' + name + '` node type definition');
	                    }
	                }
	            }
	        }

	        return structure;
	    }
	};

	var SyntaxReferenceError$1 = error.SyntaxReferenceError;
	var MatchError$1 = error.MatchError;






	var buildMatchGraph$1 = matchGraph.buildMatchGraph;
	var matchAsTree$1 = match.matchAsTree;


	var getStructureFromConfig = structure.getStructureFromConfig;
	var cssWideKeywords$1 = buildMatchGraph$1('inherit | initial | unset');
	var cssWideKeywordsWithExpression = buildMatchGraph$1('inherit | initial | unset | <-ms-legacy-expression>');

	function dumpMapSyntax(map, compact, syntaxAsAst) {
	    var result = {};

	    for (var name in map) {
	        if (map[name].syntax) {
	            result[name] = syntaxAsAst
	                ? map[name].syntax
	                : generate_1(map[name].syntax, { compact: compact });
	        }
	    }

	    return result;
	}

	function valueHasVar(tokens) {
	    for (var i = 0; i < tokens.length; i++) {
	        if (tokens[i].value.toLowerCase() === 'var(') {
	            return true;
	        }
	    }

	    return false;
	}

	function buildMatchResult(match, error, iterations) {
	    return {
	        matched: match,
	        iterations: iterations,
	        error: error,
	        getTrace: trace.getTrace,
	        isType: trace.isType,
	        isProperty: trace.isProperty,
	        isKeyword: trace.isKeyword
	    };
	}

	function matchSyntax(lexer, syntax, value, useCommon) {
	    var tokens = prepareTokens_1(value, lexer.syntax);
	    var result;

	    if (valueHasVar(tokens)) {
	        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
	    }

	    if (useCommon) {
	        result = matchAsTree$1(tokens, lexer.valueCommonSyntax, lexer);
	    }

	    if (!useCommon || !result.match) {
	        result = matchAsTree$1(tokens, syntax.match, lexer);
	        if (!result.match) {
	            return buildMatchResult(
	                null,
	                new MatchError$1(result.reason, syntax.syntax, value, result),
	                result.iterations
	            );
	        }
	    }

	    return buildMatchResult(result.match, null, result.iterations);
	}

	var Lexer = function(config, syntax, structure) {
	    this.valueCommonSyntax = cssWideKeywords$1;
	    this.syntax = syntax;
	    this.generic = false;
	    this.atrules = {};
	    this.properties = {};
	    this.types = {};
	    this.structure = structure || getStructureFromConfig(config);

	    if (config) {
	        if (config.types) {
	            for (var name in config.types) {
	                this.addType_(name, config.types[name]);
	            }
	        }

	        if (config.generic) {
	            this.generic = true;
	            for (var name in generic) {
	                this.addType_(name, generic[name]);
	            }
	        }

	        if (config.atrules) {
	            for (var name in config.atrules) {
	                this.addAtrule_(name, config.atrules[name]);
	            }
	        }

	        if (config.properties) {
	            for (var name in config.properties) {
	                this.addProperty_(name, config.properties[name]);
	            }
	        }
	    }
	};

	Lexer.prototype = {
	    structure: {},
	    checkStructure: function(ast) {
	        function collectWarning(node, message) {
	            warns.push({
	                node: node,
	                message: message
	            });
	        }

	        var structure = this.structure;
	        var warns = [];

	        this.syntax.walk(ast, function(node) {
	            if (structure.hasOwnProperty(node.type)) {
	                structure[node.type].check(node, collectWarning);
	            } else {
	                collectWarning(node, 'Unknown node type `' + node.type + '`');
	            }
	        });

	        return warns.length ? warns : false;
	    },

	    createDescriptor: function(syntax, type, name) {
	        var ref = {
	            type: type,
	            name: name
	        };
	        var descriptor = {
	            type: type,
	            name: name,
	            syntax: null,
	            match: null
	        };

	        if (typeof syntax === 'function') {
	            descriptor.match = buildMatchGraph$1(syntax, ref);
	        } else {
	            if (typeof syntax === 'string') {
	                // lazy parsing on first access
	                Object.defineProperty(descriptor, 'syntax', {
	                    get: function() {
	                        Object.defineProperty(descriptor, 'syntax', {
	                            value: parse_1(syntax)
	                        });

	                        return descriptor.syntax;
	                    }
	                });
	            } else {
	                descriptor.syntax = syntax;
	            }

	            // lazy graph build on first access
	            Object.defineProperty(descriptor, 'match', {
	                get: function() {
	                    Object.defineProperty(descriptor, 'match', {
	                        value: buildMatchGraph$1(descriptor.syntax, ref)
	                    });

	                    return descriptor.match;
	                }
	            });
	        }

	        return descriptor;
	    },
	    addAtrule_: function(name, syntax) {
	        this.atrules[name] = {
	            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
	            descriptors: syntax.descriptors
	                ? Object.keys(syntax.descriptors).reduce((res, name) => {
	                    res[name] = this.createDescriptor(syntax.descriptors[name], 'AtruleDescriptor', name);
	                    return res;
	                }, {})
	                : null
	        };
	    },
	    addProperty_: function(name, syntax) {
	        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
	    },
	    addType_: function(name, syntax) {
	        this.types[name] = this.createDescriptor(syntax, 'Type', name);

	        if (syntax === generic['-ms-legacy-expression']) {
	            this.valueCommonSyntax = cssWideKeywordsWithExpression;
	        }
	    },

	    matchAtrulePrelude: function(atruleName, prelude) {
	        var atrule = names.keyword(atruleName);

	        var atrulePreludeSyntax = atrule.vendor
	            ? this.getAtrulePrelude(atrule.name) || this.getAtrulePrelude(atrule.basename)
	            : this.getAtrulePrelude(atrule.name);

	        if (!atrulePreludeSyntax) {
	            if (atrule.basename in this.atrules) {
	                return buildMatchResult(null, new Error('At-rule `' + atruleName + '` should not contain a prelude'));
	            }

	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        return matchSyntax(this, atrulePreludeSyntax, prelude, true);
	    },
	    matchAtruleDescriptor: function(atruleName, descriptorName, value) {
	        var atrule = names.keyword(atruleName);
	        var descriptor = names.keyword(descriptorName);

	        var atruleEntry = atrule.vendor
	            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
	            : this.atrules[atrule.name];

	        if (!atruleEntry) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule', atruleName));
	        }

	        if (!atruleEntry.descriptors) {
	            return buildMatchResult(null, new Error('At-rule `' + atruleName + '` has no known descriptors'));
	        }

	        var atruleDescriptorSyntax = descriptor.vendor
	            ? atruleEntry.descriptors[descriptor.name] || atruleEntry.descriptors[descriptor.basename]
	            : atruleEntry.descriptors[descriptor.name];

	        if (!atruleDescriptorSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown at-rule descriptor', descriptorName));
	        }

	        return matchSyntax(this, atruleDescriptorSyntax, value, true);
	    },
	    matchDeclaration: function(node) {
	        if (node.type !== 'Declaration') {
	            return buildMatchResult(null, new Error('Not a Declaration node'));
	        }

	        return this.matchProperty(node.property, node.value);
	    },
	    matchProperty: function(propertyName, value) {
	        var property = names.property(propertyName);

	        // don't match syntax for a custom property
	        if (property.custom) {
	            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
	        }

	        var propertySyntax = property.vendor
	            ? this.getProperty(property.name) || this.getProperty(property.basename)
	            : this.getProperty(property.name);

	        if (!propertySyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown property', propertyName));
	        }

	        return matchSyntax(this, propertySyntax, value, true);
	    },
	    matchType: function(typeName, value) {
	        var typeSyntax = this.getType(typeName);

	        if (!typeSyntax) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Unknown type', typeName));
	        }

	        return matchSyntax(this, typeSyntax, value, false);
	    },
	    match: function(syntax, value) {
	        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
	            return buildMatchResult(null, new SyntaxReferenceError$1('Bad syntax'));
	        }

	        if (typeof syntax === 'string' || !syntax.match) {
	            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
	        }

	        return matchSyntax(this, syntax, value, false);
	    },

	    findValueFragments: function(propertyName, value, type, name) {
	        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
	    },
	    findDeclarationValueFragments: function(declaration, type, name) {
	        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
	    },
	    findAllFragments: function(ast, type, name) {
	        var result = [];

	        this.syntax.walk(ast, {
	            visit: 'Declaration',
	            enter: function(declaration) {
	                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
	            }.bind(this)
	        });

	        return result;
	    },

	    getAtrulePrelude: function(atruleName) {
	        return this.atrules.hasOwnProperty(atruleName) ? this.atrules[atruleName].prelude : null;
	    },
	    getAtruleDescriptor: function(atruleName, name) {
	        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
	            ? this.atrules[atruleName].declarators[name] || null
	            : null;
	    },
	    getProperty: function(name) {
	        return this.properties.hasOwnProperty(name) ? this.properties[name] : null;
	    },
	    getType: function(name) {
	        return this.types.hasOwnProperty(name) ? this.types[name] : null;
	    },

	    validate: function() {
	        function validate(syntax, name, broken, descriptor) {
	            if (broken.hasOwnProperty(name)) {
	                return broken[name];
	            }

	            broken[name] = false;
	            if (descriptor.syntax !== null) {
	                walk$1(descriptor.syntax, function(node) {
	                    if (node.type !== 'Type' && node.type !== 'Property') {
	                        return;
	                    }

	                    var map = node.type === 'Type' ? syntax.types : syntax.properties;
	                    var brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

	                    if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
	                        broken[name] = true;
	                    }
	                }, this);
	            }
	        }

	        var brokenTypes = {};
	        var brokenProperties = {};

	        for (var key in this.types) {
	            validate(this, key, brokenTypes, this.types[key]);
	        }

	        for (var key in this.properties) {
	            validate(this, key, brokenProperties, this.properties[key]);
	        }

	        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
	            return brokenTypes[name];
	        });
	        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
	            return brokenProperties[name];
	        });

	        if (brokenTypes.length || brokenProperties.length) {
	            return {
	                types: brokenTypes,
	                properties: brokenProperties
	            };
	        }

	        return null;
	    },
	    dump: function(syntaxAsAst, pretty) {
	        return {
	            generic: this.generic,
	            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
	            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst)
	        };
	    },
	    toString: function() {
	        return JSON.stringify(this.dump());
	    }
	};

	var Lexer_1 = Lexer;

	var definitionSyntax = {
	    SyntaxError: _SyntaxError$1,
	    parse: parse_1,
	    generate: generate_1,
	    walk: walk$1
	};

	var isBOM$2 = tokenizer.isBOM;

	var N$3 = 10;
	var F$2 = 12;
	var R$2 = 13;

	function computeLinesAndColumns(host, source) {
	    var sourceLength = source.length;
	    var lines = adoptBuffer(host.lines, sourceLength); // +1
	    var line = host.startLine;
	    var columns = adoptBuffer(host.columns, sourceLength);
	    var column = host.startColumn;
	    var startOffset = source.length > 0 ? isBOM$2(source.charCodeAt(0)) : 0;

	    for (var i = startOffset; i < sourceLength; i++) { // -1
	        var code = source.charCodeAt(i);

	        lines[i] = line;
	        columns[i] = column++;

	        if (code === N$3 || code === R$2 || code === F$2) {
	            if (code === R$2 && i + 1 < sourceLength && source.charCodeAt(i + 1) === N$3) {
	                i++;
	                lines[i] = line;
	                columns[i] = column;
	            }

	            line++;
	            column = 1;
	        }
	    }

	    lines[i] = line;
	    columns[i] = column;

	    host.lines = lines;
	    host.columns = columns;
	}

	var OffsetToLocation = function() {
	    this.lines = null;
	    this.columns = null;
	    this.linesAndColumnsComputed = false;
	};

	OffsetToLocation.prototype = {
	    setSource: function(source, startOffset, startLine, startColumn) {
	        this.source = source;
	        this.startOffset = typeof startOffset === 'undefined' ? 0 : startOffset;
	        this.startLine = typeof startLine === 'undefined' ? 1 : startLine;
	        this.startColumn = typeof startColumn === 'undefined' ? 1 : startColumn;
	        this.linesAndColumnsComputed = false;
	    },

	    ensureLinesAndColumnsComputed: function() {
	        if (!this.linesAndColumnsComputed) {
	            computeLinesAndColumns(this, this.source);
	            this.linesAndColumnsComputed = true;
	        }
	    },
	    getLocation: function(offset, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            offset: this.startOffset + offset,
	            line: this.lines[offset],
	            column: this.columns[offset]
	        };
	    },
	    getLocationRange: function(start, end, filename) {
	        this.ensureLinesAndColumnsComputed();

	        return {
	            source: filename,
	            start: {
	                offset: this.startOffset + start,
	                line: this.lines[start],
	                column: this.columns[start]
	            },
	            end: {
	                offset: this.startOffset + end,
	                line: this.lines[end],
	                column: this.columns[end]
	            }
	        };
	    }
	};

	var OffsetToLocation_1 = OffsetToLocation;

	var TYPE$7 = tokenizer.TYPE;
	var WHITESPACE$2 = TYPE$7.WhiteSpace;
	var COMMENT$2 = TYPE$7.Comment;

	var sequence = function readSequence(recognizer) {
	    var children = this.createList();
	    var child = null;
	    var context = {
	        recognizer: recognizer,
	        space: null,
	        ignoreWS: false,
	        ignoreWSAfter: false
	    };

	    this.scanner.skipSC();

	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case COMMENT$2:
	                this.scanner.next();
	                continue;

	            case WHITESPACE$2:
	                if (context.ignoreWS) {
	                    this.scanner.next();
	                } else {
	                    context.space = this.WhiteSpace();
	                }
	                continue;
	        }

	        child = recognizer.getNode.call(this, context);

	        if (child === undefined) {
	            break;
	        }

	        if (context.space !== null) {
	            children.push(context.space);
	            context.space = null;
	        }

	        children.push(child);

	        if (context.ignoreWSAfter) {
	            context.ignoreWSAfter = false;
	            context.ignoreWS = true;
	        } else {
	            context.ignoreWS = false;
	        }
	    }

	    return children;
	};

	var findWhiteSpaceStart$1 = utils.findWhiteSpaceStart;

	var noop$3 = function() {};

	var TYPE$8 = _const.TYPE;
	var NAME$2 = _const.NAME;
	var WHITESPACE$3 = TYPE$8.WhiteSpace;
	var IDENT$2 = TYPE$8.Ident;
	var FUNCTION = TYPE$8.Function;
	var URL$1 = TYPE$8.Url;
	var HASH = TYPE$8.Hash;
	var PERCENTAGE = TYPE$8.Percentage;
	var NUMBER$2 = TYPE$8.Number;
	var NUMBERSIGN$1 = 0x0023; // U+0023 NUMBER SIGN (#)
	var NULL = 0;

	function createParseContext(name) {
	    return function() {
	        return this[name]();
	    };
	}

	function processConfig(config) {
	    var parserConfig = {
	        context: {},
	        scope: {},
	        atrule: {},
	        pseudo: {}
	    };

	    if (config.parseContext) {
	        for (var name in config.parseContext) {
	            switch (typeof config.parseContext[name]) {
	                case 'function':
	                    parserConfig.context[name] = config.parseContext[name];
	                    break;

	                case 'string':
	                    parserConfig.context[name] = createParseContext(config.parseContext[name]);
	                    break;
	            }
	        }
	    }

	    if (config.scope) {
	        for (var name in config.scope) {
	            parserConfig.scope[name] = config.scope[name];
	        }
	    }

	    if (config.atrule) {
	        for (var name in config.atrule) {
	            var atrule = config.atrule[name];

	            if (atrule.parse) {
	                parserConfig.atrule[name] = atrule.parse;
	            }
	        }
	    }

	    if (config.pseudo) {
	        for (var name in config.pseudo) {
	            var pseudo = config.pseudo[name];

	            if (pseudo.parse) {
	                parserConfig.pseudo[name] = pseudo.parse;
	            }
	        }
	    }

	    if (config.node) {
	        for (var name in config.node) {
	            parserConfig[name] = config.node[name].parse;
	        }
	    }

	    return parserConfig;
	}

	var create$1 = function createParser(config) {
	    var parser = {
	        scanner: new TokenStream_1(),
	        locationMap: new OffsetToLocation_1(),

	        filename: '<unknown>',
	        needPositions: false,
	        onParseError: noop$3,
	        onParseErrorThrow: false,
	        parseAtrulePrelude: true,
	        parseRulePrelude: true,
	        parseValue: true,
	        parseCustomProperty: false,

	        readSequence: sequence,

	        createList: function() {
	            return new List_1();
	        },
	        createSingleNodeList: function(node) {
	            return new List_1().appendData(node);
	        },
	        getFirstListNode: function(list) {
	            return list && list.first();
	        },
	        getLastListNode: function(list) {
	            return list.last();
	        },

	        parseWithFallback: function(consumer, fallback) {
	            var startToken = this.scanner.tokenIndex;

	            try {
	                return consumer.call(this);
	            } catch (e) {
	                if (this.onParseErrorThrow) {
	                    throw e;
	                }

	                var fallbackNode = fallback.call(this, startToken);

	                this.onParseErrorThrow = true;
	                this.onParseError(e, fallbackNode);
	                this.onParseErrorThrow = false;

	                return fallbackNode;
	            }
	        },

	        lookupNonWSType: function(offset) {
	            do {
	                var type = this.scanner.lookupType(offset++);
	                if (type !== WHITESPACE$3) {
	                    return type;
	                }
	            } while (type !== NULL);

	            return NULL;
	        },

	        eat: function(tokenType) {
	            if (this.scanner.tokenType !== tokenType) {
	                var offset = this.scanner.tokenStart;
	                var message = NAME$2[tokenType] + ' is expected';

	                // tweak message and offset
	                switch (tokenType) {
	                    case IDENT$2:
	                        // when identifier is expected but there is a function or url
	                        if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL$1) {
	                            offset = this.scanner.tokenEnd - 1;
	                            message = 'Identifier is expected but function found';
	                        } else {
	                            message = 'Identifier is expected';
	                        }
	                        break;

	                    case HASH:
	                        if (this.scanner.isDelim(NUMBERSIGN$1)) {
	                            this.scanner.next();
	                            offset++;
	                            message = 'Name is expected';
	                        }
	                        break;

	                    case PERCENTAGE:
	                        if (this.scanner.tokenType === NUMBER$2) {
	                            offset = this.scanner.tokenEnd;
	                            message = 'Percent sign is expected';
	                        }
	                        break;

	                    default:
	                        // when test type is part of another token show error for current position + 1
	                        // e.g. eat(HYPHENMINUS) will fail on "-foo", but pointing on "-" is odd
	                        if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
	                            offset = offset + 1;
	                        }
	                }

	                this.error(message, offset);
	            }

	            this.scanner.next();
	        },

	        consume: function(tokenType) {
	            var value = this.scanner.getTokenValue();

	            this.eat(tokenType);

	            return value;
	        },
	        consumeFunctionName: function() {
	            var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);

	            this.eat(FUNCTION);

	            return name;
	        },

	        getLocation: function(start, end) {
	            if (this.needPositions) {
	                return this.locationMap.getLocationRange(
	                    start,
	                    end,
	                    this.filename
	                );
	            }

	            return null;
	        },
	        getLocationFromList: function(list) {
	            if (this.needPositions) {
	                var head = this.getFirstListNode(list);
	                var tail = this.getLastListNode(list);
	                return this.locationMap.getLocationRange(
	                    head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
	                    this.filename
	                );
	            }

	            return null;
	        },

	        error: function(message, offset) {
	            var location = typeof offset !== 'undefined' && offset < this.scanner.source.length
	                ? this.locationMap.getLocation(offset)
	                : this.scanner.eof
	                    ? this.locationMap.getLocation(findWhiteSpaceStart$1(this.scanner.source, this.scanner.source.length - 1))
	                    : this.locationMap.getLocation(this.scanner.tokenStart);

	            throw new _SyntaxError(
	                message || 'Unexpected input',
	                this.scanner.source,
	                location.offset,
	                location.line,
	                location.column
	            );
	        }
	    };

	    config = processConfig(config || {});
	    for (var key in config) {
	        parser[key] = config[key];
	    }

	    return function(source, options) {
	        options = options || {};

	        var context = options.context || 'default';
	        var ast;

	        tokenizer(source, parser.scanner);
	        parser.locationMap.setSource(
	            source,
	            options.offset,
	            options.line,
	            options.column
	        );

	        parser.filename = options.filename || '<unknown>';
	        parser.needPositions = Boolean(options.positions);
	        parser.onParseError = typeof options.onParseError === 'function' ? options.onParseError : noop$3;
	        parser.onParseErrorThrow = false;
	        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
	        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
	        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
	        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

	        if (!parser.context.hasOwnProperty(context)) {
	            throw new Error('Unknown context `' + context + '`');
	        }

	        ast = parser.context[context].call(parser, options);

	        if (!parser.scanner.eof) {
	            parser.error();
	        }

	        return ast;
	    };
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

	/**
	 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
	 */
	var encode = function (number) {
	  if (0 <= number && number < intToCharMap.length) {
	    return intToCharMap[number];
	  }
	  throw new TypeError("Must be between 0 and 63: " + number);
	};

	/**
	 * Decode a single base 64 character code digit to an integer. Returns -1 on
	 * failure.
	 */
	var decode = function (charCode) {
	  var bigA = 65;     // 'A'
	  var bigZ = 90;     // 'Z'

	  var littleA = 97;  // 'a'
	  var littleZ = 122; // 'z'

	  var zero = 48;     // '0'
	  var nine = 57;     // '9'

	  var plus = 43;     // '+'
	  var slash = 47;    // '/'

	  var littleOffset = 26;
	  var numberOffset = 52;

	  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
	  if (bigA <= charCode && charCode <= bigZ) {
	    return (charCode - bigA);
	  }

	  // 26 - 51: abcdefghijklmnopqrstuvwxyz
	  if (littleA <= charCode && charCode <= littleZ) {
	    return (charCode - littleA + littleOffset);
	  }

	  // 52 - 61: 0123456789
	  if (zero <= charCode && charCode <= nine) {
	    return (charCode - zero + numberOffset);
	  }

	  // 62: +
	  if (charCode == plus) {
	    return 62;
	  }

	  // 63: /
	  if (charCode == slash) {
	    return 63;
	  }

	  // Invalid base64 digit.
	  return -1;
	};

	var base64 = {
		encode: encode,
		decode: decode
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 *
	 * Based on the Base 64 VLQ implementation in Closure Compiler:
	 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
	 *
	 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
	 * Redistribution and use in source and binary forms, with or without
	 * modification, are permitted provided that the following conditions are
	 * met:
	 *
	 *  * Redistributions of source code must retain the above copyright
	 *    notice, this list of conditions and the following disclaimer.
	 *  * Redistributions in binary form must reproduce the above
	 *    copyright notice, this list of conditions and the following
	 *    disclaimer in the documentation and/or other materials provided
	 *    with the distribution.
	 *  * Neither the name of Google Inc. nor the names of its
	 *    contributors may be used to endorse or promote products derived
	 *    from this software without specific prior written permission.
	 *
	 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
	 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
	 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
	 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
	 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
	 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
	 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
	 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
	 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
	 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	 */



	// A single base 64 digit can contain 6 bits of data. For the base 64 variable
	// length quantities we use in the source map spec, the first bit is the sign,
	// the next four bits are the actual value, and the 6th bit is the
	// continuation bit. The continuation bit tells us whether there are more
	// digits in this value following this digit.
	//
	//   Continuation
	//   |    Sign
	//   |    |
	//   V    V
	//   101011

	var VLQ_BASE_SHIFT = 5;

	// binary: 100000
	var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

	// binary: 011111
	var VLQ_BASE_MASK = VLQ_BASE - 1;

	// binary: 100000
	var VLQ_CONTINUATION_BIT = VLQ_BASE;

	/**
	 * Converts from a two-complement value to a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
	 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
	 */
	function toVLQSigned(aValue) {
	  return aValue < 0
	    ? ((-aValue) << 1) + 1
	    : (aValue << 1) + 0;
	}

	/**
	 * Converts to a two-complement value from a value where the sign bit is
	 * placed in the least significant bit.  For example, as decimals:
	 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
	 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
	 */
	function fromVLQSigned(aValue) {
	  var isNegative = (aValue & 1) === 1;
	  var shifted = aValue >> 1;
	  return isNegative
	    ? -shifted
	    : shifted;
	}

	/**
	 * Returns the base 64 VLQ encoded value.
	 */
	var encode$1 = function base64VLQ_encode(aValue) {
	  var encoded = "";
	  var digit;

	  var vlq = toVLQSigned(aValue);

	  do {
	    digit = vlq & VLQ_BASE_MASK;
	    vlq >>>= VLQ_BASE_SHIFT;
	    if (vlq > 0) {
	      // There are still more digits in this value, so we must make sure the
	      // continuation bit is marked.
	      digit |= VLQ_CONTINUATION_BIT;
	    }
	    encoded += base64.encode(digit);
	  } while (vlq > 0);

	  return encoded;
	};

	/**
	 * Decodes the next base 64 VLQ value from the given string and returns the
	 * value and the rest of the string via the out parameter.
	 */
	var decode$1 = function base64VLQ_decode(aStr, aIndex, aOutParam) {
	  var strLen = aStr.length;
	  var result = 0;
	  var shift = 0;
	  var continuation, digit;

	  do {
	    if (aIndex >= strLen) {
	      throw new Error("Expected more digits in base 64 VLQ value.");
	    }

	    digit = base64.decode(aStr.charCodeAt(aIndex++));
	    if (digit === -1) {
	      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
	    }

	    continuation = !!(digit & VLQ_CONTINUATION_BIT);
	    digit &= VLQ_BASE_MASK;
	    result = result + (digit << shift);
	    shift += VLQ_BASE_SHIFT;
	  } while (continuation);

	  aOutParam.value = fromVLQSigned(result);
	  aOutParam.rest = aIndex;
	};

	var base64Vlq = {
		encode: encode$1,
		decode: decode$1
	};

	var util = createCommonjsModule(function (module, exports) {
	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */

	/**
	 * This is a helper function for getting values from parameter/options
	 * objects.
	 *
	 * @param args The object we are extracting values from
	 * @param name The name of the property we are getting.
	 * @param defaultValue An optional value to return if the property is missing
	 * from the object. If this is not specified and the property is missing, an
	 * error will be thrown.
	 */
	function getArg(aArgs, aName, aDefaultValue) {
	  if (aName in aArgs) {
	    return aArgs[aName];
	  } else if (arguments.length === 3) {
	    return aDefaultValue;
	  } else {
	    throw new Error('"' + aName + '" is a required argument.');
	  }
	}
	exports.getArg = getArg;

	var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
	var dataUrlRegexp = /^data:.+\,.+$/;

	function urlParse(aUrl) {
	  var match = aUrl.match(urlRegexp);
	  if (!match) {
	    return null;
	  }
	  return {
	    scheme: match[1],
	    auth: match[2],
	    host: match[3],
	    port: match[4],
	    path: match[5]
	  };
	}
	exports.urlParse = urlParse;

	function urlGenerate(aParsedUrl) {
	  var url = '';
	  if (aParsedUrl.scheme) {
	    url += aParsedUrl.scheme + ':';
	  }
	  url += '//';
	  if (aParsedUrl.auth) {
	    url += aParsedUrl.auth + '@';
	  }
	  if (aParsedUrl.host) {
	    url += aParsedUrl.host;
	  }
	  if (aParsedUrl.port) {
	    url += ":" + aParsedUrl.port;
	  }
	  if (aParsedUrl.path) {
	    url += aParsedUrl.path;
	  }
	  return url;
	}
	exports.urlGenerate = urlGenerate;

	/**
	 * Normalizes a path, or the path portion of a URL:
	 *
	 * - Replaces consecutive slashes with one slash.
	 * - Removes unnecessary '.' parts.
	 * - Removes unnecessary '<dir>/..' parts.
	 *
	 * Based on code in the Node.js 'path' core module.
	 *
	 * @param aPath The path or url to normalize.
	 */
	function normalize(aPath) {
	  var path = aPath;
	  var url = urlParse(aPath);
	  if (url) {
	    if (!url.path) {
	      return aPath;
	    }
	    path = url.path;
	  }
	  var isAbsolute = exports.isAbsolute(path);

	  var parts = path.split(/\/+/);
	  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
	    part = parts[i];
	    if (part === '.') {
	      parts.splice(i, 1);
	    } else if (part === '..') {
	      up++;
	    } else if (up > 0) {
	      if (part === '') {
	        // The first part is blank if the path is absolute. Trying to go
	        // above the root is a no-op. Therefore we can remove all '..' parts
	        // directly after the root.
	        parts.splice(i + 1, up);
	        up = 0;
	      } else {
	        parts.splice(i, 2);
	        up--;
	      }
	    }
	  }
	  path = parts.join('/');

	  if (path === '') {
	    path = isAbsolute ? '/' : '.';
	  }

	  if (url) {
	    url.path = path;
	    return urlGenerate(url);
	  }
	  return path;
	}
	exports.normalize = normalize;

	/**
	 * Joins two paths/URLs.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be joined with the root.
	 *
	 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
	 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
	 *   first.
	 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
	 *   is updated with the result and aRoot is returned. Otherwise the result
	 *   is returned.
	 *   - If aPath is absolute, the result is aPath.
	 *   - Otherwise the two paths are joined with a slash.
	 * - Joining for example 'http://' and 'www.example.com' is also supported.
	 */
	function join(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }
	  if (aPath === "") {
	    aPath = ".";
	  }
	  var aPathUrl = urlParse(aPath);
	  var aRootUrl = urlParse(aRoot);
	  if (aRootUrl) {
	    aRoot = aRootUrl.path || '/';
	  }

	  // `join(foo, '//www.example.org')`
	  if (aPathUrl && !aPathUrl.scheme) {
	    if (aRootUrl) {
	      aPathUrl.scheme = aRootUrl.scheme;
	    }
	    return urlGenerate(aPathUrl);
	  }

	  if (aPathUrl || aPath.match(dataUrlRegexp)) {
	    return aPath;
	  }

	  // `join('http://', 'www.example.com')`
	  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
	    aRootUrl.host = aPath;
	    return urlGenerate(aRootUrl);
	  }

	  var joined = aPath.charAt(0) === '/'
	    ? aPath
	    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

	  if (aRootUrl) {
	    aRootUrl.path = joined;
	    return urlGenerate(aRootUrl);
	  }
	  return joined;
	}
	exports.join = join;

	exports.isAbsolute = function (aPath) {
	  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
	};

	/**
	 * Make a path relative to a URL or another path.
	 *
	 * @param aRoot The root path or URL.
	 * @param aPath The path or URL to be made relative to aRoot.
	 */
	function relative(aRoot, aPath) {
	  if (aRoot === "") {
	    aRoot = ".";
	  }

	  aRoot = aRoot.replace(/\/$/, '');

	  // It is possible for the path to be above the root. In this case, simply
	  // checking whether the root is a prefix of the path won't work. Instead, we
	  // need to remove components from the root one by one, until either we find
	  // a prefix that fits, or we run out of components to remove.
	  var level = 0;
	  while (aPath.indexOf(aRoot + '/') !== 0) {
	    var index = aRoot.lastIndexOf("/");
	    if (index < 0) {
	      return aPath;
	    }

	    // If the only part of the root that is left is the scheme (i.e. http://,
	    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
	    // have exhausted all components, so the path is not relative to the root.
	    aRoot = aRoot.slice(0, index);
	    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
	      return aPath;
	    }

	    ++level;
	  }

	  // Make sure we add a "../" for each component we removed from the root.
	  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
	}
	exports.relative = relative;

	var supportsNullProto = (function () {
	  var obj = Object.create(null);
	  return !('__proto__' in obj);
	}());

	function identity (s) {
	  return s;
	}

	/**
	 * Because behavior goes wacky when you set `__proto__` on objects, we
	 * have to prefix all the strings in our set with an arbitrary character.
	 *
	 * See https://github.com/mozilla/source-map/pull/31 and
	 * https://github.com/mozilla/source-map/issues/30
	 *
	 * @param String aStr
	 */
	function toSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return '$' + aStr;
	  }

	  return aStr;
	}
	exports.toSetString = supportsNullProto ? identity : toSetString;

	function fromSetString(aStr) {
	  if (isProtoString(aStr)) {
	    return aStr.slice(1);
	  }

	  return aStr;
	}
	exports.fromSetString = supportsNullProto ? identity : fromSetString;

	function isProtoString(s) {
	  if (!s) {
	    return false;
	  }

	  var length = s.length;

	  if (length < 9 /* "__proto__".length */) {
	    return false;
	  }

	  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
	      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
	      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
	      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
	      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
	      s.charCodeAt(length - 9) !== 95  /* '_' */) {
	    return false;
	  }

	  for (var i = length - 10; i >= 0; i--) {
	    if (s.charCodeAt(i) !== 36 /* '$' */) {
	      return false;
	    }
	  }

	  return true;
	}

	/**
	 * Comparator between two mappings where the original positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same original source/line/column, but different generated
	 * line and column the same. Useful when searching for a mapping with a
	 * stubbed out mapping.
	 */
	function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
	  var cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0 || onlyCompareOriginal) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByOriginalPositions = compareByOriginalPositions;

	/**
	 * Comparator between two mappings with deflated source and name indices where
	 * the generated positions are compared.
	 *
	 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
	 * mappings with the same generated line and column, but different
	 * source/name/original line and column the same. Useful when searching for a
	 * mapping with a stubbed out mapping.
	 */
	function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0 || onlyCompareGenerated) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

	function strcmp(aStr1, aStr2) {
	  if (aStr1 === aStr2) {
	    return 0;
	  }

	  if (aStr1 === null) {
	    return 1; // aStr2 !== null
	  }

	  if (aStr2 === null) {
	    return -1; // aStr1 !== null
	  }

	  if (aStr1 > aStr2) {
	    return 1;
	  }

	  return -1;
	}

	/**
	 * Comparator between two mappings with inflated source and name strings where
	 * the generated positions are compared.
	 */
	function compareByGeneratedPositionsInflated(mappingA, mappingB) {
	  var cmp = mappingA.generatedLine - mappingB.generatedLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = strcmp(mappingA.source, mappingB.source);
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalLine - mappingB.originalLine;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  cmp = mappingA.originalColumn - mappingB.originalColumn;
	  if (cmp !== 0) {
	    return cmp;
	  }

	  return strcmp(mappingA.name, mappingB.name);
	}
	exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

	/**
	 * Strip any JSON XSSI avoidance prefix from the string (as documented
	 * in the source maps specification), and then parse the string as
	 * JSON.
	 */
	function parseSourceMapInput(str) {
	  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
	}
	exports.parseSourceMapInput = parseSourceMapInput;

	/**
	 * Compute the URL of a source given the the source root, the source's
	 * URL, and the source map's URL.
	 */
	function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
	  sourceURL = sourceURL || '';

	  if (sourceRoot) {
	    // This follows what Chrome does.
	    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
	      sourceRoot += '/';
	    }
	    // The spec says:
	    //   Line 4: An optional source root, useful for relocating source
	    //   files on a server or removing repeated values in the
	    //   “sources” entry.  This value is prepended to the individual
	    //   entries in the “source” field.
	    sourceURL = sourceRoot + sourceURL;
	  }

	  // Historically, SourceMapConsumer did not take the sourceMapURL as
	  // a parameter.  This mode is still somewhat supported, which is why
	  // this code block is conditional.  However, it's preferable to pass
	  // the source map URL to SourceMapConsumer, so that this function
	  // can implement the source URL resolution algorithm as outlined in
	  // the spec.  This block is basically the equivalent of:
	  //    new URL(sourceURL, sourceMapURL).toString()
	  // ... except it avoids using URL, which wasn't available in the
	  // older releases of node still supported by this library.
	  //
	  // The spec says:
	  //   If the sources are not absolute URLs after prepending of the
	  //   “sourceRoot”, the sources are resolved relative to the
	  //   SourceMap (like resolving script src in a html document).
	  if (sourceMapURL) {
	    var parsed = urlParse(sourceMapURL);
	    if (!parsed) {
	      throw new Error("sourceMapURL could not be parsed");
	    }
	    if (parsed.path) {
	      // Strip the last path component, but keep the "/".
	      var index = parsed.path.lastIndexOf('/');
	      if (index >= 0) {
	        parsed.path = parsed.path.substring(0, index + 1);
	      }
	    }
	    sourceURL = join(urlGenerate(parsed), sourceURL);
	  }

	  return normalize(sourceURL);
	}
	exports.computeSourceURL = computeSourceURL;
	});
	var util_1 = util.getArg;
	var util_2 = util.urlParse;
	var util_3 = util.urlGenerate;
	var util_4 = util.normalize;
	var util_5 = util.join;
	var util_6 = util.isAbsolute;
	var util_7 = util.relative;
	var util_8 = util.toSetString;
	var util_9 = util.fromSetString;
	var util_10 = util.compareByOriginalPositions;
	var util_11 = util.compareByGeneratedPositionsDeflated;
	var util_12 = util.compareByGeneratedPositionsInflated;
	var util_13 = util.parseSourceMapInput;
	var util_14 = util.computeSourceURL;

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */


	var has = Object.prototype.hasOwnProperty;
	var hasNativeMap = typeof Map !== "undefined";

	/**
	 * A data structure which is a combination of an array and a set. Adding a new
	 * member is O(1), testing for membership is O(1), and finding the index of an
	 * element is O(1). Removing elements from the set is not supported. Only
	 * strings are supported for membership.
	 */
	function ArraySet() {
	  this._array = [];
	  this._set = hasNativeMap ? new Map() : Object.create(null);
	}

	/**
	 * Static method for creating ArraySet instances from an existing array.
	 */
	ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
	  var set = new ArraySet();
	  for (var i = 0, len = aArray.length; i < len; i++) {
	    set.add(aArray[i], aAllowDuplicates);
	  }
	  return set;
	};

	/**
	 * Return how many unique items are in this ArraySet. If duplicates have been
	 * added, than those do not count towards the size.
	 *
	 * @returns Number
	 */
	ArraySet.prototype.size = function ArraySet_size() {
	  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
	};

	/**
	 * Add the given string to this set.
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
	  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
	  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
	  var idx = this._array.length;
	  if (!isDuplicate || aAllowDuplicates) {
	    this._array.push(aStr);
	  }
	  if (!isDuplicate) {
	    if (hasNativeMap) {
	      this._set.set(aStr, idx);
	    } else {
	      this._set[sStr] = idx;
	    }
	  }
	};

	/**
	 * Is the given string a member of this set?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.has = function ArraySet_has(aStr) {
	  if (hasNativeMap) {
	    return this._set.has(aStr);
	  } else {
	    var sStr = util.toSetString(aStr);
	    return has.call(this._set, sStr);
	  }
	};

	/**
	 * What is the index of the given string in the array?
	 *
	 * @param String aStr
	 */
	ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
	  if (hasNativeMap) {
	    var idx = this._set.get(aStr);
	    if (idx >= 0) {
	        return idx;
	    }
	  } else {
	    var sStr = util.toSetString(aStr);
	    if (has.call(this._set, sStr)) {
	      return this._set[sStr];
	    }
	  }

	  throw new Error('"' + aStr + '" is not in the set.');
	};

	/**
	 * What is the element at the given index?
	 *
	 * @param Number aIdx
	 */
	ArraySet.prototype.at = function ArraySet_at(aIdx) {
	  if (aIdx >= 0 && aIdx < this._array.length) {
	    return this._array[aIdx];
	  }
	  throw new Error('No element indexed by ' + aIdx);
	};

	/**
	 * Returns the array representation of this set (which has the proper indices
	 * indicated by indexOf). Note that this is a copy of the internal array used
	 * for storing the members so that no one can mess with internal state.
	 */
	ArraySet.prototype.toArray = function ArraySet_toArray() {
	  return this._array.slice();
	};

	var ArraySet_1 = ArraySet;

	var arraySet = {
		ArraySet: ArraySet_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2014 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	/**
	 * Determine whether mappingB is after mappingA with respect to generated
	 * position.
	 */
	function generatedPositionAfter(mappingA, mappingB) {
	  // Optimized for most common case
	  var lineA = mappingA.generatedLine;
	  var lineB = mappingB.generatedLine;
	  var columnA = mappingA.generatedColumn;
	  var columnB = mappingB.generatedColumn;
	  return lineB > lineA || lineB == lineA && columnB >= columnA ||
	         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
	}

	/**
	 * A data structure to provide a sorted view of accumulated mappings in a
	 * performance conscious manner. It trades a neglibable overhead in general
	 * case for a large speedup in case of mappings being added in order.
	 */
	function MappingList() {
	  this._array = [];
	  this._sorted = true;
	  // Serves as infimum
	  this._last = {generatedLine: -1, generatedColumn: 0};
	}

	/**
	 * Iterate through internal items. This method takes the same arguments that
	 * `Array.prototype.forEach` takes.
	 *
	 * NOTE: The order of the mappings is NOT guaranteed.
	 */
	MappingList.prototype.unsortedForEach =
	  function MappingList_forEach(aCallback, aThisArg) {
	    this._array.forEach(aCallback, aThisArg);
	  };

	/**
	 * Add the given source mapping.
	 *
	 * @param Object aMapping
	 */
	MappingList.prototype.add = function MappingList_add(aMapping) {
	  if (generatedPositionAfter(this._last, aMapping)) {
	    this._last = aMapping;
	    this._array.push(aMapping);
	  } else {
	    this._sorted = false;
	    this._array.push(aMapping);
	  }
	};

	/**
	 * Returns the flat, sorted array of mappings. The mappings are sorted by
	 * generated position.
	 *
	 * WARNING: This method returns internal data without copying, for
	 * performance. The return value must NOT be mutated, and should be treated as
	 * an immutable borrow. If you want to take ownership, you must make your own
	 * copy.
	 */
	MappingList.prototype.toArray = function MappingList_toArray() {
	  if (!this._sorted) {
	    this._array.sort(util.compareByGeneratedPositionsInflated);
	    this._sorted = true;
	  }
	  return this._array;
	};

	var MappingList_1 = MappingList;

	var mappingList = {
		MappingList: MappingList_1
	};

	/* -*- Mode: js; js-indent-level: 2; -*- */
	/*
	 * Copyright 2011 Mozilla Foundation and contributors
	 * Licensed under the New BSD license. See LICENSE or:
	 * http://opensource.org/licenses/BSD-3-Clause
	 */



	var ArraySet$1 = arraySet.ArraySet;
	var MappingList$1 = mappingList.MappingList;

	/**
	 * An instance of the SourceMapGenerator represents a source map which is
	 * being built incrementally. You may pass an object with the following
	 * properties:
	 *
	 *   - file: The filename of the generated source.
	 *   - sourceRoot: A root for all relative URLs in this source map.
	 */
	function SourceMapGenerator(aArgs) {
	  if (!aArgs) {
	    aArgs = {};
	  }
	  this._file = util.getArg(aArgs, 'file', null);
	  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
	  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
	  this._sources = new ArraySet$1();
	  this._names = new ArraySet$1();
	  this._mappings = new MappingList$1();
	  this._sourcesContents = null;
	}

	SourceMapGenerator.prototype._version = 3;

	/**
	 * Creates a new SourceMapGenerator based on a SourceMapConsumer
	 *
	 * @param aSourceMapConsumer The SourceMap.
	 */
	SourceMapGenerator.fromSourceMap =
	  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
	    var sourceRoot = aSourceMapConsumer.sourceRoot;
	    var generator = new SourceMapGenerator({
	      file: aSourceMapConsumer.file,
	      sourceRoot: sourceRoot
	    });
	    aSourceMapConsumer.eachMapping(function (mapping) {
	      var newMapping = {
	        generated: {
	          line: mapping.generatedLine,
	          column: mapping.generatedColumn
	        }
	      };

	      if (mapping.source != null) {
	        newMapping.source = mapping.source;
	        if (sourceRoot != null) {
	          newMapping.source = util.relative(sourceRoot, newMapping.source);
	        }

	        newMapping.original = {
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        };

	        if (mapping.name != null) {
	          newMapping.name = mapping.name;
	        }
	      }

	      generator.addMapping(newMapping);
	    });
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var sourceRelative = sourceFile;
	      if (sourceRoot !== null) {
	        sourceRelative = util.relative(sourceRoot, sourceFile);
	      }

	      if (!generator._sources.has(sourceRelative)) {
	        generator._sources.add(sourceRelative);
	      }

	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        generator.setSourceContent(sourceFile, content);
	      }
	    });
	    return generator;
	  };

	/**
	 * Add a single mapping from original source line and column to the generated
	 * source's line and column for this source map being created. The mapping
	 * object should have the following properties:
	 *
	 *   - generated: An object with the generated line and column positions.
	 *   - original: An object with the original line and column positions.
	 *   - source: The original source file (relative to the sourceRoot).
	 *   - name: An optional original token name for this mapping.
	 */
	SourceMapGenerator.prototype.addMapping =
	  function SourceMapGenerator_addMapping(aArgs) {
	    var generated = util.getArg(aArgs, 'generated');
	    var original = util.getArg(aArgs, 'original', null);
	    var source = util.getArg(aArgs, 'source', null);
	    var name = util.getArg(aArgs, 'name', null);

	    if (!this._skipValidation) {
	      this._validateMapping(generated, original, source, name);
	    }

	    if (source != null) {
	      source = String(source);
	      if (!this._sources.has(source)) {
	        this._sources.add(source);
	      }
	    }

	    if (name != null) {
	      name = String(name);
	      if (!this._names.has(name)) {
	        this._names.add(name);
	      }
	    }

	    this._mappings.add({
	      generatedLine: generated.line,
	      generatedColumn: generated.column,
	      originalLine: original != null && original.line,
	      originalColumn: original != null && original.column,
	      source: source,
	      name: name
	    });
	  };

	/**
	 * Set the source content for a source file.
	 */
	SourceMapGenerator.prototype.setSourceContent =
	  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
	    var source = aSourceFile;
	    if (this._sourceRoot != null) {
	      source = util.relative(this._sourceRoot, source);
	    }

	    if (aSourceContent != null) {
	      // Add the source content to the _sourcesContents map.
	      // Create a new _sourcesContents map if the property is null.
	      if (!this._sourcesContents) {
	        this._sourcesContents = Object.create(null);
	      }
	      this._sourcesContents[util.toSetString(source)] = aSourceContent;
	    } else if (this._sourcesContents) {
	      // Remove the source file from the _sourcesContents map.
	      // If the _sourcesContents map is empty, set the property to null.
	      delete this._sourcesContents[util.toSetString(source)];
	      if (Object.keys(this._sourcesContents).length === 0) {
	        this._sourcesContents = null;
	      }
	    }
	  };

	/**
	 * Applies the mappings of a sub-source-map for a specific source file to the
	 * source map being generated. Each mapping to the supplied source file is
	 * rewritten using the supplied source map. Note: The resolution for the
	 * resulting mappings is the minimium of this map and the supplied map.
	 *
	 * @param aSourceMapConsumer The source map to be applied.
	 * @param aSourceFile Optional. The filename of the source file.
	 *        If omitted, SourceMapConsumer's file property will be used.
	 * @param aSourceMapPath Optional. The dirname of the path to the source map
	 *        to be applied. If relative, it is relative to the SourceMapConsumer.
	 *        This parameter is needed when the two source maps aren't in the same
	 *        directory, and the source map to be applied contains relative source
	 *        paths. If so, those relative source paths need to be rewritten
	 *        relative to the SourceMapGenerator.
	 */
	SourceMapGenerator.prototype.applySourceMap =
	  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
	    var sourceFile = aSourceFile;
	    // If aSourceFile is omitted, we will use the file property of the SourceMap
	    if (aSourceFile == null) {
	      if (aSourceMapConsumer.file == null) {
	        throw new Error(
	          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
	          'or the source map\'s "file" property. Both were omitted.'
	        );
	      }
	      sourceFile = aSourceMapConsumer.file;
	    }
	    var sourceRoot = this._sourceRoot;
	    // Make "sourceFile" relative if an absolute Url is passed.
	    if (sourceRoot != null) {
	      sourceFile = util.relative(sourceRoot, sourceFile);
	    }
	    // Applying the SourceMap can add and remove items from the sources and
	    // the names array.
	    var newSources = new ArraySet$1();
	    var newNames = new ArraySet$1();

	    // Find mappings for the "sourceFile"
	    this._mappings.unsortedForEach(function (mapping) {
	      if (mapping.source === sourceFile && mapping.originalLine != null) {
	        // Check if it can be mapped by the source map, then update the mapping.
	        var original = aSourceMapConsumer.originalPositionFor({
	          line: mapping.originalLine,
	          column: mapping.originalColumn
	        });
	        if (original.source != null) {
	          // Copy mapping
	          mapping.source = original.source;
	          if (aSourceMapPath != null) {
	            mapping.source = util.join(aSourceMapPath, mapping.source);
	          }
	          if (sourceRoot != null) {
	            mapping.source = util.relative(sourceRoot, mapping.source);
	          }
	          mapping.originalLine = original.line;
	          mapping.originalColumn = original.column;
	          if (original.name != null) {
	            mapping.name = original.name;
	          }
	        }
	      }

	      var source = mapping.source;
	      if (source != null && !newSources.has(source)) {
	        newSources.add(source);
	      }

	      var name = mapping.name;
	      if (name != null && !newNames.has(name)) {
	        newNames.add(name);
	      }

	    }, this);
	    this._sources = newSources;
	    this._names = newNames;

	    // Copy sourcesContents of applied map.
	    aSourceMapConsumer.sources.forEach(function (sourceFile) {
	      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
	      if (content != null) {
	        if (aSourceMapPath != null) {
	          sourceFile = util.join(aSourceMapPath, sourceFile);
	        }
	        if (sourceRoot != null) {
	          sourceFile = util.relative(sourceRoot, sourceFile);
	        }
	        this.setSourceContent(sourceFile, content);
	      }
	    }, this);
	  };

	/**
	 * A mapping can have one of the three levels of data:
	 *
	 *   1. Just the generated position.
	 *   2. The Generated position, original position, and original source.
	 *   3. Generated and original position, original source, as well as a name
	 *      token.
	 *
	 * To maintain consistency, we validate that any new mapping being added falls
	 * in to one of these categories.
	 */
	SourceMapGenerator.prototype._validateMapping =
	  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
	                                              aName) {
	    // When aOriginal is truthy but has empty values for .line and .column,
	    // it is most likely a programmer error. In this case we throw a very
	    // specific error message to try to guide them the right way.
	    // For example: https://github.com/Polymer/polymer-bundler/pull/519
	    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
	        throw new Error(
	            'original.line and original.column are not numbers -- you probably meant to omit ' +
	            'the original mapping entirely and only map the generated position. If so, pass ' +
	            'null for the original mapping instead of an object with empty or null values.'
	        );
	    }

	    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	        && aGenerated.line > 0 && aGenerated.column >= 0
	        && !aOriginal && !aSource && !aName) {
	      // Case 1.
	      return;
	    }
	    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
	             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
	             && aGenerated.line > 0 && aGenerated.column >= 0
	             && aOriginal.line > 0 && aOriginal.column >= 0
	             && aSource) {
	      // Cases 2 and 3.
	      return;
	    }
	    else {
	      throw new Error('Invalid mapping: ' + JSON.stringify({
	        generated: aGenerated,
	        source: aSource,
	        original: aOriginal,
	        name: aName
	      }));
	    }
	  };

	/**
	 * Serialize the accumulated mappings in to the stream of base 64 VLQs
	 * specified by the source map format.
	 */
	SourceMapGenerator.prototype._serializeMappings =
	  function SourceMapGenerator_serializeMappings() {
	    var previousGeneratedColumn = 0;
	    var previousGeneratedLine = 1;
	    var previousOriginalColumn = 0;
	    var previousOriginalLine = 0;
	    var previousName = 0;
	    var previousSource = 0;
	    var result = '';
	    var next;
	    var mapping;
	    var nameIdx;
	    var sourceIdx;

	    var mappings = this._mappings.toArray();
	    for (var i = 0, len = mappings.length; i < len; i++) {
	      mapping = mappings[i];
	      next = '';

	      if (mapping.generatedLine !== previousGeneratedLine) {
	        previousGeneratedColumn = 0;
	        while (mapping.generatedLine !== previousGeneratedLine) {
	          next += ';';
	          previousGeneratedLine++;
	        }
	      }
	      else {
	        if (i > 0) {
	          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
	            continue;
	          }
	          next += ',';
	        }
	      }

	      next += base64Vlq.encode(mapping.generatedColumn
	                                 - previousGeneratedColumn);
	      previousGeneratedColumn = mapping.generatedColumn;

	      if (mapping.source != null) {
	        sourceIdx = this._sources.indexOf(mapping.source);
	        next += base64Vlq.encode(sourceIdx - previousSource);
	        previousSource = sourceIdx;

	        // lines are stored 0-based in SourceMap spec version 3
	        next += base64Vlq.encode(mapping.originalLine - 1
	                                   - previousOriginalLine);
	        previousOriginalLine = mapping.originalLine - 1;

	        next += base64Vlq.encode(mapping.originalColumn
	                                   - previousOriginalColumn);
	        previousOriginalColumn = mapping.originalColumn;

	        if (mapping.name != null) {
	          nameIdx = this._names.indexOf(mapping.name);
	          next += base64Vlq.encode(nameIdx - previousName);
	          previousName = nameIdx;
	        }
	      }

	      result += next;
	    }

	    return result;
	  };

	SourceMapGenerator.prototype._generateSourcesContent =
	  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
	    return aSources.map(function (source) {
	      if (!this._sourcesContents) {
	        return null;
	      }
	      if (aSourceRoot != null) {
	        source = util.relative(aSourceRoot, source);
	      }
	      var key = util.toSetString(source);
	      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
	        ? this._sourcesContents[key]
	        : null;
	    }, this);
	  };

	/**
	 * Externalize the source map.
	 */
	SourceMapGenerator.prototype.toJSON =
	  function SourceMapGenerator_toJSON() {
	    var map = {
	      version: this._version,
	      sources: this._sources.toArray(),
	      names: this._names.toArray(),
	      mappings: this._serializeMappings()
	    };
	    if (this._file != null) {
	      map.file = this._file;
	    }
	    if (this._sourceRoot != null) {
	      map.sourceRoot = this._sourceRoot;
	    }
	    if (this._sourcesContents) {
	      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
	    }

	    return map;
	  };

	/**
	 * Render the source map being generated to a string.
	 */
	SourceMapGenerator.prototype.toString =
	  function SourceMapGenerator_toString() {
	    return JSON.stringify(this.toJSON());
	  };

	var SourceMapGenerator_1 = SourceMapGenerator;

	var sourceMapGenerator = {
		SourceMapGenerator: SourceMapGenerator_1
	};

	var SourceMapGenerator$1 = sourceMapGenerator.SourceMapGenerator;
	var trackNodes = {
	    Atrule: true,
	    Selector: true,
	    Declaration: true
	};

	var sourceMap = function generateSourceMap(handlers) {
	    var map = new SourceMapGenerator$1();
	    var line = 1;
	    var column = 0;
	    var generated = {
	        line: 1,
	        column: 0
	    };
	    var original = {
	        line: 0, // should be zero to add first mapping
	        column: 0
	    };
	    var sourceMappingActive = false;
	    var activatedGenerated = {
	        line: 1,
	        column: 0
	    };
	    var activatedMapping = {
	        generated: activatedGenerated
	    };

	    var handlersNode = handlers.node;
	    handlers.node = function(node) {
	        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
	            var nodeLine = node.loc.start.line;
	            var nodeColumn = node.loc.start.column - 1;

	            if (original.line !== nodeLine ||
	                original.column !== nodeColumn) {
	                original.line = nodeLine;
	                original.column = nodeColumn;

	                generated.line = line;
	                generated.column = column;

	                if (sourceMappingActive) {
	                    sourceMappingActive = false;
	                    if (generated.line !== activatedGenerated.line ||
	                        generated.column !== activatedGenerated.column) {
	                        map.addMapping(activatedMapping);
	                    }
	                }

	                sourceMappingActive = true;
	                map.addMapping({
	                    source: node.loc.source,
	                    original: original,
	                    generated: generated
	                });
	            }
	        }

	        handlersNode.call(this, node);

	        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
	            activatedGenerated.line = line;
	            activatedGenerated.column = column;
	        }
	    };

	    var handlersChunk = handlers.chunk;
	    handlers.chunk = function(chunk) {
	        for (var i = 0; i < chunk.length; i++) {
	            if (chunk.charCodeAt(i) === 10) { // \n
	                line++;
	                column = 0;
	            } else {
	                column++;
	            }
	        }

	        handlersChunk(chunk);
	    };

	    var handlersResult = handlers.result;
	    handlers.result = function() {
	        if (sourceMappingActive) {
	            map.addMapping(activatedMapping);
	        }

	        return {
	            css: handlersResult(),
	            map: map
	        };
	    };

	    return handlers;
	};

	var hasOwnProperty$3 = Object.prototype.hasOwnProperty;

	function processChildren(node, delimeter) {
	    var list = node.children;
	    var prev = null;

	    if (typeof delimeter !== 'function') {
	        list.forEach(this.node, this);
	    } else {
	        list.forEach(function(node) {
	            if (prev !== null) {
	                delimeter.call(this, prev);
	            }

	            this.node(node);
	            prev = node;
	        }, this);
	    }
	}

	var create$2 = function createGenerator(config) {
	    function processNode(node) {
	        if (hasOwnProperty$3.call(types, node.type)) {
	            types[node.type].call(this, node);
	        } else {
	            throw new Error('Unknown node type: ' + node.type);
	        }
	    }

	    var types = {};

	    if (config.node) {
	        for (var name in config.node) {
	            types[name] = config.node[name].generate;
	        }
	    }

	    return function(node, options) {
	        var buffer = '';
	        var handlers = {
	            children: processChildren,
	            node: processNode,
	            chunk: function(chunk) {
	                buffer += chunk;
	            },
	            result: function() {
	                return buffer;
	            }
	        };

	        if (options) {
	            if (typeof options.decorator === 'function') {
	                handlers = options.decorator(handlers);
	            }

	            if (options.sourceMap) {
	                handlers = sourceMap(handlers);
	            }
	        }

	        handlers.node(node);

	        return handlers.result();
	    };
	};

	var create$3 = function createConvertors(walk) {
	    return {
	        fromPlainObject: function(ast) {
	            walk(ast, {
	                enter: function(node) {
	                    if (node.children && node.children instanceof List_1 === false) {
	                        node.children = new List_1().fromArray(node.children);
	                    }
	                }
	            });

	            return ast;
	        },
	        toPlainObject: function(ast) {
	            walk(ast, {
	                leave: function(node) {
	                    if (node.children && node.children instanceof List_1) {
	                        node.children = node.children.toArray();
	                    }
	                }
	            });

	            return ast;
	        }
	    };
	};

	var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
	var noop$4 = function() {};

	function ensureFunction$1(value) {
	    return typeof value === 'function' ? value : noop$4;
	}

	function invokeForType(fn, type) {
	    return function(node, item, list) {
	        if (node.type === type) {
	            fn.call(this, node, item, list);
	        }
	    };
	}

	function getWalkersFromStructure(name, nodeType) {
	    var structure = nodeType.structure;
	    var walkers = [];

	    for (var key in structure) {
	        if (hasOwnProperty$4.call(structure, key) === false) {
	            continue;
	        }

	        var fieldTypes = structure[key];
	        var walker = {
	            name: key,
	            type: false,
	            nullable: false
	        };

	        if (!Array.isArray(structure[key])) {
	            fieldTypes = [structure[key]];
	        }

	        for (var i = 0; i < fieldTypes.length; i++) {
	            var fieldType = fieldTypes[i];
	            if (fieldType === null) {
	                walker.nullable = true;
	            } else if (typeof fieldType === 'string') {
	                walker.type = 'node';
	            } else if (Array.isArray(fieldType)) {
	                walker.type = 'list';
	            }
	        }

	        if (walker.type) {
	            walkers.push(walker);
	        }
	    }

	    if (walkers.length) {
	        return {
	            context: nodeType.walkContext,
	            fields: walkers
	        };
	    }

	    return null;
	}

	function getTypesFromConfig(config) {
	    var types = {};

	    for (var name in config.node) {
	        if (hasOwnProperty$4.call(config.node, name)) {
	            var nodeType = config.node[name];

	            if (!nodeType.structure) {
	                throw new Error('Missed `structure` field in `' + name + '` node type definition');
	            }

	            types[name] = getWalkersFromStructure(name, nodeType);
	        }
	    }

	    return types;
	}

	function createTypeIterator(config, reverse) {
	    var fields = config.fields.slice();
	    var contextName = config.context;
	    var useContext = typeof contextName === 'string';

	    if (reverse) {
	        fields.reverse();
	    }

	    return function(node, context, walk) {
	        var prevContextValue;

	        if (useContext) {
	            prevContextValue = context[contextName];
	            context[contextName] = node;
	        }

	        for (var i = 0; i < fields.length; i++) {
	            var field = fields[i];
	            var ref = node[field.name];

	            if (!field.nullable || ref) {
	                if (field.type === 'list') {
	                    if (reverse) {
	                        ref.forEachRight(walk);
	                    } else {
	                        ref.forEach(walk);
	                    }
	                } else {
	                    walk(ref);
	                }
	            }
	        }

	        if (useContext) {
	            context[contextName] = prevContextValue;
	        }
	    };
	}

	function createFastTraveralMap(iterators) {
	    return {
	        Atrule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Rule: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block
	        },
	        Declaration: {
	            StyleSheet: iterators.StyleSheet,
	            Atrule: iterators.Atrule,
	            Rule: iterators.Rule,
	            Block: iterators.Block,
	            DeclarationList: iterators.DeclarationList
	        }
	    };
	}

	var create$4 = function createWalker(config) {
	    var types = getTypesFromConfig(config);
	    var iteratorsNatural = {};
	    var iteratorsReverse = {};

	    for (var name in types) {
	        if (hasOwnProperty$4.call(types, name) && types[name] !== null) {
	            iteratorsNatural[name] = createTypeIterator(types[name], false);
	            iteratorsReverse[name] = createTypeIterator(types[name], true);
	        }
	    }

	    var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
	    var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

	    var walk = function(root, options) {
	        function walkNode(node, item, list) {
	            enter.call(context, node, item, list);

	            if (iterators.hasOwnProperty(node.type)) {
	                iterators[node.type](node, context, walkNode);
	            }

	            leave.call(context, node, item, list);
	        }

	        var enter = noop$4;
	        var leave = noop$4;
	        var iterators = iteratorsNatural;
	        var context = {
	            root: root,
	            stylesheet: null,
	            atrule: null,
	            atrulePrelude: null,
	            rule: null,
	            selector: null,
	            block: null,
	            declaration: null,
	            function: null
	        };

	        if (typeof options === 'function') {
	            enter = options;
	        } else if (options) {
	            enter = ensureFunction$1(options.enter);
	            leave = ensureFunction$1(options.leave);

	            if (options.reverse) {
	                iterators = iteratorsReverse;
	            }

	            if (options.visit) {
	                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
	                    iterators = options.reverse
	                        ? fastTraversalIteratorsReverse[options.visit]
	                        : fastTraversalIteratorsNatural[options.visit];
	                } else if (!types.hasOwnProperty(options.visit)) {
	                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).join(', ') + ')');
	                }

	                enter = invokeForType(enter, options.visit);
	                leave = invokeForType(leave, options.visit);
	            }
	        }

	        if (enter === noop$4 && leave === noop$4) {
	            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
	        }

	        // swap handlers in reverse mode to invert visit order
	        if (options.reverse) {
	            var tmp = enter;
	            enter = leave;
	            leave = tmp;
	        }

	        walkNode(root);
	    };

	    walk.find = function(ast, fn) {
	        var found = null;

	        walk(ast, function(node, item, list) {
	            if (found === null && fn.call(this, node, item, list)) {
	                found = node;
	            }
	        });

	        return found;
	    };

	    walk.findLast = function(ast, fn) {
	        var found = null;

	        walk(ast, {
	            reverse: true,
	            enter: function(node, item, list) {
	                if (found === null && fn.call(this, node, item, list)) {
	                    found = node;
	                }
	            }
	        });

	        return found;
	    };

	    walk.findAll = function(ast, fn) {
	        var found = [];

	        walk(ast, function(node, item, list) {
	            if (fn.call(this, node, item, list)) {
	                found.push(node);
	            }
	        });

	        return found;
	    };

	    return walk;
	};

	var clone = function clone(node) {
	    var result = {};

	    for (var key in node) {
	        var value = node[key];

	        if (value) {
	            if (Array.isArray(value) || value instanceof List_1) {
	                value = value.map(clone);
	            } else if (value.constructor === Object) {
	                value = clone(value);
	            }
	        }

	        result[key] = value;
	    }

	    return result;
	};

	var hasOwnProperty$5 = Object.prototype.hasOwnProperty;
	var shape = {
	    generic: true,
	    types: {},
	    atrules: {},
	    properties: {},
	    parseContext: {},
	    scope: {},
	    atrule: ['parse'],
	    pseudo: ['parse'],
	    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
	};

	function isObject(value) {
	    return value && value.constructor === Object;
	}

	function copy(value) {
	    if (isObject(value)) {
	        return Object.assign({}, value);
	    } else {
	        return value;
	    }
	}
	function extend(dest, src) {
	    for (var key in src) {
	        if (hasOwnProperty$5.call(src, key)) {
	            if (isObject(dest[key])) {
	                extend(dest[key], copy(src[key]));
	            } else {
	                dest[key] = copy(src[key]);
	            }
	        }
	    }
	}

	function mix(dest, src, shape) {
	    for (var key in shape) {
	        if (hasOwnProperty$5.call(shape, key) === false) {
	            continue;
	        }

	        if (shape[key] === true) {
	            if (key in src) {
	                if (hasOwnProperty$5.call(src, key)) {
	                    dest[key] = copy(src[key]);
	                }
	            }
	        } else if (shape[key]) {
	            if (isObject(shape[key])) {
	                var res = {};
	                extend(res, dest[key]);
	                extend(res, src[key]);
	                dest[key] = res;
	            } else if (Array.isArray(shape[key])) {
	                var res = {};
	                var innerShape = shape[key].reduce(function(s, k) {
	                    s[k] = true;
	                    return s;
	                }, {});
	                for (var name in dest[key]) {
	                    if (hasOwnProperty$5.call(dest[key], name)) {
	                        res[name] = {};
	                        if (dest[key] && dest[key][name]) {
	                            mix(res[name], dest[key][name], innerShape);
	                        }
	                    }
	                }
	                for (var name in src[key]) {
	                    if (hasOwnProperty$5.call(src[key], name)) {
	                        if (!res[name]) {
	                            res[name] = {};
	                        }
	                        if (src[key] && src[key][name]) {
	                            mix(res[name], src[key][name], innerShape);
	                        }
	                    }
	                }
	                dest[key] = res;
	            }
	        }
	    }
	    return dest;
	}

	var mix_1 = function(dest, src) {
	    return mix(dest, src, shape);
	};

	function createSyntax(config) {
	    var parse = create$1(config);
	    var walk = create$4(config);
	    var generate = create$2(config);
	    var convert = create$3(walk);

	    var syntax = {
	        List: List_1,
	        SyntaxError: _SyntaxError,
	        TokenStream: TokenStream_1,
	        Lexer: Lexer_1,

	        vendorPrefix: names.vendorPrefix,
	        keyword: names.keyword,
	        property: names.property,
	        isCustomProperty: names.isCustomProperty,

	        definitionSyntax: definitionSyntax,
	        lexer: null,
	        createLexer: function(config) {
	            return new Lexer_1(config, syntax, syntax.lexer.structure);
	        },

	        tokenize: tokenizer,
	        parse: parse,
	        walk: walk,
	        generate: generate,

	        find: walk.find,
	        findLast: walk.findLast,
	        findAll: walk.findAll,

	        clone: clone,
	        fromPlainObject: convert.fromPlainObject,
	        toPlainObject: convert.toPlainObject,

	        createSyntax: function(config) {
	            return createSyntax(mix_1({}, config));
	        },
	        fork: function(extension) {
	            var base = mix_1({}, config); // copy of config
	            return createSyntax(
	                typeof extension === 'function'
	                    ? extension(base, Object.assign)
	                    : mix_1(base, extension)
	            );
	        }
	    };

	    syntax.lexer = new Lexer_1({
	        generic: true,
	        types: config.types,
	        atrules: config.atrules,
	        properties: config.properties,
	        node: config.node
	    }, syntax);

	    return syntax;
	}
	var create_1 = function(config) {
	    return createSyntax(mix_1({}, config));
	};

	var create$5 = {
		create: create_1
	};

	var atRules = {
		"@charset": {
		syntax: "@charset \"<charset>\";",
		groups: [
			"CSS Charsets"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
	},
		"@counter-style": {
		syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
		interfaces: [
			"CSSCounterStyleRule"
		],
		groups: [
			"CSS Counter Styles"
		],
		descriptors: {
			"additive-symbols": {
				syntax: "[ <integer> && <symbol> ]#",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			fallback: {
				syntax: "<counter-style-name>",
				media: "all",
				initial: "decimal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			negative: {
				syntax: "<symbol> <symbol>?",
				media: "all",
				initial: "\"-\" hyphen-minus",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			pad: {
				syntax: "<integer> && <symbol>",
				media: "all",
				initial: "0 \"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			prefix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\"\"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			range: {
				syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"speak-as": {
				syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
				media: "all",
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			suffix: {
				syntax: "<symbol>",
				media: "all",
				initial: "\". \"",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			symbols: {
				syntax: "<symbol>+",
				media: "all",
				initial: "N/A",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			system: {
				syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
				media: "all",
				initial: "symbolic",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
	},
		"@document": {
		syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
	},
		"@font-face": {
		syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
		interfaces: [
			"CSSFontFaceRule"
		],
		groups: [
			"CSS Fonts"
		],
		descriptors: {
			"font-display": {
				syntax: "[ auto | block | swap | fallback | optional ]",
				media: "visual",
				percentages: "no",
				initial: "auto",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			"font-family": {
				syntax: "<family-name>",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-feature-settings": {
				syntax: "normal | <feature-tag-value>#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-variation-settings": {
				syntax: "normal | [ <string> <number> ]#",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"font-stretch": {
				syntax: "<font-stretch-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-style": {
				syntax: "normal | italic | oblique <angle>{0,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-weight": {
				syntax: "<font-weight-absolute>{1,2}",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"font-variant": {
				syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
				media: "all",
				initial: "normal",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			src: {
				syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
				media: "all",
				initial: "n/a (required)",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			},
			"unicode-range": {
				syntax: "<unicode-range>#",
				media: "all",
				initial: "U+0-10FFFF",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
	},
		"@font-feature-values": {
		syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
		interfaces: [
			"CSSFontFeatureValuesRule"
		],
		groups: [
			"CSS Fonts"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
	},
		"@import": {
		syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
		groups: [
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
	},
		"@keyframes": {
		syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
		interfaces: [
			"CSSKeyframeRule",
			"CSSKeyframesRule"
		],
		groups: [
			"CSS Animations"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
	},
		"@media": {
		syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSMediaRule",
			"CSSCustomMediaRule"
		],
		groups: [
			"CSS Conditional Rules",
			"Media Queries"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
	},
		"@namespace": {
		syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
		groups: [
			"CSS Namespaces"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
	},
		"@page": {
		syntax: "@page <page-selector-list> {\n  <page-body>\n}",
		interfaces: [
			"CSSPageRule"
		],
		groups: [
			"CSS Pages"
		],
		descriptors: {
			bleed: {
				syntax: "auto | <length>",
				media: [
					"visual",
					"paged"
				],
				initial: "auto",
				percentages: "no",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "experimental"
			},
			marks: {
				syntax: "none | [ crop || cross ]",
				media: [
					"visual",
					"paged"
				],
				initial: "none",
				percentages: "no",
				computed: "asSpecified",
				order: "orderOfAppearance",
				status: "experimental"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
	},
		"@supports": {
		syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSGroupingRule",
			"CSSConditionRule",
			"CSSSupportsRule"
		],
		groups: [
			"CSS Conditional Rules"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
	},
		"@viewport": {
		syntax: "@viewport {\n  <group-rule-body>\n}",
		interfaces: [
			"CSSViewportRule"
		],
		groups: [
			"CSS Device Adaptation"
		],
		descriptors: {
			height: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-height",
					"max-height"
				],
				percentages: [
					"min-height",
					"max-height"
				],
				computed: [
					"min-height",
					"max-height"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			"max-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"max-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-height": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToHeightOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-width": {
				syntax: "<viewport-length>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToWidthOfInitialViewport",
				computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
				order: "uniqueOrder",
				status: "standard"
			},
			"min-zoom": {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			},
			orientation: {
				syntax: "auto | portrait | landscape",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			"user-zoom": {
				syntax: "zoom | fixed",
				media: [
					"visual",
					"continuous"
				],
				initial: "zoom",
				percentages: "referToSizeOfBoundingBox",
				computed: "asSpecified",
				order: "uniqueOrder",
				status: "standard"
			},
			width: {
				syntax: "<viewport-length>{1,2}",
				media: [
					"visual",
					"continuous"
				],
				initial: [
					"min-width",
					"max-width"
				],
				percentages: [
					"min-width",
					"max-width"
				],
				computed: [
					"min-width",
					"max-width"
				],
				order: "orderOfAppearance",
				status: "standard"
			},
			zoom: {
				syntax: "auto | <number> | <percentage>",
				media: [
					"visual",
					"continuous"
				],
				initial: "auto",
				percentages: "the zoom factor itself",
				computed: "autoNonNegativeOrPercentage",
				order: "uniqueOrder",
				status: "standard"
			}
		},
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
	}
	};

	var atRules$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		'default': atRules
	});

	var all = {
		syntax: "initial | inherit | unset | revert",
		media: "noPracticalMedia",
		inherited: false,
		animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "noPracticalInitialValue",
		appliesto: "allElements",
		computed: "asSpecifiedAppliesToEachProperty",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
	};
	var animation = {
		syntax: "<single-animation>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-iteration-count",
			"animation-direction",
			"animation-fill-mode",
			"animation-play-state"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"animation-name",
			"animation-duration",
			"animation-timing-function",
			"animation-delay",
			"animation-direction",
			"animation-iteration-count",
			"animation-fill-mode",
			"animation-play-state"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
	};
	var appearance = {
		syntax: "none | auto | button | textfield | <compat>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	};
	var azimuth = {
		syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
		media: "aural",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Speech"
		],
		initial: "center",
		appliesto: "allElements",
		computed: "normalizedAngle",
		order: "orderOfAppearance",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
	};
	var background = {
		syntax: "[ <bg-layer> , ]* <final-bg-layer>",
		media: "visual",
		inherited: false,
		animationType: [
			"background-color",
			"background-image",
			"background-clip",
			"background-position",
			"background-size",
			"background-repeat",
			"background-attachment"
		],
		percentages: [
			"background-position",
			"background-size"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		appliesto: "allElements",
		computed: [
			"background-image",
			"background-position",
			"background-size",
			"background-repeat",
			"background-origin",
			"background-clip",
			"background-attachment",
			"background-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
	};
	var border = {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-color",
			"border-style",
			"border-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-width",
			"border-style",
			"border-color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
	};
	var bottom = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
	};
	var clear = {
		syntax: "none | left | right | both | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
	};
	var clip = {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: false,
		animationType: "rectangle",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "absolutelyPositionedElements",
		computed: "autoOrRectangle",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
	};
	var color = {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "variesFromBrowserToBrowser",
		appliesto: "allElements",
		computed: "translucentValuesRGBAOtherwiseRGB",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
	};
	var columns = {
		syntax: "<'column-width'> || <'column-count'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-width",
			"column-count"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-width",
			"column-count"
		],
		appliesto: "blockContainersExceptTableWrappers",
		computed: [
			"column-width",
			"column-count"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
	};
	var contain = {
		syntax: "none | strict | content | [ size || layout || style || paint ]",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Containment"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
	};
	var content = {
		syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "normal",
		appliesto: "beforeAndAfterPseudos",
		computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
	};
	var cursor = {
		syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
	};
	var direction = {
		syntax: "ltr | rtl",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "ltr",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
	};
	var display = {
		syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Display"
		],
		initial: "inline",
		appliesto: "allElements",
		computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
	};
	var filter = {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
	};
	var flex = {
		syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
		media: "visual",
		inherited: false,
		animationType: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		appliesto: "flexItemsAndInFlowPseudos",
		computed: [
			"flex-grow",
			"flex-shrink",
			"flex-basis"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
	};
	var float = {
		syntax: "left | right | none | inline-start | inline-end",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "none",
		appliesto: "allElementsNoEffectIfDisplayNone",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
	};
	var font = {
		syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
		media: "visual",
		inherited: true,
		animationType: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		percentages: [
			"font-size",
			"line-height"
		],
		groups: [
			"CSS Fonts"
		],
		initial: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		appliesto: "allElements",
		computed: [
			"font-style",
			"font-variant",
			"font-weight",
			"font-stretch",
			"font-size",
			"line-height",
			"font-family"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
	};
	var gap = {
		syntax: "<'row-gap'> <'column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"row-gap",
			"column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"row-gap",
			"column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"row-gap",
			"column-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	};
	var grid = {
		syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-auto-rows",
			"grid-auto-columns"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-rows",
			"grid-template-columns",
			"grid-template-areas",
			"grid-auto-rows",
			"grid-auto-columns",
			"grid-auto-flow",
			"grid-column-gap",
			"grid-row-gap",
			"column-gap",
			"row-gap"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
	};
	var height = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAutoOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
	};
	var hyphens = {
		syntax: "none | manual | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "manual",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
	};
	var inset = {
		syntax: "<'top'>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
	};
	var isolation = {
		syntax: "auto | isolate",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
	};
	var left = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
	};
	var margin = {
		syntax: "[ <length> | <percentage> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: [
			"margin-bottom",
			"margin-left",
			"margin-right",
			"margin-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
	};
	var mask = {
		syntax: "<mask-layer>#",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		percentages: [
			"mask-position"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-image",
			"mask-mode",
			"mask-repeat",
			"mask-position",
			"mask-clip",
			"mask-origin",
			"mask-size",
			"mask-composite"
		],
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	};
	var offset = {
		syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		percentages: [
			"offset-position",
			"offset-distance",
			"offset-anchor"
		],
		groups: [
			"CSS Motion Path"
		],
		initial: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		appliesto: "transformableElements",
		computed: [
			"offset-position",
			"offset-path",
			"offset-distance",
			"offset-anchor",
			"offset-rotate"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
	};
	var opacity = {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "1.0",
		appliesto: "allElements",
		computed: "specifiedValueClipped0To1",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
	};
	var order = {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndAbsolutelyPositionedFlexContainerChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
	};
	var orphans = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
	};
	var outline = {
		syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: [
			"outline-color",
			"outline-style",
			"outline-width"
		],
		appliesto: "allElements",
		computed: [
			"outline-color",
			"outline-width",
			"outline-style"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
	};
	var overflow = {
		syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
	};
	var padding = {
		syntax: "[ <length> | <percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: [
			"padding-bottom",
			"padding-left",
			"padding-right",
			"padding-top"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
	};
	var perspective = {
		syntax: "none | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "absoluteLengthOrNone",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
	};
	var position = {
		syntax: "static | relative | absolute | sticky | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "static",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
	};
	var quotes = {
		syntax: "none | auto | [ <string> <string> ]+",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Generated Content"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
	};
	var resize = {
		syntax: "none | both | horizontal | vertical | block | inline",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
	};
	var right = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
	};
	var rotate = {
		syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
	};
	var scale = {
		syntax: "none | <number>{1,3}",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
	};
	var top = {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToContainingBlockHeight",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
	};
	var transform = {
		syntax: "none | <transform-list>",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
	};
	var transition = {
		syntax: "<single-transition>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		appliesto: "allElementsAndPseudos",
		computed: [
			"transition-delay",
			"transition-duration",
			"transition-property",
			"transition-timing-function"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
	};
	var translate = {
		syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
		media: "visual",
		inherited: false,
		animationType: "transform",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
	};
	var visibility = {
		syntax: "visible | hidden | collapse",
		media: "visual",
		inherited: true,
		animationType: "visibility",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "visible",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
	};
	var widows = {
		syntax: "<integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "2",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
	};
	var width = {
		syntax: "[ <length> | <percentage> ] && [ border-box | content-box ]? | available | min-content | max-content | fit-content | auto",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAutoOrAbsoluteLength",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
	};
	var zoom = {
		syntax: "normal | reset | <number> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
	};
	var properties$1 = {
		"--*": {
		syntax: "<declaration-value>",
		media: "all",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Variables"
		],
		initial: "seeProse",
		appliesto: "allElements",
		computed: "asSpecifiedWithVarsSubstituted",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
	},
		"-ms-accelerator": {
		syntax: "false | true",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "false",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
	},
		"-ms-block-progression": {
		syntax: "tb | rl | bt | lr",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "tb",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
	},
		"-ms-content-zoom-chaining": {
		syntax: "none | chained",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
	},
		"-ms-content-zooming": {
		syntax: "none | zoom",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "zoomForTheTopLevelNoneForTheRest",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
	},
		"-ms-content-zoom-limit": {
		syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-limit-max",
			"-ms-content-zoom-limit-min"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
	},
		"-ms-content-zoom-limit-max": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "maxZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "400%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
	},
		"-ms-content-zoom-limit-min": {
		syntax: "<percentage>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "minZoomFactor",
		groups: [
			"Microsoft Extensions"
		],
		initial: "100%",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
	},
		"-ms-content-zoom-snap": {
		syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-content-zoom-snap-type",
			"-ms-content-zoom-snap-points"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
	},
		"-ms-content-zoom-snap-points": {
		syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0%, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
	},
		"-ms-content-zoom-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
	},
		"-ms-filter": {
		syntax: "<string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "\"\"",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
	},
		"-ms-flow-from": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
	},
		"-ms-flow-into": {
		syntax: "[ none | <custom-ident> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "iframeElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
	},
		"-ms-high-contrast-adjust": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
	},
		"-ms-hyphenate-limit-chars": {
		syntax: "auto | <integer>{1,3}",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
	},
		"-ms-hyphenate-limit-lines": {
		syntax: "no-limit | <integer>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "no-limit",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
	},
		"-ms-hyphenate-limit-zone": {
		syntax: "<percentage> | <length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToLineBoxWidth",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
	},
		"-ms-ime-align": {
		syntax: "auto | after",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
	},
		"-ms-overflow-style": {
		syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
	},
		"-ms-scrollbar-3dlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
	},
		"-ms-scrollbar-arrow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ButtonText",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
	},
		"-ms-scrollbar-base-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
	},
		"-ms-scrollbar-darkshadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
	},
		"-ms-scrollbar-face-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDFace",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
	},
		"-ms-scrollbar-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDHighlight",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
	},
		"-ms-scrollbar-shadow-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "ThreeDDarkShadow",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
	},
		"-ms-scrollbar-track-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "Scrollbar",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
	},
		"-ms-scroll-chaining": {
		syntax: "chained | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "chained",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
	},
		"-ms-scroll-limit": {
		syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-limit-x-min",
			"-ms-scroll-limit-y-min",
			"-ms-scroll-limit-x-max",
			"-ms-scroll-limit-y-max"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
	},
		"-ms-scroll-limit-x-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
	},
		"-ms-scroll-limit-x-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
	},
		"-ms-scroll-limit-y-max": {
		syntax: "auto | <length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
	},
		"-ms-scroll-limit-y-min": {
		syntax: "<length>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
	},
		"-ms-scroll-rails": {
		syntax: "none | railed",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "railed",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
	},
		"-ms-scroll-snap-points-x": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
	},
		"-ms-scroll-snap-points-y": {
		syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "snapInterval(0px, 100%)",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
	},
		"-ms-scroll-snap-type": {
		syntax: "none | proximity | mandatory",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
	},
		"-ms-scroll-snap-x": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-x"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
	},
		"-ms-scroll-snap-y": {
		syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: [
			"-ms-scroll-snap-type",
			"-ms-scroll-snap-points-y"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
	},
		"-ms-scroll-translation": {
		syntax: "none | vertical-to-horizontal",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
	},
		"-ms-text-autospace": {
		syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
	},
		"-ms-touch-select": {
		syntax: "grippers | none",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "grippers",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
	},
		"-ms-user-select": {
		syntax: "none | element | text",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "text",
		appliesto: "nonReplacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
	},
		"-ms-wrap-flow": {
		syntax: "auto | both | start | end | maximum | clear",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
	},
		"-ms-wrap-margin": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "0",
		appliesto: "exclusionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
	},
		"-ms-wrap-through": {
		syntax: "wrap | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Microsoft Extensions"
		],
		initial: "wrap",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
	},
		"-moz-appearance": {
		syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-moz-binding": {
		syntax: "<url> | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
	},
		"-moz-border-bottom-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
	},
		"-moz-border-left-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
	},
		"-moz-border-right-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
	},
		"-moz-border-top-colors": {
		syntax: "<color>+ | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
	},
		"-moz-context-properties": {
		syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElementsThatCanReferenceImages",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
	},
		"-moz-float-edge": {
		syntax: "border-box | content-box | margin-box | padding-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "content-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
	},
		"-moz-force-broken-image-icon": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "images",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
	},
		"-moz-image-region": {
		syntax: "<shape> | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "xulImageElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
	},
		"-moz-orient": {
		syntax: "inline | block | horizontal | vertical",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "inline",
		appliesto: "anyElementEffectOnProgressAndMeter",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
	},
		"-moz-outline-radius": {
		syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		percentages: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		groups: [
			"Mozilla Extensions"
		],
		initial: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		appliesto: "allElements",
		computed: [
			"-moz-outline-radius-topleft",
			"-moz-outline-radius-topright",
			"-moz-outline-radius-bottomright",
			"-moz-outline-radius-bottomleft"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
	},
		"-moz-outline-radius-bottomleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
	},
		"-moz-outline-radius-bottomright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
	},
		"-moz-outline-radius-topleft": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
	},
		"-moz-outline-radius-topright": {
		syntax: "<outline-radius>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"Mozilla Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
	},
		"-moz-stack-sizing": {
		syntax: "ignore | stretch-to-fit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "stretch-to-fit",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
	},
		"-moz-text-blink": {
		syntax: "none | blink",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
	},
		"-moz-user-focus": {
		syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
	},
		"-moz-user-input": {
		syntax: "auto | none | enabled | disabled",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
	},
		"-moz-user-modify": {
		syntax: "read-only | read-write | write-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
	},
		"-moz-window-dragging": {
		syntax: "drag | no-drag",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "drag",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
	},
		"-moz-window-shadow": {
		syntax: "default | menu | tooltip | sheet | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "default",
		appliesto: "allElementsCreatingNativeWindows",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
	},
		"-webkit-appearance": {
		syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "noneButOverriddenInUserAgentCSS",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-appearance"
	},
		"-webkit-border-before": {
		syntax: "<'border-width'> || <'border-style'> || <'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: [
			"-webkit-border-before-width"
		],
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"color"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
	},
		"-webkit-border-before-color": {
		syntax: "<'color'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-border-before-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"WebKit Extensions"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"-webkit-box-reflect": {
		syntax: "[ above | below | right | left ]? <length>? <image>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
	},
		"-webkit-line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"WebKit Extensions",
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
	},
		"-webkit-mask": {
		syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-mask-image",
			"-webkit-mask-repeat",
			"-webkit-mask-attachment",
			"-webkit-mask-position",
			"-webkit-mask-origin",
			"-webkit-mask-clip"
		],
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
	},
		"-webkit-mask-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
	},
		"-webkit-mask-clip": {
		syntax: "[ <box> | border | padding | content | text ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "border",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"-webkit-mask-composite": {
		syntax: "<composite-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "source-over",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
	},
		"-webkit-mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteURIOrNone",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"-webkit-mask-origin": {
		syntax: "[ <box> | border | padding | content ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "padding",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"-webkit-mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"-webkit-mask-position-x": {
		syntax: "[ <length-percentage> | left | center | right ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
	},
		"-webkit-mask-position-y": {
		syntax: "[ <length-percentage> | top | center | bottom ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfElement",
		groups: [
			"WebKit Extensions"
		],
		initial: "0%",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
	},
		"-webkit-mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"-webkit-mask-repeat-x": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
	},
		"-webkit-mask-repeat-y": {
		syntax: "repeat | no-repeat | space | round",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "absoluteLengthOrPercentage",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
	},
		"-webkit-mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"-webkit-overflow-scrolling": {
		syntax: "auto | touch",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
	},
		"-webkit-tap-highlight-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "black",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
	},
		"-webkit-text-fill-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
	},
		"-webkit-text-stroke": {
		syntax: "<length> || <color>",
		media: "visual",
		inherited: true,
		animationType: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		appliesto: "allElements",
		computed: [
			"-webkit-text-stroke-width",
			"-webkit-text-stroke-color"
		],
		order: "canonicalOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
	},
		"-webkit-text-stroke-color": {
		syntax: "<color>",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
	},
		"-webkit-text-stroke-width": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "absoluteLength",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
	},
		"-webkit-touch-callout": {
		syntax: "default | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "default",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
	},
		"-webkit-user-modify": {
		syntax: "read-only | read-write | read-write-plaintext-only",
		media: "interactive",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"WebKit Extensions"
		],
		initial: "read-only",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard"
	},
		"align-content": {
		syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
	},
		"align-items": {
		syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
	},
		"align-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
		computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
	},
		all: all,
		animation: animation,
		"animation-delay": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
	},
		"animation-direction": {
		syntax: "<single-animation-direction>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "normal",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
	},
		"animation-duration": {
		syntax: "<time>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
	},
		"animation-fill-mode": {
		syntax: "<single-animation-fill-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
	},
		"animation-iteration-count": {
		syntax: "<single-animation-iteration-count>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "1",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
	},
		"animation-name": {
		syntax: "[ none | <keyframes-name> ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "none",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
	},
		"animation-play-state": {
		syntax: "<single-animation-play-state>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "running",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
	},
		"animation-timing-function": {
		syntax: "<timing-function>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Animations"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
	},
		appearance: appearance,
		"aspect-ratio": {
		syntax: "auto | <ratio>",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
	},
		azimuth: azimuth,
		"backdrop-filter": {
		syntax: "none | <filter-function-list>",
		media: "visual",
		inherited: false,
		animationType: "filterList",
		percentages: "no",
		groups: [
			"Filter Effects"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
	},
		"backface-visibility": {
		syntax: "visible | hidden",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "visible",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
	},
		background: background,
		"background-attachment": {
		syntax: "<attachment>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "scroll",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
	},
		"background-blend-mode": {
		syntax: "<blend-mode>#",
		media: "none",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
	},
		"background-clip": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "border-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
	},
		"background-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "transparent",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
	},
		"background-image": {
		syntax: "<bg-image>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
	},
		"background-origin": {
		syntax: "<box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
	},
		"background-position": {
		syntax: "<bg-position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0% 0%",
		appliesto: "allElements",
		computed: "listEachItemTwoKeywordsOriginOffsets",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
	},
		"background-position-x": {
		syntax: "[ center | [ left | right | x-start | x-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "left",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
	},
		"background-position-y": {
		syntax: "[ center | [ top | bottom | y-start | y-end ]? <length-percentage>? ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "top",
		appliesto: "allElements",
		computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
	},
		"background-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "repeat",
		appliesto: "allElements",
		computed: "listEachItemHasTwoKeywordsOnePerDimension",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
	},
		"background-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "relativeToBackgroundPositioningArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "auto auto",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
	},
		"block-overflow": {
		syntax: "clip | ellipsis | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "clip",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"block-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
	},
		border: border,
		"border-block": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
	},
		"border-block-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
	},
		"border-block-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
	},
		"border-block-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
	},
		"border-block-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
	},
		"border-block-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
	},
		"border-block-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
	},
		"border-block-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
	},
		"border-block-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-block-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
	},
		"border-block-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
	},
		"border-block-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
	},
		"border-block-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
	},
		"border-bottom": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-bottom-style",
			"border-bottom-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-bottom-style",
			"border-bottom-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
	},
		"border-bottom-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
	},
		"border-bottom-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
	},
		"border-bottom-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
	},
		"border-bottom-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
	},
		"border-bottom-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
	},
		"border-collapse": {
		syntax: "collapse | separate",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "separate",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
	},
		"border-color": {
		syntax: "<color>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-color",
			"border-right-color",
			"border-bottom-color",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-color",
			"border-left-color",
			"border-right-color",
			"border-top-color"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
	},
		"border-end-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
	},
		"border-end-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
	},
		"border-image": {
		syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"border-image-slice",
			"border-image-width"
		],
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-image-source",
			"border-image-slice",
			"border-image-width",
			"border-image-outset",
			"border-image-repeat"
		],
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: [
			"border-image-outset",
			"border-image-repeat",
			"border-image-slice",
			"border-image-source",
			"border-image-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
	},
		"border-image-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
	},
		"border-image-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "stretch",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
	},
		"border-image-slice": {
		syntax: "<number-percentage>{1,4} && fill?",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToSizeOfBorderImage",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "100%",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
		order: "percentagesOrLengthsFollowedByFill",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
	},
		"border-image-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
	},
		"border-image-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "referToWidthOrHeightOfBorderImageArea",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "1",
		appliesto: "allElementsExceptTableElementsWhenCollapse",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
	},
		"border-inline": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
	},
		"border-inline-end": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-end-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
	},
		"border-inline-color": {
		syntax: "<'border-top-color'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
	},
		"border-inline-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
	},
		"border-inline-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
	},
		"border-inline-end-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
	},
		"border-inline-end-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
	},
		"border-inline-end-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
	},
		"border-inline-start": {
		syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: [
			"border-width",
			"border-style",
			"color"
		],
		appliesto: "allElements",
		computed: [
			"border-width",
			"border-style",
			"border-inline-start-color"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
	},
		"border-inline-start-color": {
		syntax: "<'border-top-color'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
	},
		"border-inline-start-style": {
		syntax: "<'border-top-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Logical Properties"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
	},
		"border-inline-start-width": {
		syntax: "<'border-top-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
	},
		"border-left": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-left-color",
			"border-left-style",
			"border-left-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		appliesto: "allElements",
		computed: [
			"border-left-width",
			"border-left-style",
			"border-left-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
	},
		"border-left-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
	},
		"border-left-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
	},
		"border-left-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
	},
		"border-radius": {
		syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-left-radius",
			"border-top-right-radius",
			"border-bottom-right-radius",
			"border-bottom-left-radius"
		],
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: [
			"border-bottom-left-radius",
			"border-bottom-right-radius",
			"border-top-left-radius",
			"border-top-right-radius"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
	},
		"border-right": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-right-color",
			"border-right-style",
			"border-right-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		appliesto: "allElements",
		computed: [
			"border-right-width",
			"border-right-style",
			"border-right-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
	},
		"border-right-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
	},
		"border-right-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
	},
		"border-right-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
	},
		"border-spacing": {
		syntax: "<length> <length>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "0",
		appliesto: "tableElements",
		computed: "twoAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
	},
		"border-start-end-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
	},
		"border-start-start-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
	},
		"border-style": {
		syntax: "<line-style>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-style",
			"border-right-style",
			"border-bottom-style",
			"border-left-style"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-style",
			"border-left-style",
			"border-right-style",
			"border-top-style"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
	},
		"border-top": {
		syntax: "<line-width> || <line-style> || <color>",
		media: "visual",
		inherited: false,
		animationType: [
			"border-top-color",
			"border-top-style",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		appliesto: "allElements",
		computed: [
			"border-top-width",
			"border-top-style",
			"border-top-color"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
	},
		"border-top-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
	},
		"border-top-left-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
	},
		"border-top-right-radius": {
		syntax: "<length-percentage>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfBorderBox",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "0",
		appliesto: "allElementsUAsNotRequiredWhenCollapse",
		computed: "twoAbsoluteLengthOrPercentages",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
	},
		"border-top-style": {
		syntax: "<line-style>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
	},
		"border-top-width": {
		syntax: "<line-width>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
	},
		"border-width": {
		syntax: "<line-width>{1,4}",
		media: "visual",
		inherited: false,
		animationType: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: [
			"border-top-width",
			"border-right-width",
			"border-bottom-width",
			"border-left-width"
		],
		appliesto: "allElements",
		computed: [
			"border-bottom-width",
			"border-left-width",
			"border-right-width",
			"border-top-width"
		],
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
	},
		bottom: bottom,
		"box-align": {
		syntax: "start | center | end | baseline | stretch",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "stretch",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
	},
		"box-decoration-break": {
		syntax: "slice | clone",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "slice",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
	},
		"box-direction": {
		syntax: "normal | reverse | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "normal",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
	},
		"box-flex": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "0",
		appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
	},
		"box-flex-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "inFlowChildrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
	},
		"box-lines": {
		syntax: "single | multiple",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "single",
		appliesto: "boxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
	},
		"box-ordinal-group": {
		syntax: "<integer>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "1",
		appliesto: "childrenOfBoxElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
	},
		"box-orient": {
		syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "inlineAxisHorizontalInXUL",
		appliesto: "elementsWithDisplayBoxOrInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
	},
		"box-pack": {
		syntax: "start | center | end | justify",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions",
			"WebKit Extensions"
		],
		initial: "start",
		appliesto: "elementsWithDisplayMozBoxMozInlineBox",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
	},
		"box-shadow": {
		syntax: "none | <shadow>#",
		media: "visual",
		inherited: false,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Backgrounds and Borders"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "absoluteLengthsSpecifiedColorAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
	},
		"box-sizing": {
		syntax: "content-box | border-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "content-box",
		appliesto: "allElementsAcceptingWidthOrHeight",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
	},
		"break-after": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
	},
		"break-before": {
		syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
	},
		"break-inside": {
		syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fragmentation"
		],
		initial: "auto",
		appliesto: "blockLevelElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
	},
		"caption-side": {
		syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "top",
		appliesto: "tableCaptionElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
	},
		"caret-color": {
		syntax: "auto | <color>",
		media: "interactive",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asAutoOrColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
	},
		clear: clear,
		clip: clip,
		"clip-path": {
		syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
	},
		color: color,
		"color-adjust": {
		syntax: "economy | exact",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Color"
		],
		initial: "economy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
	},
		"column-count": {
		syntax: "<integer> | auto",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
	},
		"column-fill": {
		syntax: "auto | balance | balance-all",
		media: "visualInContinuousMediaNoEffectInOverflowColumns",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "balance",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
	},
		"column-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"column-rule": {
		syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: [
			"column-rule-width",
			"column-rule-style",
			"column-rule-color"
		],
		appliesto: "multicolElements",
		computed: [
			"column-rule-color",
			"column-rule-style",
			"column-rule-width"
		],
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
	},
		"column-rule-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "currentcolor",
		appliesto: "multicolElements",
		computed: "computedColor",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
	},
		"column-rule-style": {
		syntax: "<'border-style'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "multicolElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
	},
		"column-rule-width": {
		syntax: "<'border-width'>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "medium",
		appliesto: "multicolElements",
		computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
	},
		"column-span": {
		syntax: "none | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "none",
		appliesto: "inFlowBlockLevelElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
	},
		"column-width": {
		syntax: "<length> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Columns"
		],
		initial: "auto",
		appliesto: "blockContainersExceptTableWrappers",
		computed: "absoluteLengthZeroOrLarger",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
	},
		columns: columns,
		contain: contain,
		content: content,
		"counter-increment": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
	},
		"counter-reset": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
	},
		"counter-set": {
		syntax: "[ <custom-ident> <integer>? ]+ | none",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Counter Styles"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
	},
		cursor: cursor,
		direction: direction,
		display: display,
		"empty-cells": {
		syntax: "show | hide",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "show",
		appliesto: "tableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
	},
		filter: filter,
		flex: flex,
		"flex-basis": {
		syntax: "content | <'width'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToFlexContainersInnerMainSize",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "auto",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "lengthOrPercentageBeforeKeywordIfBothPresent",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
	},
		"flex-direction": {
		syntax: "row | row-reverse | column | column-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "row",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
	},
		"flex-flow": {
		syntax: "<'flex-direction'> || <'flex-wrap'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: [
			"flex-direction",
			"flex-wrap"
		],
		appliesto: "flexContainers",
		computed: [
			"flex-direction",
			"flex-wrap"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
	},
		"flex-grow": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "0",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
	},
		"flex-shrink": {
		syntax: "<number>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "1",
		appliesto: "flexItemsAndInFlowPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
	},
		"flex-wrap": {
		syntax: "nowrap | wrap | wrap-reverse",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Flexible Box Layout"
		],
		initial: "nowrap",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
	},
		float: float,
		font: font,
		"font-family": {
		syntax: "[ <family-name> | <generic-family> ]#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "dependsOnUserAgent",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
	},
		"font-feature-settings": {
		syntax: "normal | <feature-tag-value>#",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
	},
		"font-kerning": {
		syntax: "auto | normal | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
	},
		"font-language-override": {
		syntax: "normal | <string>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
	},
		"font-optical-sizing": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
	},
		"font-variation-settings": {
		syntax: "normal | [ <string> <number> ]#",
		media: "visual",
		inherited: true,
		animationType: "transform",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
	},
		"font-size": {
		syntax: "<absolute-size> | <relative-size> | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToParentElementsFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
	},
		"font-size-adjust": {
		syntax: "none | <number>",
		media: "visual",
		inherited: true,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
	},
		"font-stretch": {
		syntax: "<font-stretch-absolute>",
		media: "visual",
		inherited: true,
		animationType: "fontStretch",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
	},
		"font-style": {
		syntax: "normal | italic | oblique <angle>?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
	},
		"font-synthesis": {
		syntax: "none | [ weight || style ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "weight style",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
	},
		"font-variant": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
	},
		"font-variant-alternates": {
		syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
	},
		"font-variant-caps": {
		syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
	},
		"font-variant-east-asian": {
		syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
	},
		"font-variant-ligatures": {
		syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
	},
		"font-variant-numeric": {
		syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
	},
		"font-variant-position": {
		syntax: "normal | sub | super",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
	},
		"font-weight": {
		syntax: "<font-weight-absolute> | bolder | lighter",
		media: "visual",
		inherited: true,
		animationType: "fontWeight",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
	},
		gap: gap,
		grid: grid,
		"grid-area": {
		syntax: "<grid-line> [ / <grid-line> ]{0,3}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-column-start",
			"grid-row-end",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
	},
		"grid-auto-columns": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
	},
		"grid-auto-flow": {
		syntax: "[ row | column ] || dense",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "row",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
	},
		"grid-auto-rows": {
		syntax: "<track-size>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
	},
		"grid-column": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-column-start",
			"grid-column-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-column-start",
			"grid-column-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
	},
		"grid-column-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
	},
		"grid-column-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
	},
		"grid-column-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
	},
		"grid-gap": {
		syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
		media: "visual",
		inherited: false,
		animationType: [
			"grid-row-gap",
			"grid-column-gap"
		],
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-gap",
			"grid-column-gap"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-row-gap",
			"grid-column-gap"
		],
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
	},
		"grid-row": {
		syntax: "<grid-line> [ / <grid-line> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-row-start",
			"grid-row-end"
		],
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: [
			"grid-row-start",
			"grid-row-end"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
	},
		"grid-row-end": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
	},
		"grid-row-gap": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "0",
		appliesto: "gridContainers",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"grid-row-start": {
		syntax: "<grid-line>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "auto",
		appliesto: "gridItemsAndBoxesWithinGridContainer",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
	},
		"grid-template": {
		syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: [
			"grid-template-columns",
			"grid-template-rows"
		],
		groups: [
			"CSS Grid Layout"
		],
		initial: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		appliesto: "gridContainers",
		computed: [
			"grid-template-columns",
			"grid-template-rows",
			"grid-template-areas"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
	},
		"grid-template-areas": {
		syntax: "none | <string>+",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
	},
		"grid-template-columns": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
	},
		"grid-template-rows": {
		syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpcDifferenceLpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Grid Layout"
		],
		initial: "none",
		appliesto: "gridContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
	},
		"hanging-punctuation": {
		syntax: "none | [ first || [ force-end | allow-end ] || last ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
	},
		height: height,
		hyphens: hyphens,
		"image-orientation": {
		syntax: "from-image | <angle> | [ <angle>? flip ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "0deg",
		appliesto: "allElements",
		computed: "angleRoundedToNextQuarter",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
	},
		"image-rendering": {
		syntax: "auto | crisp-edges | pixelated",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
	},
		"image-resolution": {
		syntax: "[ from-image || <resolution> ] && snap?",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "1dppx",
		appliesto: "allElements",
		computed: "asSpecifiedWithExceptionOfResolution",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ime-mode": {
		syntax: "auto | normal | active | inactive | disabled",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "textFields",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
	},
		"initial-letter": {
		syntax: "normal | [ <number> <integer>? ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "normal",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
	},
		"initial-letter-align": {
		syntax: "[ auto | alphabetic | hanging | ideographic ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Inline"
		],
		initial: "auto",
		appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
	},
		"inline-size": {
		syntax: "<'width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsWidthAndHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
	},
		inset: inset,
		"inset-block": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
	},
		"inset-block-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
	},
		"inset-block-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalHeightOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
	},
		"inset-inline": {
		syntax: "<'top'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
	},
		"inset-inline-end": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
	},
		"inset-inline-start": {
		syntax: "<'top'>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "sameAsBoxOffsets",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
	},
		isolation: isolation,
		"justify-content": {
		syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "flexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
	},
		"justify-items": {
		syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "legacy",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
	},
		"justify-self": {
		syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "auto",
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
	},
		left: left,
		"letter-spacing": {
		syntax: "normal | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumValueOfAbsoluteLengthOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
	},
		"line-break": {
		syntax: "auto | loose | normal | strict | anywhere",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
	},
		"line-clamp": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"line-height": {
		syntax: "normal | <number> | <length> | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "numberOrLength",
		percentages: "referToElementFontSize",
		groups: [
			"CSS Fonts"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "absoluteLengthOrAsSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
	},
		"line-height-step": {
		syntax: "<length>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Fonts"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "absoluteLength",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
	},
		"list-style": {
		syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: [
			"list-style-type",
			"list-style-position",
			"list-style-image"
		],
		appliesto: "listItems",
		computed: [
			"list-style-image",
			"list-style-position",
			"list-style-type"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
	},
		"list-style-image": {
		syntax: "<url> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "none",
		appliesto: "listItems",
		computed: "noneOrImageWithAbsoluteURI",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
	},
		"list-style-position": {
		syntax: "inside | outside",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "outside",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
	},
		"list-style-type": {
		syntax: "<counter-style> | <string> | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Lists and Counters"
		],
		initial: "disc",
		appliesto: "listItems",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
	},
		margin: margin,
		"margin-block": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
	},
		"margin-block-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
	},
		"margin-block-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
	},
		"margin-bottom": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
	},
		"margin-inline": {
		syntax: "<'margin-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
	},
		"margin-inline-end": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
	},
		"margin-inline-start": {
		syntax: "<'margin-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "dependsOnLayoutModel",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsMargin",
		computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
	},
		"margin-left": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
	},
		"margin-right": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
	},
		"margin-top": {
		syntax: "<length> | <percentage> | auto",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
	},
		mask: mask,
		"mask-border": {
		syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
		media: "visual",
		inherited: false,
		animationType: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		percentages: [
			"mask-border-slice",
			"mask-border-width"
		],
		groups: [
			"CSS Masking"
		],
		initial: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		appliesto: "allElementsSVGContainerElements",
		computed: [
			"mask-border-mode",
			"mask-border-outset",
			"mask-border-repeat",
			"mask-border-slice",
			"mask-border-source",
			"mask-border-width"
		],
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
	},
		"mask-border-mode": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "alpha",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
	},
		"mask-border-outset": {
		syntax: "[ <length> | <number> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
	},
		"mask-border-repeat": {
		syntax: "[ stretch | repeat | round | space ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "stretch",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
	},
		"mask-border-slice": {
		syntax: "<number-percentage>{1,4} fill?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "referToSizeOfMaskBorderImage",
		groups: [
			"CSS Masking"
		],
		initial: "0",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
	},
		"mask-border-source": {
		syntax: "none | <image>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
	},
		"mask-border-width": {
		syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToMaskBorderImageArea",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
	},
		"mask-clip": {
		syntax: "[ <geometry-box> | no-clip ]#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
	},
		"mask-composite": {
		syntax: "<compositing-operator>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "add",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
	},
		"mask-image": {
		syntax: "<mask-reference>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "none",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedURLsAbsolute",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
	},
		"mask-mode": {
		syntax: "<masking-mode>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "match-source",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
	},
		"mask-origin": {
		syntax: "<geometry-box>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "border-box",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
	},
		"mask-position": {
		syntax: "<position>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToSizeOfMaskPaintingArea",
		groups: [
			"CSS Masking"
		],
		initial: "center",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoKeywordsForOriginAndOffsets",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
	},
		"mask-repeat": {
		syntax: "<repeat-style>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "no-repeat",
		appliesto: "allElementsSVGContainerElements",
		computed: "consistsOfTwoDimensionKeywords",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
	},
		"mask-size": {
		syntax: "<bg-size>#",
		media: "visual",
		inherited: false,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "auto",
		appliesto: "allElementsSVGContainerElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
	},
		"mask-type": {
		syntax: "luminance | alpha",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Masking"
		],
		initial: "luminance",
		appliesto: "maskElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
	},
		"max-block-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
	},
		"max-height": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
	},
		"max-inline-size": {
		syntax: "<'max-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMaxWidthAndMaxHeight",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
	},
		"max-lines": {
		syntax: "none | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "none",
		appliesto: "blockContainersExceptMultiColumnContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"max-width": {
		syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "none",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
	},
		"min-block-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "blockSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
	},
		"min-height": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableColumns",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
	},
		"min-inline-size": {
		syntax: "<'min-width'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "inlineSizeOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "sameAsWidthAndHeight",
		computed: "sameAsMinWidthAndMinHeight",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
	},
		"min-width": {
		syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "allElementsButNonReplacedAndTableRows",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
	},
		"mix-blend-mode": {
		syntax: "<blend-mode>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Compositing and Blending"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
	},
		"object-fit": {
		syntax: "fill | contain | cover | none | scale-down",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Images"
		],
		initial: "fill",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
	},
		"object-position": {
		syntax: "<position>",
		media: "visual",
		inherited: true,
		animationType: "repeatableListOfSimpleListOfLpc",
		percentages: "referToWidthAndHeightOfElement",
		groups: [
			"CSS Images"
		],
		initial: "50% 50%",
		appliesto: "replacedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
	},
		offset: offset,
		"offset-anchor": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "relativeToWidthAndHeight",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-distance": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToTotalPathLength",
		groups: [
			"CSS Motion Path"
		],
		initial: "0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
	},
		"offset-path": {
		syntax: "none | ray( [ <angle> && <size>? && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "none",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		stacking: true,
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
	},
		"offset-position": {
		syntax: "auto | <position>",
		media: "visual",
		inherited: false,
		animationType: "position",
		percentages: "referToSizeOfContainingBlock",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "perGrammar",
		status: "experimental"
	},
		"offset-rotate": {
		syntax: "[ auto | reverse ] || <angle>",
		media: "visual",
		inherited: false,
		animationType: "angleOrBasicShapeOrPath",
		percentages: "no",
		groups: [
			"CSS Motion Path"
		],
		initial: "auto",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
	},
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		"outline-color": {
		syntax: "<color> | invert",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "invertOrCurrentColor",
		appliesto: "allElements",
		computed: "invertForTranslucentColorRGBAOtherwiseRGB",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
	},
		"outline-offset": {
		syntax: "<length>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
	},
		"outline-style": {
		syntax: "auto | <'border-style'>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
	},
		"outline-width": {
		syntax: "<line-width>",
		media: [
			"visual",
			"interactive"
		],
		inherited: false,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "medium",
		appliesto: "allElements",
		computed: "absoluteLength0ForNone",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
	},
		overflow: overflow,
		"overflow-anchor": {
		syntax: "auto | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Anchoring"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-block": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-clip-box": {
		syntax: "padding-box | content-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Mozilla Extensions"
		],
		initial: "padding-box",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
	},
		"overflow-inline": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "auto",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "experimental"
	},
		"overflow-wrap": {
		syntax: "normal | break-word | anywhere",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"overflow-x": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
	},
		"overflow-y": {
		syntax: "visible | hidden | clip | scroll | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Overflow"
		],
		initial: "visible",
		appliesto: "blockContainersFlexContainersGridContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
	},
		"overscroll-behavior": {
		syntax: "[ contain | none | auto ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
	},
		"overscroll-behavior-x": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
	},
		"overscroll-behavior-y": {
		syntax: "contain | none | auto",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Model"
		],
		initial: "auto",
		appliesto: "nonReplacedBlockAndInlineBlockElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
	},
		padding: padding,
		"padding-block": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
	},
		"padding-block-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
	},
		"padding-block-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
	},
		"padding-bottom": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
	},
		"padding-inline": {
		syntax: "<'padding-left'>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
	},
		"padding-inline-end": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
	},
		"padding-inline-start": {
		syntax: "<'padding-left'>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "logicalWidthOfContainingBlock",
		groups: [
			"CSS Logical Properties"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
	},
		"padding-left": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
	},
		"padding-right": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
	},
		"padding-top": {
		syntax: "<length> | <percentage>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Box Model"
		],
		initial: "0",
		appliesto: "allElementsExceptInternalTableDisplayTypes",
		computed: "percentageAsSpecifiedOrAbsoluteLength",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
	},
		"page-break-after": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
	},
		"page-break-before": {
		syntax: "auto | always | avoid | left | right | recto | verso",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
	},
		"page-break-inside": {
		syntax: "auto | avoid",
		media: [
			"visual",
			"paged"
		],
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Pages"
		],
		initial: "auto",
		appliesto: "blockElementsInNormalFlow",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
	},
		"paint-order": {
		syntax: "normal | [ fill || stroke || markers ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
	},
		perspective: perspective,
		"perspective-origin": {
		syntax: "<position>",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50%",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
	},
		"place-content": {
		syntax: "<'align-content'> <'justify-content'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multilineFlexContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
	},
		"place-items": {
		syntax: "<'align-items'> <'justify-items'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-items",
			"justify-items"
		],
		appliesto: "allElements",
		computed: [
			"align-items",
			"justify-items"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
	},
		"place-self": {
		syntax: "<'align-self'> <'justify-self'>?",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Box Alignment"
		],
		initial: [
			"align-self",
			"justify-self"
		],
		appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
		computed: [
			"align-self",
			"justify-self"
		],
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
	},
		"pointer-events": {
		syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
	},
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		"row-gap": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToDimensionOfContentArea",
		groups: [
			"CSS Box Alignment"
		],
		initial: "normal",
		appliesto: "multiColumnElementsFlexContainersGridContainers",
		computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
	},
		"ruby-align": {
		syntax: "start | center | space-between | space-around",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "space-around",
		appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
	},
		"ruby-merge": {
		syntax: "separate | collapse | auto",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "separate",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental"
	},
		"ruby-position": {
		syntax: "over | under | inter-character",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Ruby"
		],
		initial: "over",
		appliesto: "rubyAnnotationsContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
	},
		scale: scale,
		"scrollbar-color": {
		syntax: "auto | dark | light | <color>{2}",
		media: "visual",
		inherited: true,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
	},
		"scrollbar-width": {
		syntax: "auto | thin | none",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scrollbars"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
	},
		"scroll-behavior": {
		syntax: "auto | smooth",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSSOM View"
		],
		initial: "auto",
		appliesto: "scrollingBoxes",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
	},
		"scroll-margin": {
		syntax: "<length>{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
	},
		"scroll-margin-block": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
	},
		"scroll-margin-block-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
	},
		"scroll-margin-block-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
	},
		"scroll-margin-bottom": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
	},
		"scroll-margin-inline": {
		syntax: "<length>{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
	},
		"scroll-margin-inline-start": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
	},
		"scroll-margin-inline-end": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
	},
		"scroll-margin-left": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
	},
		"scroll-margin-right": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
	},
		"scroll-margin-top": {
		syntax: "<length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
	},
		"scroll-padding": {
		syntax: "[ auto | <length-percentage> ]{1,4}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
	},
		"scroll-padding-block": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
	},
		"scroll-padding-block-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
	},
		"scroll-padding-block-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
	},
		"scroll-padding-bottom": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
	},
		"scroll-padding-inline": {
		syntax: "[ auto | <length-percentage> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
	},
		"scroll-padding-inline-start": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
	},
		"scroll-padding-inline-end": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
	},
		"scroll-padding-left": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
	},
		"scroll-padding-right": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
	},
		"scroll-padding-top": {
		syntax: "auto | <length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "relativeToTheScrollContainersScrollport",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "auto",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
	},
		"scroll-snap-align": {
		syntax: "[ none | start | end | center ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
	},
		"scroll-snap-coordinate": {
		syntax: "none | <position>#",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "referToBorderBox",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
	},
		"scroll-snap-destination": {
		syntax: "<position>",
		media: "interactive",
		inherited: false,
		animationType: "position",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "0px 0px",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
	},
		"scroll-snap-points-x": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
	},
		"scroll-snap-points-y": {
		syntax: "none | repeat( <length-percentage> )",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "relativeToScrollContainerPaddingBoxAxis",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
	},
		"scroll-snap-stop": {
		syntax: "normal | always",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "perGrammar",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
	},
		"scroll-snap-type": {
		syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
	},
		"scroll-snap-type-x": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
	},
		"scroll-snap-type-y": {
		syntax: "none | mandatory | proximity",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Scroll Snap"
		],
		initial: "none",
		appliesto: "scrollContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "obsolete",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
	},
		"shape-image-threshold": {
		syntax: "<alpha-value>",
		media: "visual",
		inherited: false,
		animationType: "number",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "0.0",
		appliesto: "floats",
		computed: "specifiedValueNumberClipped0To1",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
	},
		"shape-margin": {
		syntax: "<length-percentage>",
		media: "visual",
		inherited: false,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Shapes"
		],
		initial: "0",
		appliesto: "floats",
		computed: "asSpecifiedRelativeToAbsoluteLengths",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
	},
		"shape-outside": {
		syntax: "none | <shape-box> || <basic-shape> | <image>",
		media: "visual",
		inherited: false,
		animationType: "basicShapeOtherwiseNo",
		percentages: "no",
		groups: [
			"CSS Shapes"
		],
		initial: "none",
		appliesto: "floats",
		computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
	},
		"tab-size": {
		syntax: "<integer> | <length>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "8",
		appliesto: "blockContainers",
		computed: "specifiedIntegerOrAbsoluteLength",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
	},
		"table-layout": {
		syntax: "auto | fixed",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Table"
		],
		initial: "auto",
		appliesto: "tableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
	},
		"text-align": {
		syntax: "start | end | left | right | center | justify | match-parent",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "startOrNamelessValueIfLTRRightIfRTL",
		appliesto: "blockContainers",
		computed: "asSpecifiedExceptMatchParent",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
	},
		"text-align-last": {
		syntax: "auto | start | end | left | right | center | justify",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "blockContainers",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
	},
		"text-combine-upright": {
		syntax: "none | all | [ digits <integer>? ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "none",
		appliesto: "nonReplacedInlineElements",
		computed: "keywordPlusIntegerIfDigits",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
	},
		"text-decoration": {
		syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line",
			"text-decoration-thickness"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-decoration-color",
			"text-decoration-style",
			"text-decoration-line"
		],
		appliesto: "allElements",
		computed: [
			"text-decoration-line",
			"text-decoration-style",
			"text-decoration-color",
			"text-decoration-thickness"
		],
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
	},
		"text-decoration-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
	},
		"text-decoration-line": {
		syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
	},
		"text-decoration-skip": {
		syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "objects",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
	},
		"text-decoration-skip-ink": {
		syntax: "auto | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
	},
		"text-decoration-style": {
		syntax: "solid | double | dotted | dashed | wavy",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "solid",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
	},
		"text-decoration-thickness": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: false,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
	},
		"text-emphasis": {
		syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
		media: "visual",
		inherited: false,
		animationType: [
			"text-emphasis-color",
			"text-emphasis-style"
		],
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		appliesto: "allElements",
		computed: [
			"text-emphasis-style",
			"text-emphasis-color"
		],
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
	},
		"text-emphasis-color": {
		syntax: "<color>",
		media: "visual",
		inherited: false,
		animationType: "color",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "currentcolor",
		appliesto: "allElements",
		computed: "computedColor",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
	},
		"text-emphasis-position": {
		syntax: "[ over | under ] && [ right | left ]",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "over right",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
	},
		"text-emphasis-style": {
		syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
	},
		"text-indent": {
		syntax: "<length-percentage> && hanging? && each-line?",
		media: "visual",
		inherited: true,
		animationType: "lpc",
		percentages: "referToWidthOfContainingBlock",
		groups: [
			"CSS Text"
		],
		initial: "0",
		appliesto: "blockContainers",
		computed: "percentageOrAbsoluteLengthPlusKeywords",
		order: "lengthOrPercentageBeforeKeywords",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
	},
		"text-justify": {
		syntax: "auto | inter-character | inter-word | none",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "auto",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
	},
		"text-orientation": {
		syntax: "mixed | upright | sideways",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "mixed",
		appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
	},
		"text-overflow": {
		syntax: "[ clip | ellipsis | <string> ]{1,2}",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "clip",
		appliesto: "blockContainerElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
	},
		"text-rendering": {
		syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Miscellaneous"
		],
		initial: "auto",
		appliesto: "textElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
	},
		"text-shadow": {
		syntax: "none | <shadow-t>#",
		media: "visual",
		inherited: true,
		animationType: "shadowList",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "colorPlusThreeAbsoluteLengths",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
	},
		"text-size-adjust": {
		syntax: "none | auto | <percentage>",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "referToSizeOfFont",
		groups: [
			"CSS Text"
		],
		initial: "autoForSmartphoneBrowsersSupportingInflation",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "experimental",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
	},
		"text-transform": {
		syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "none",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
	},
		"text-underline-offset": {
		syntax: "auto | from-font | <length>",
		media: "visual",
		inherited: true,
		animationType: "byComputedValueType",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
	},
		"text-underline-position": {
		syntax: "auto | [ under || [ left | right ] ]",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text Decoration"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "orderOfAppearance",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
	},
		top: top,
		"touch-action": {
		syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"Pointer Events"
		],
		initial: "auto",
		appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
	},
		transform: transform,
		"transform-box": {
		syntax: "border-box | fill-box | view-box",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "border-box ",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
	},
		"transform-origin": {
		syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
		media: "visual",
		inherited: false,
		animationType: "simpleListOfLpc",
		percentages: "referToSizeOfBoundingBox",
		groups: [
			"CSS Transforms"
		],
		initial: "50% 50% 0",
		appliesto: "transformableElements",
		computed: "forLengthAbsoluteValueOtherwisePercentage",
		order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
	},
		"transform-style": {
		syntax: "flat | preserve-3d",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transforms"
		],
		initial: "flat",
		appliesto: "transformableElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
	},
		transition: transition,
		"transition-delay": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
	},
		"transition-duration": {
		syntax: "<time>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "0s",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
	},
		"transition-property": {
		syntax: "none | <single-transition-property>#",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "all",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
	},
		"transition-timing-function": {
		syntax: "<timing-function>#",
		media: "interactive",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Transitions"
		],
		initial: "ease",
		appliesto: "allElementsAndPseudos",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
	},
		translate: translate,
		"unicode-bidi": {
		syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "normal",
		appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
	},
		"user-select": {
		syntax: "auto | text | none | contain | all",
		media: "visual",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Basic User Interface"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "nonstandard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
	},
		"vertical-align": {
		syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
		media: "visual",
		inherited: false,
		animationType: "length",
		percentages: "referToLineHeight",
		groups: [
			"CSS Table"
		],
		initial: "baseline",
		appliesto: "inlineLevelAndTableCellElements",
		computed: "absoluteLengthOrKeyword",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
	},
		visibility: visibility,
		"white-space": {
		syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
	},
		widows: widows,
		width: width,
		"will-change": {
		syntax: "auto | <animateable-feature>#",
		media: "all",
		inherited: false,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Will Change"
		],
		initial: "auto",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
	},
		"word-break": {
		syntax: "normal | break-all | keep-all | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
	},
		"word-spacing": {
		syntax: "normal | <length-percentage>",
		media: "visual",
		inherited: true,
		animationType: "length",
		percentages: "referToWidthOfAffectedGlyph",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "allElements",
		computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
		order: "uniqueOrder",
		alsoAppliesTo: [
			"::first-letter",
			"::first-line",
			"::placeholder"
		],
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
	},
		"word-wrap": {
		syntax: "normal | break-word",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Text"
		],
		initial: "normal",
		appliesto: "nonReplacedInlineElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
	},
		"writing-mode": {
		syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
		media: "visual",
		inherited: true,
		animationType: "discrete",
		percentages: "no",
		groups: [
			"CSS Writing Modes"
		],
		initial: "horizontal-tb",
		appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
		computed: "asSpecified",
		order: "uniqueOrder",
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
	},
		"z-index": {
		syntax: "auto | <integer>",
		media: "visual",
		inherited: false,
		animationType: "integer",
		percentages: "no",
		groups: [
			"CSS Positioning"
		],
		initial: "auto",
		appliesto: "positionedElements",
		computed: "asSpecified",
		order: "uniqueOrder",
		stacking: true,
		status: "standard",
		mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
	},
		zoom: zoom
	};

	var properties$2 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		all: all,
		animation: animation,
		appearance: appearance,
		azimuth: azimuth,
		background: background,
		border: border,
		bottom: bottom,
		clear: clear,
		clip: clip,
		color: color,
		columns: columns,
		contain: contain,
		content: content,
		cursor: cursor,
		direction: direction,
		display: display,
		filter: filter,
		flex: flex,
		float: float,
		font: font,
		gap: gap,
		grid: grid,
		height: height,
		hyphens: hyphens,
		inset: inset,
		isolation: isolation,
		left: left,
		margin: margin,
		mask: mask,
		offset: offset,
		opacity: opacity,
		order: order,
		orphans: orphans,
		outline: outline,
		overflow: overflow,
		padding: padding,
		perspective: perspective,
		position: position,
		quotes: quotes,
		resize: resize,
		right: right,
		rotate: rotate,
		scale: scale,
		top: top,
		transform: transform,
		transition: transition,
		translate: translate,
		visibility: visibility,
		widows: widows,
		width: width,
		zoom: zoom,
		'default': properties$1
	});

	var attachment = {
		syntax: "scroll | fixed | local"
	};
	var box = {
		syntax: "border-box | padding-box | content-box"
	};
	var color$1 = {
		syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
	};
	var combinator = {
		syntax: "'>' | '+' | '~' | [ '||' ]"
	};
	var compat = {
		syntax: "searchfield | textarea | push-button | button-bevel | slider-horizontal | checkbox | radio | square-button | menulist | menulist-button | listbox | meter | progress-bar"
	};
	var gradient = {
		syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
	};
	var hue = {
		syntax: "<number> | <angle>"
	};
	var image = {
		syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
	};
	var nth = {
		syntax: "<an-plus-b> | even | odd"
	};
	var position$1 = {
		syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
	};
	var quote = {
		syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
	};
	var shadow = {
		syntax: "inset? && <length>{2,4} && <color>?"
	};
	var shape$1 = {
		syntax: "rect(<top>, <right>, <bottom>, <left>)"
	};
	var size = {
		syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
	};
	var symbol = {
		syntax: "<string> | <image> | <custom-ident>"
	};
	var target = {
		syntax: "<target-counter()> | <target-counters()> | <target-text()>"
	};
	var syntaxes = {
		"absolute-size": {
		syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
	},
		"alpha-value": {
		syntax: "<number> | <percentage>"
	},
		"angle-percentage": {
		syntax: "<angle> | <percentage>"
	},
		"angular-color-hint": {
		syntax: "<angle-percentage>"
	},
		"angular-color-stop": {
		syntax: "<color> && <color-stop-angle>?"
	},
		"angular-color-stop-list": {
		syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
	},
		"animateable-feature": {
		syntax: "scroll-position | contents | <custom-ident>"
	},
		attachment: attachment,
		"attr()": {
		syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
	},
		"attr-matcher": {
		syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
	},
		"attr-modifier": {
		syntax: "i | s"
	},
		"attribute-selector": {
		syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
	},
		"auto-repeat": {
		syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"auto-track-list": {
		syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
	},
		"baseline-position": {
		syntax: "[ first | last ]? baseline"
	},
		"basic-shape": {
		syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()>"
	},
		"bg-image": {
		syntax: "none | <image>"
	},
		"bg-layer": {
		syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"bg-position": {
		syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
	},
		"bg-size": {
		syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
	},
		"blur()": {
		syntax: "blur( <length> )"
	},
		"blend-mode": {
		syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
	},
		box: box,
		"brightness()": {
		syntax: "brightness( <number-percentage> )"
	},
		"calc()": {
		syntax: "calc( <calc-sum> )"
	},
		"calc-sum": {
		syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
	},
		"calc-product": {
		syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
	},
		"calc-value": {
		syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
	},
		"cf-final-image": {
		syntax: "<image> | <color>"
	},
		"cf-mixing-image": {
		syntax: "<percentage>? && <image>"
	},
		"circle()": {
		syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
	},
		"clamp()": {
		syntax: "clamp( <calc-sum>#{3} )"
	},
		"class-selector": {
		syntax: "'.' <ident-token>"
	},
		"clip-source": {
		syntax: "<url>"
	},
		color: color$1,
		"color-stop": {
		syntax: "<color-stop-length> | <color-stop-angle>"
	},
		"color-stop-angle": {
		syntax: "<angle-percentage>{1,2}"
	},
		"color-stop-length": {
		syntax: "<length-percentage>{1,2}"
	},
		"color-stop-list": {
		syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
	},
		combinator: combinator,
		"common-lig-values": {
		syntax: "[ common-ligatures | no-common-ligatures ]"
	},
		compat: compat,
		"composite-style": {
		syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
	},
		"compositing-operator": {
		syntax: "add | subtract | intersect | exclude"
	},
		"compound-selector": {
		syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
	},
		"compound-selector-list": {
		syntax: "<compound-selector>#"
	},
		"complex-selector": {
		syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
	},
		"complex-selector-list": {
		syntax: "<complex-selector>#"
	},
		"conic-gradient()": {
		syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
	},
		"contextual-alt-values": {
		syntax: "[ contextual | no-contextual ]"
	},
		"content-distribution": {
		syntax: "space-between | space-around | space-evenly | stretch"
	},
		"content-list": {
		syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
	},
		"content-position": {
		syntax: "center | start | end | flex-start | flex-end"
	},
		"content-replacement": {
		syntax: "<image>"
	},
		"contrast()": {
		syntax: "contrast( [ <number-percentage> ] )"
	},
		"counter()": {
		syntax: "counter( <custom-ident>, <counter-style>? )"
	},
		"counter-style": {
		syntax: "<counter-style-name> | symbols()"
	},
		"counter-style-name": {
		syntax: "<custom-ident>"
	},
		"counters()": {
		syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
	},
		"cross-fade()": {
		syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
	},
		"cubic-bezier-timing-function": {
		syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number>, <number>, <number>, <number>)"
	},
		"deprecated-system-color": {
		syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
	},
		"discretionary-lig-values": {
		syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
	},
		"display-box": {
		syntax: "contents | none"
	},
		"display-inside": {
		syntax: "flow | flow-root | table | flex | grid | ruby"
	},
		"display-internal": {
		syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
	},
		"display-legacy": {
		syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
	},
		"display-listitem": {
		syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
	},
		"display-outside": {
		syntax: "block | inline | run-in"
	},
		"drop-shadow()": {
		syntax: "drop-shadow( <length>{2,3} <color>? )"
	},
		"east-asian-variant-values": {
		syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
	},
		"east-asian-width-values": {
		syntax: "[ full-width | proportional-width ]"
	},
		"element()": {
		syntax: "element( <id-selector> )"
	},
		"ellipse()": {
		syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
	},
		"ending-shape": {
		syntax: "circle | ellipse"
	},
		"env()": {
		syntax: "env( <custom-ident> , <declaration-value>? )"
	},
		"explicit-track-list": {
		syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
	},
		"family-name": {
		syntax: "<string> | <custom-ident>+"
	},
		"feature-tag-value": {
		syntax: "<string> [ <integer> | on | off ]?"
	},
		"feature-type": {
		syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
	},
		"feature-value-block": {
		syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
	},
		"feature-value-block-list": {
		syntax: "<feature-value-block>+"
	},
		"feature-value-declaration": {
		syntax: "<custom-ident>: <integer>+;"
	},
		"feature-value-declaration-list": {
		syntax: "<feature-value-declaration>"
	},
		"feature-value-name": {
		syntax: "<custom-ident>"
	},
		"fill-rule": {
		syntax: "nonzero | evenodd"
	},
		"filter-function": {
		syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
	},
		"filter-function-list": {
		syntax: "[ <filter-function> | <url> ]+"
	},
		"final-bg-layer": {
		syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
	},
		"fit-content()": {
		syntax: "fit-content( [ <length> | <percentage> ] )"
	},
		"fixed-breadth": {
		syntax: "<length-percentage>"
	},
		"fixed-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
	},
		"fixed-size": {
		syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
	},
		"font-stretch-absolute": {
		syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
	},
		"font-variant-css21": {
		syntax: "[ normal | small-caps ]"
	},
		"font-weight-absolute": {
		syntax: "normal | bold | <number>"
	},
		"frequency-percentage": {
		syntax: "<frequency> | <percentage>"
	},
		"general-enclosed": {
		syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
	},
		"generic-family": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"generic-name": {
		syntax: "serif | sans-serif | cursive | fantasy | monospace"
	},
		"geometry-box": {
		syntax: "<shape-box> | fill-box | stroke-box | view-box"
	},
		gradient: gradient,
		"grayscale()": {
		syntax: "grayscale( <number-percentage> )"
	},
		"grid-line": {
		syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
	},
		"historical-lig-values": {
		syntax: "[ historical-ligatures | no-historical-ligatures ]"
	},
		"hsl()": {
		syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		"hsla()": {
		syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
	},
		hue: hue,
		"hue-rotate()": {
		syntax: "hue-rotate( <angle> )"
	},
		"id-selector": {
		syntax: "<hash-token>"
	},
		image: image,
		"image()": {
		syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
	},
		"image-set()": {
		syntax: "image-set( <image-set-option># )"
	},
		"image-set-option": {
		syntax: "[ <image> | <string> ] <resolution>"
	},
		"image-src": {
		syntax: "<url> | <string>"
	},
		"image-tags": {
		syntax: "ltr | rtl"
	},
		"inflexible-breadth": {
		syntax: "<length> | <percentage> | min-content | max-content | auto"
	},
		"inset()": {
		syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
	},
		"invert()": {
		syntax: "invert( <number-percentage> )"
	},
		"keyframes-name": {
		syntax: "<custom-ident> | <string>"
	},
		"keyframe-block": {
		syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
	},
		"keyframe-block-list": {
		syntax: "<keyframe-block>+"
	},
		"keyframe-selector": {
		syntax: "from | to | <percentage>"
	},
		"leader()": {
		syntax: "leader( <leader-type> )"
	},
		"leader-type": {
		syntax: "dotted | solid | space | <string>"
	},
		"length-percentage": {
		syntax: "<length> | <percentage>"
	},
		"line-names": {
		syntax: "'[' <custom-ident>* ']'"
	},
		"line-name-list": {
		syntax: "[ <line-names> | <name-repeat> ]+"
	},
		"line-style": {
		syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
	},
		"line-width": {
		syntax: "<length> | thin | medium | thick"
	},
		"linear-color-hint": {
		syntax: "<length-percentage>"
	},
		"linear-color-stop": {
		syntax: "<color> <color-stop-length>?"
	},
		"linear-gradient()": {
		syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"mask-layer": {
		syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
	},
		"mask-position": {
		syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
	},
		"mask-reference": {
		syntax: "none | <image> | <mask-source>"
	},
		"mask-source": {
		syntax: "<url>"
	},
		"masking-mode": {
		syntax: "alpha | luminance | match-source"
	},
		"matrix()": {
		syntax: "matrix( <number>#{6} )"
	},
		"matrix3d()": {
		syntax: "matrix3d( <number>#{16} )"
	},
		"max()": {
		syntax: "max( <calc-sum># )"
	},
		"media-and": {
		syntax: "<media-in-parens> [ and <media-in-parens> ]+"
	},
		"media-condition": {
		syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
	},
		"media-condition-without-or": {
		syntax: "<media-not> | <media-and> | <media-in-parens>"
	},
		"media-feature": {
		syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
	},
		"media-in-parens": {
		syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
	},
		"media-not": {
		syntax: "not <media-in-parens>"
	},
		"media-or": {
		syntax: "<media-in-parens> [ or <media-in-parens> ]+"
	},
		"media-query": {
		syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
	},
		"media-query-list": {
		syntax: "<media-query>#"
	},
		"media-type": {
		syntax: "<ident>"
	},
		"mf-boolean": {
		syntax: "<mf-name>"
	},
		"mf-name": {
		syntax: "<ident>"
	},
		"mf-plain": {
		syntax: "<mf-name> : <mf-value>"
	},
		"mf-range": {
		syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
	},
		"mf-value": {
		syntax: "<number> | <dimension> | <ident> | <ratio>"
	},
		"min()": {
		syntax: "min( <calc-sum># )"
	},
		"minmax()": {
		syntax: "minmax( [ <length> | <percentage> | <flex> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
	},
		"named-color": {
		syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
	},
		"namespace-prefix": {
		syntax: "<ident>"
	},
		"ns-prefix": {
		syntax: "[ <ident-token> | '*' ]? '|'"
	},
		"number-percentage": {
		syntax: "<number> | <percentage>"
	},
		"numeric-figure-values": {
		syntax: "[ lining-nums | oldstyle-nums ]"
	},
		"numeric-fraction-values": {
		syntax: "[ diagonal-fractions | stacked-fractions ]"
	},
		"numeric-spacing-values": {
		syntax: "[ proportional-nums | tabular-nums ]"
	},
		nth: nth,
		"opacity()": {
		syntax: "opacity( [ <number-percentage> ] )"
	},
		"overflow-position": {
		syntax: "unsafe | safe"
	},
		"outline-radius": {
		syntax: "<length> | <percentage>"
	},
		"page-body": {
		syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
	},
		"page-margin-box": {
		syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
	},
		"page-margin-box-type": {
		syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
	},
		"page-selector-list": {
		syntax: "[ <page-selector># ]?"
	},
		"page-selector": {
		syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
	},
		"paint()": {
		syntax: "paint( <ident>, <declaration-value>? )"
	},
		"perspective()": {
		syntax: "perspective( <length> )"
	},
		"polygon()": {
		syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
	},
		position: position$1,
		"pseudo-class-selector": {
		syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
	},
		"pseudo-element-selector": {
		syntax: "':' <pseudo-class-selector>"
	},
		"pseudo-page": {
		syntax: ": [ left | right | first | blank ]"
	},
		quote: quote,
		"radial-gradient()": {
		syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"relative-selector": {
		syntax: "<combinator>? <complex-selector>"
	},
		"relative-selector-list": {
		syntax: "<relative-selector>#"
	},
		"relative-size": {
		syntax: "larger | smaller"
	},
		"repeat-style": {
		syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
	},
		"repeating-linear-gradient()": {
		syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
	},
		"repeating-radial-gradient()": {
		syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
	},
		"rgb()": {
		syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
	},
		"rgba()": {
		syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
	},
		"rotate()": {
		syntax: "rotate( [ <angle> | <zero> ] )"
	},
		"rotate3d()": {
		syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
	},
		"rotateX()": {
		syntax: "rotateX( [ <angle> | <zero> ] )"
	},
		"rotateY()": {
		syntax: "rotateY( [ <angle> | <zero> ] )"
	},
		"rotateZ()": {
		syntax: "rotateZ( [ <angle> | <zero> ] )"
	},
		"saturate()": {
		syntax: "saturate( <number-percentage> )"
	},
		"scale()": {
		syntax: "scale( <number> , <number>? )"
	},
		"scale3d()": {
		syntax: "scale3d( <number> , <number> , <number> )"
	},
		"scaleX()": {
		syntax: "scaleX( <number> )"
	},
		"scaleY()": {
		syntax: "scaleY( <number> )"
	},
		"scaleZ()": {
		syntax: "scaleZ( <number> )"
	},
		"self-position": {
		syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
	},
		"shape-radius": {
		syntax: "<length-percentage> | closest-side | farthest-side"
	},
		"skew()": {
		syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
	},
		"skewX()": {
		syntax: "skewX( [ <angle> | <zero> ] )"
	},
		"skewY()": {
		syntax: "skewY( [ <angle> | <zero> ] )"
	},
		"sepia()": {
		syntax: "sepia( <number-percentage> )"
	},
		shadow: shadow,
		"shadow-t": {
		syntax: "[ <length>{2,3} && <color>? ]"
	},
		shape: shape$1,
		"shape-box": {
		syntax: "<box> | margin-box"
	},
		"side-or-corner": {
		syntax: "[ left | right ] || [ top | bottom ]"
	},
		"single-animation": {
		syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
	},
		"single-animation-direction": {
		syntax: "normal | reverse | alternate | alternate-reverse"
	},
		"single-animation-fill-mode": {
		syntax: "none | forwards | backwards | both"
	},
		"single-animation-iteration-count": {
		syntax: "infinite | <number>"
	},
		"single-animation-play-state": {
		syntax: "running | paused"
	},
		"single-transition": {
		syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
	},
		"single-transition-property": {
		syntax: "all | <custom-ident>"
	},
		size: size,
		"step-position": {
		syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
	},
		"step-timing-function": {
		syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
	},
		"subclass-selector": {
		syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
	},
		"supports-condition": {
		syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
	},
		"supports-in-parens": {
		syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
	},
		"supports-feature": {
		syntax: "<supports-decl> | <supports-selector-fn>"
	},
		"supports-decl": {
		syntax: "( <declaration> )"
	},
		"supports-selector-fn": {
		syntax: "selector( <complex-selector> )"
	},
		symbol: symbol,
		target: target,
		"target-counter()": {
		syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
	},
		"target-counters()": {
		syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
	},
		"target-text()": {
		syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
	},
		"time-percentage": {
		syntax: "<time> | <percentage>"
	},
		"timing-function": {
		syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
	},
		"track-breadth": {
		syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
	},
		"track-list": {
		syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
	},
		"track-repeat": {
		syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
	},
		"track-size": {
		syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
	},
		"transform-function": {
		syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
	},
		"transform-list": {
		syntax: "<transform-function>+"
	},
		"translate()": {
		syntax: "translate( <length-percentage> , <length-percentage>? )"
	},
		"translate3d()": {
		syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
	},
		"translateX()": {
		syntax: "translateX( <length-percentage> )"
	},
		"translateY()": {
		syntax: "translateY( <length-percentage> )"
	},
		"translateZ()": {
		syntax: "translateZ( <length> )"
	},
		"type-or-unit": {
		syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
	},
		"type-selector": {
		syntax: "<wq-name> | <ns-prefix>? '*'"
	},
		"var()": {
		syntax: "var( <custom-property-name> , <declaration-value>? )"
	},
		"viewport-length": {
		syntax: "auto | <length-percentage>"
	},
		"wq-name": {
		syntax: "<ns-prefix>? <ident-token>"
	}
	};

	var syntaxes$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		attachment: attachment,
		box: box,
		color: color$1,
		combinator: combinator,
		compat: compat,
		gradient: gradient,
		hue: hue,
		image: image,
		nth: nth,
		position: position$1,
		quote: quote,
		shadow: shadow,
		shape: shape$1,
		size: size,
		symbol: symbol,
		target: target,
		'default': syntaxes
	});

	var properties$3 = {
		"-moz-background-clip": {
			comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "padding | border"
		},
		"-moz-border-radius-bottomleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
			syntax: "<'border-bottom-left-radius'>"
		},
		"-moz-border-radius-bottomright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-border-radius-topleft": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
			syntax: "<'border-top-left-radius'>"
		},
		"-moz-border-radius-topright": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
			syntax: "<'border-bottom-right-radius'>"
		},
		"-moz-control-character-visibility": {
			comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
			syntax: "visible | hidden"
		},
		"-moz-osx-font-smoothing": {
			comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | grayscale"
		},
		"-moz-user-select": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "none | text | all | -moz-none"
		},
		"-ms-flex-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "start | end | center | baseline | stretch"
		},
		"-ms-flex-item-align": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
			syntax: "auto | start | end | center | baseline | stretch"
		},
		"-ms-flex-line-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
			syntax: "start | end | center | justify | distribute | stretch"
		},
		"-ms-flex-negative": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-shrink'>"
		},
		"-ms-flex-pack": {
			comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
			syntax: "start | end | center | justify | distribute"
		},
		"-ms-flex-order": {
			comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
			syntax: "<integer>"
		},
		"-ms-flex-positive": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-grow'>"
		},
		"-ms-flex-preferred-size": {
			comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
			syntax: "<'flex-basis'>"
		},
		"-ms-interpolation-mode": {
			comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
			syntax: "nearest-neighbor | bicubic"
		},
		"-ms-grid-column-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-columns": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-columns",
			syntax: "<track-list-v0>"
		},
		"-ms-grid-row-align": {
			comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
			syntax: "start | end | center | stretch"
		},
		"-ms-grid-rows": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/2012/WD-css3-grid-layout-20120322/#grid-rows",
			syntax: "<track-list-v0>"
		},
		"-ms-hyphenate-limit-last": {
			comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
			syntax: "none | always | column | page | spread"
		},
		"-webkit-appearance": {
			comment: "webkit specific keywords",
			references: [
				"http://css-infos.net/property/-webkit-appearance"
			],
			syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | listbox | listitem | media-fullscreen-button | media-mute-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield"
		},
		"-webkit-background-clip": {
			comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
			syntax: "[ <box> | border | padding | content | text ]#"
		},
		"-webkit-column-break-after": {
			comment: "added, http://help.dottoro.com/lcrthhhv.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-before": {
			comment: "added, http://help.dottoro.com/lcxquvkf.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-column-break-inside": {
			comment: "added, http://help.dottoro.com/lclhnthl.php",
			syntax: "always | auto | avoid"
		},
		"-webkit-font-smoothing": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
			syntax: "auto | none | antialiased | subpixel-antialiased"
		},
		"-webkit-mask-box-image": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
		},
		"-webkit-print-color-adjust": {
			comment: "missed",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
			],
			syntax: "economy | exact"
		},
		"-webkit-text-security": {
			comment: "missed; http://help.dottoro.com/lcbkewgt.php",
			syntax: "none | circle | disc | square"
		},
		"-webkit-user-drag": {
			comment: "missed; http://help.dottoro.com/lcbixvwm.php",
			syntax: "none | element | auto"
		},
		"-webkit-user-select": {
			comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
			syntax: "auto | none | text | all"
		},
		"alignment-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
			],
			syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
		},
		"baseline-shift": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
			],
			syntax: "baseline | sub | super | <svg-length>"
		},
		behavior: {
			comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
			syntax: "<url>+"
		},
		"clip-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
			],
			syntax: "nonzero | evenodd"
		},
		cue: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'cue-before'> <'cue-after'>?"
		},
		"cue-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		"cue-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<url> <decibel>? | none"
		},
		cursor: {
			comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
			references: [
				"https://www.sitepoint.com/css3-cursor-styles/"
			],
			syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
		},
		display: {
			comment: "extended with -ms-flexbox",
			syntax: "block | contents | flex | flow | flow-root | grid | inline | inline-block | inline-flex | inline-grid | inline-list-item | inline-table | list-item | none | ruby | ruby-base | ruby-base-container | ruby-text | ruby-text-container | run-in | table | table-caption | table-cell | table-column | table-column-group | table-footer-group | table-header-group | table-row | table-row-group | -ms-flexbox | -ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
		},
		position: {
			comment: "extended with -webkit-sticky",
			syntax: "static | relative | absolute | sticky | fixed | -webkit-sticky"
		},
		"dominant-baseline": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
			],
			syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
		},
		"image-rendering": {
			comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
				"https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
			],
			syntax: "auto | crisp-edges | pixelated | optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
		},
		fill: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<paint>"
		},
		"fill-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "<number-zero-one>"
		},
		"fill-rule": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#FillProperty"
			],
			syntax: "nonzero | evenodd"
		},
		filter: {
			comment: "extend with IE legacy syntaxes",
			syntax: "none | <filter-function-list> | <-ms-filter-function-list>"
		},
		"glyph-orientation-horizontal": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
			],
			syntax: "<angle>"
		},
		"glyph-orientation-vertical": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
			],
			syntax: "<angle>"
		},
		kerning: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#KerningProperty"
			],
			syntax: "auto | <svg-length>"
		},
		"letter-spacing": {
			comment: "fix syntax <length> -> <length-percentage>",
			references: [
				"https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
			],
			syntax: "normal | <length-percentage>"
		},
		marker: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-end": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-mid": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"marker-start": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
			],
			syntax: "none | <url>"
		},
		"max-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
			syntax: "<length> | <percentage> | none | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		"min-width": {
			comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "<length> | <percentage> | auto | max-content | min-content | fit-content | fill-available | <-non-standard-width>"
		},
		opacity: {
			comment: "strict to 0..1 <number> -> <number-zero-one>",
			syntax: "<number-zero-one>"
		},
		overflow: {
			comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "[ visible | hidden | clip | scroll | auto ]{1,2} | <-non-standard-overflow>"
		},
		pause: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'pause-before'> <'pause-after'>?"
		},
		"pause-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"pause-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		rest: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<'rest-before'> <'rest-after'>?"
		},
		"rest-after": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"rest-before": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
		},
		"shape-rendering": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
			],
			syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
		},
		src: {
			comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
			syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
		},
		speak: {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | none | normal"
		},
		"speak-as": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
		},
		stroke: {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<paint>"
		},
		"stroke-dasharray": {
			comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "none | [ <svg-length>+ ]#"
		},
		"stroke-dashoffset": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"stroke-linecap": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "butt | round | square"
		},
		"stroke-linejoin": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "miter | round | bevel"
		},
		"stroke-miterlimit": {
			comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-one-or-greater>"
		},
		"stroke-opacity": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<number-zero-one>"
		},
		"stroke-width": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
			],
			syntax: "<svg-length>"
		},
		"text-anchor": {
			comment: "added SVG property",
			references: [
				"https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
			],
			syntax: "start | middle | end"
		},
		"unicode-bidi": {
			comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
			syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext | -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate"
		},
		"unicode-range": {
			comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
			syntax: "<urange>#"
		},
		"voice-balance": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<number> | left | center | right | leftwards | rightwards"
		},
		"voice-duration": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "auto | <time>"
		},
		"voice-family": {
			comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
		},
		"voice-pitch": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-range": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
		},
		"voice-rate": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
		},
		"voice-stress": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "normal | strong | moderate | none | reduced"
		},
		"voice-volume": {
			comment: "https://www.w3.org/TR/css3-speech/#property-index",
			syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
		},
		"writing-mode": {
			comment: "extend with SVG keywords",
			syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr | <svg-writing-mode>"
		}
	};
	var syntaxes$2 = {
		"-legacy-gradient": {
			comment: "added collection of legacy gradient syntaxes",
			syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
		},
		"-legacy-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-repeating-linear-gradient": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
		},
		"-legacy-linear-gradient-arguments": {
			comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
			syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
		},
		"-legacy-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-repeating-radial-gradient": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
		},
		"-legacy-radial-gradient-arguments": {
			comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
			syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
		},
		"-legacy-radial-gradient-size": {
			comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
			syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
		},
		"-legacy-radial-gradient-shape": {
			comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
			syntax: "circle | ellipse"
		},
		"-non-standard-font": {
			comment: "non standard fonts",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
		},
		"-non-standard-color": {
			comment: "non standard colors",
			references: [
				"http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
				"https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
			],
			syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
		},
		"-non-standard-image-rendering": {
			comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
			syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
		},
		"-non-standard-overflow": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
			syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
		},
		"-non-standard-width": {
			comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
			syntax: "min-intrinsic | intrinsic | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
		},
		"-webkit-gradient()": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
			syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
		},
		"-webkit-gradient-color-stop": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
		},
		"-webkit-gradient-point": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
		},
		"-webkit-gradient-radius": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "<length> | <percentage>"
		},
		"-webkit-gradient-type": {
			comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
			syntax: "linear | radial"
		},
		"-webkit-mask-box-repeat": {
			comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
			syntax: "repeat | stretch | round"
		},
		"-webkit-mask-clip-style": {
			comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
			syntax: "border | border-box | padding | padding-box | content | content-box | text"
		},
		"-ms-filter-function-list": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function>+"
		},
		"-ms-filter-function": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
		},
		"-ms-filter-function-progid": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
		},
		"-ms-filter-function-legacy": {
			comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
			syntax: "<ident-token> | <function-token> <any-value>? )"
		},
		"-ms-filter": {
			syntax: "<string>"
		},
		age: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "child | young | old"
		},
		"attr-name": {
			syntax: "<wq-name>"
		},
		"attr-fallback": {
			syntax: "<any-value>"
		},
		"border-radius": {
			comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
			syntax: "<length-percentage>{1,2}"
		},
		bottom: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"content-list": {
			comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
			syntax: "[ <string> | contents | <url> | <quote> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
		},
		"generic-voice": {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "[ <age>? <gender> <integer>? ]"
		},
		gender: {
			comment: "https://www.w3.org/TR/css3-speech/#voice-family",
			syntax: "male | female | neutral"
		},
		"generic-family": {
			comment: "added -apple-system",
			references: [
				"https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
			],
			syntax: "serif | sans-serif | cursive | fantasy | monospace | -apple-system"
		},
		gradient: {
			comment: "added legacy syntaxes support",
			syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <-legacy-gradient>"
		},
		left: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"mask-image": {
			comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
			syntax: "<mask-reference>#"
		},
		"name-repeat": {
			comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
			syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
		},
		"named-color": {
			comment: "added non standard color names",
			syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen | <-non-standard-color>"
		},
		paint: {
			comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
			syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
		},
		"path()": {
			comment: "missed, `motion` property was renamed, but left it as is for now; path() syntax was get from last draft https://drafts.fxtf.org/motion-1/#funcdef-offset-path-path",
			syntax: "path( <string> )"
		},
		ratio: {
			comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
			syntax: "<integer> / <integer>"
		},
		right: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		shape: {
			comment: "missed spaces in function body and add backwards compatible syntax",
			syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
		},
		"svg-length": {
			comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
			references: [
				"https://www.w3.org/TR/SVG11/coords.html#Units"
			],
			syntax: "<percentage> | <length> | <number>"
		},
		"svg-writing-mode": {
			comment: "SVG specific keywords (deprecated for CSS)",
			references: [
				"https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
				"https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
			],
			syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
		},
		top: {
			comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
			syntax: "<length> | auto"
		},
		"track-group": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
		},
		"track-list-v0": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "[ <string>* <track-group> <string>* ]+ | none"
		},
		"track-minmax": {
			comment: "used by old grid-columns and grid-rows syntax v0",
			syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
		},
		x: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		y: {
			comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
			syntax: "<number>"
		},
		declaration: {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
		},
		"declaration-list": {
			comment: "missed, restored by https://drafts.csswg.org/css-syntax",
			syntax: "[ <declaration>? ';' ]* <declaration>?"
		},
		url: {
			comment: "https://drafts.csswg.org/css-values-4/#urls",
			syntax: "url( <string> <url-modifier>* ) | <url-token>"
		},
		"url-modifier": {
			comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
			syntax: "<ident> | <function-token> <any-value> )"
		},
		"number-zero-one": {
			syntax: "<number [0,1]>"
		},
		"number-one-or-greater": {
			syntax: "<number [1,∞]>"
		},
		"positive-integer": {
			syntax: "<integer [0,∞]>"
		}
	};
	var patch = {
		properties: properties$3,
		syntaxes: syntaxes$2
	};

	var patch$1 = /*#__PURE__*/Object.freeze({
		__proto__: null,
		properties: properties$3,
		syntaxes: syntaxes$2,
		'default': patch
	});

	var mdnAtrules = getCjsExportFromNamespace(atRules$1);

	var mdnProperties = getCjsExportFromNamespace(properties$2);

	var mdnSyntaxes = getCjsExportFromNamespace(syntaxes$1);

	var patch$2 = getCjsExportFromNamespace(patch$1);

	function preprocessAtrules(dict) {
	    var result = Object.create(null);

	    for (var atruleName in dict) {
	        var atrule = dict[atruleName];
	        var descriptors = null;

	        if (atrule.descriptors) {
	            descriptors = Object.create(null);

	            for (var descriptor in atrule.descriptors) {
	                descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
	            }
	        }

	        result[atruleName.substr(1)] = {
	            prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
	            descriptors
	        };
	    }

	    return result;
	}

	function buildDictionary(dict, patchDict) {
	    var result = {};

	    // copy all syntaxes for an original dict
	    for (var key in dict) {
	        result[key] = dict[key].syntax;
	    }

	    // apply a patch
	    for (var key in patchDict) {
	        if (key in dict) {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            } else {
	                delete result[key];
	            }
	        } else {
	            if (patchDict[key].syntax) {
	                result[key] = patchDict[key].syntax;
	            }
	        }
	    }

	    return result;
	}

	var data = {
	    types: buildDictionary(mdnSyntaxes, patch$2.syntaxes),
	    atrules: preprocessAtrules(mdnAtrules),
	    properties: buildDictionary(mdnProperties, patch$2.properties)
	};

	var cmpChar$3 = tokenizer.cmpChar;
	var isDigit$4 = tokenizer.isDigit;
	var TYPE$9 = tokenizer.TYPE;

	var WHITESPACE$4 = TYPE$9.WhiteSpace;
	var COMMENT$3 = TYPE$9.Comment;
	var IDENT$3 = TYPE$9.Ident;
	var NUMBER$3 = TYPE$9.Number;
	var DIMENSION$2 = TYPE$9.Dimension;
	var PLUSSIGN$3 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$3 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var N$4 = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
	var DISALLOW_SIGN$1 = true;
	var ALLOW_SIGN$1 = false;

	function checkInteger$1(offset, disallowSign) {
	    var pos = this.scanner.tokenStart + offset;
	    var code = this.scanner.source.charCodeAt(pos);

	    if (code === PLUSSIGN$3 || code === HYPHENMINUS$3) {
	        if (disallowSign) {
	            this.error('Number sign is not allowed');
	        }
	        pos++;
	    }

	    for (; pos < this.scanner.tokenEnd; pos++) {
	        if (!isDigit$4(this.scanner.source.charCodeAt(pos))) {
	            this.error('Integer is expected', pos);
	        }
	    }
	}

	function checkTokenIsInteger(disallowSign) {
	    return checkInteger$1.call(this, 0, disallowSign);
	}

	function expectCharCode(offset, code) {
	    if (!cmpChar$3(this.scanner.source, this.scanner.tokenStart + offset, code)) {
	        var msg = '';

	        switch (code) {
	            case N$4:
	                msg = 'N is expected';
	                break;
	            case HYPHENMINUS$3:
	                msg = 'HyphenMinus is expected';
	                break;
	        }

	        this.error(msg, this.scanner.tokenStart + offset);
	    }
	}

	// ... <signed-integer>
	// ... ['+' | '-'] <signless-integer>
	function consumeB$1() {
	    var offset = 0;
	    var sign = 0;
	    var type = this.scanner.tokenType;

	    while (type === WHITESPACE$4 || type === COMMENT$3) {
	        type = this.scanner.lookupType(++offset);
	    }

	    if (type !== NUMBER$3) {
	        if (this.scanner.isDelim(PLUSSIGN$3, offset) ||
	            this.scanner.isDelim(HYPHENMINUS$3, offset)) {
	            sign = this.scanner.isDelim(PLUSSIGN$3, offset) ? PLUSSIGN$3 : HYPHENMINUS$3;

	            do {
	                type = this.scanner.lookupType(++offset);
	            } while (type === WHITESPACE$4 || type === COMMENT$3);

	            if (type !== NUMBER$3) {
	                this.scanner.skip(offset);
	                checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	            }
	        } else {
	            return null;
	        }
	    }

	    if (offset > 0) {
	        this.scanner.skip(offset);
	    }

	    if (sign === 0) {
	        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	        if (type !== PLUSSIGN$3 && type !== HYPHENMINUS$3) {
	            this.error('Number sign is expected');
	        }
	    }

	    checkTokenIsInteger.call(this, sign !== 0);
	    return sign === HYPHENMINUS$3 ? '-' + this.consume(NUMBER$3) : this.consume(NUMBER$3);
	}

	// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
	var AnPlusB = {
	    name: 'AnPlusB',
	    structure: {
	        a: [String, null],
	        b: [String, null]
	    },
	    parse: function() {
	        /* eslint-disable brace-style*/
	        var start = this.scanner.tokenStart;
	        var a = null;
	        var b = null;

	        // <integer>
	        if (this.scanner.tokenType === NUMBER$3) {
	            checkTokenIsInteger.call(this, ALLOW_SIGN$1);
	            b = this.consume(NUMBER$3);
	        }

	        // -n
	        // -n <signed-integer>
	        // -n ['+' | '-'] <signless-integer>
	        // -n- <signless-integer>
	        // <dashndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 && cmpChar$3(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS$3)) {
	            a = '-1';

	            expectCharCode.call(this, 1, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // -n
	                // -n <signed-integer>
	                // -n ['+' | '-'] <signless-integer>
	                case 2:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // -n- <signless-integer>
	                case 3:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // <dashndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 2, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 3, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + 2);
	            }
	        }

	        // '+'? n
	        // '+'? n <signed-integer>
	        // '+'? n ['+' | '-'] <signless-integer>
	        // '+'? n- <signless-integer>
	        // '+'? <ndashdigit-ident>
	        else if (this.scanner.tokenType === IDENT$3 || (this.scanner.isDelim(PLUSSIGN$3) && this.scanner.lookupType(1) === IDENT$3)) {
	            var sign = 0;
	            a = '1';

	            // just ignore a plus
	            if (this.scanner.isDelim(PLUSSIGN$3)) {
	                sign = 1;
	                this.scanner.next();
	            }

	            expectCharCode.call(this, 0, N$4);

	            switch (this.scanner.getTokenLength()) {
	                // '+'? n
	                // '+'? n <signed-integer>
	                // '+'? n ['+' | '-'] <signless-integer>
	                case 1:
	                    this.scanner.next();
	                    b = consumeB$1.call(this);
	                    break;

	                // '+'? n- <signless-integer>
	                case 2:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);

	                    this.scanner.next();
	                    this.scanner.skipSC();

	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);

	                    b = '-' + this.consume(NUMBER$3);
	                    break;

	                // '+'? <ndashdigit-ident>
	                default:
	                    expectCharCode.call(this, 1, HYPHENMINUS$3);
	                    checkInteger$1.call(this, 2, DISALLOW_SIGN$1);
	                    this.scanner.next();

	                    b = this.scanner.substrToCursor(start + sign + 1);
	            }
	        }

	        // <ndashdigit-dimension>
	        // <ndash-dimension> <signless-integer>
	        // <n-dimension>
	        // <n-dimension> <signed-integer>
	        // <n-dimension> ['+' | '-'] <signless-integer>
	        else if (this.scanner.tokenType === DIMENSION$2) {
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
	            var sign = code === PLUSSIGN$3 || code === HYPHENMINUS$3;

	            for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
	                if (!isDigit$4(this.scanner.source.charCodeAt(i))) {
	                    break;
	                }
	            }

	            if (i === this.scanner.tokenStart + sign) {
	                this.error('Integer is expected', this.scanner.tokenStart + sign);
	            }

	            expectCharCode.call(this, i - this.scanner.tokenStart, N$4);
	            a = this.scanner.source.substring(start, i);

	            // <n-dimension>
	            // <n-dimension> <signed-integer>
	            // <n-dimension> ['+' | '-'] <signless-integer>
	            if (i + 1 === this.scanner.tokenEnd) {
	                this.scanner.next();
	                b = consumeB$1.call(this);
	            } else {
	                expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS$3);

	                // <ndash-dimension> <signless-integer>
	                if (i + 2 === this.scanner.tokenEnd) {
	                    this.scanner.next();
	                    this.scanner.skipSC();
	                    checkTokenIsInteger.call(this, DISALLOW_SIGN$1);
	                    b = '-' + this.consume(NUMBER$3);
	                }
	                // <ndashdigit-dimension>
	                else {
	                    checkInteger$1.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN$1);
	                    this.scanner.next();
	                    b = this.scanner.substrToCursor(i + 1);
	                }
	            }
	        } else {
	            this.error();
	        }

	        if (a !== null && a.charCodeAt(0) === PLUSSIGN$3) {
	            a = a.substr(1);
	        }

	        if (b !== null && b.charCodeAt(0) === PLUSSIGN$3) {
	            b = b.substr(1);
	        }

	        return {
	            type: 'AnPlusB',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            a: a,
	            b: b
	        };
	    },
	    generate: function(node) {
	        var a = node.a !== null && node.a !== undefined;
	        var b = node.b !== null && node.b !== undefined;

	        if (a) {
	            this.chunk(
	                node.a === '+1' ? '+n' : // eslint-disable-line operator-linebreak, indent
	                node.a ===  '1' ?  'n' : // eslint-disable-line operator-linebreak, indent
	                node.a === '-1' ? '-n' : // eslint-disable-line operator-linebreak, indent
	                node.a + 'n'             // eslint-disable-line operator-linebreak, indent
	            );

	            if (b) {
	                b = String(node.b);
	                if (b.charAt(0) === '-' || b.charAt(0) === '+') {
	                    this.chunk(b.charAt(0));
	                    this.chunk(b.substr(1));
	                } else {
	                    this.chunk('+');
	                    this.chunk(b);
	                }
	            }
	        } else {
	            this.chunk(String(node.b));
	        }
	    }
	};

	var TYPE$a = tokenizer.TYPE;

	var WhiteSpace = TYPE$a.WhiteSpace;
	var Semicolon = TYPE$a.Semicolon;
	var LeftCurlyBracket = TYPE$a.LeftCurlyBracket;
	var Delim = TYPE$a.Delim;
	var EXCLAMATIONMARK$1 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function getOffsetExcludeWS() {
	    if (this.scanner.tokenIndex > 0) {
	        if (this.scanner.lookupType(-1) === WhiteSpace) {
	            return this.scanner.tokenIndex > 1
	                ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1)
	                : this.scanner.firstCharOffset;
	        }
	    }

	    return this.scanner.tokenStart;
	}

	// 0, 0, false
	function balanceEnd() {
	    return 0;
	}

	// LEFTCURLYBRACKET, 0, false
	function leftCurlyBracket(tokenType) {
	    return tokenType === LeftCurlyBracket ? 1 : 0;
	}

	// LEFTCURLYBRACKET, SEMICOLON, false
	function leftCurlyBracketOrSemicolon(tokenType) {
	    return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
	}

	// EXCLAMATIONMARK, SEMICOLON, false
	function exclamationMarkOrSemicolon(tokenType, source, offset) {
	    if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK$1) {
	        return 1;
	    }

	    return tokenType === Semicolon ? 1 : 0;
	}

	// 0, SEMICOLON, true
	function semicolonIncluded(tokenType) {
	    return tokenType === Semicolon ? 2 : 0;
	}

	var Raw = {
	    name: 'Raw',
	    structure: {
	        value: String
	    },
	    parse: function(startToken, mode, excludeWhiteSpace) {
	        var startOffset = this.scanner.getTokenStart(startToken);
	        var endOffset;

	        this.scanner.skip(
	            this.scanner.getRawLength(startToken, mode || balanceEnd)
	        );

	        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
	            endOffset = getOffsetExcludeWS.call(this);
	        } else {
	            endOffset = this.scanner.tokenStart;
	        }

	        return {
	            type: 'Raw',
	            loc: this.getLocation(startOffset, endOffset),
	            value: this.scanner.source.substring(startOffset, endOffset)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    },

	    mode: {
	        default: balanceEnd,
	        leftCurlyBracket: leftCurlyBracket,
	        leftCurlyBracketOrSemicolon: leftCurlyBracketOrSemicolon,
	        exclamationMarkOrSemicolon: exclamationMarkOrSemicolon,
	        semicolonIncluded: semicolonIncluded
	    }
	};

	var TYPE$b = tokenizer.TYPE;
	var rawMode = Raw.mode;

	var ATKEYWORD = TYPE$b.AtKeyword;
	var SEMICOLON = TYPE$b.Semicolon;
	var LEFTCURLYBRACKET$1 = TYPE$b.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$1 = TYPE$b.RightCurlyBracket;

	function consumeRaw(startToken) {
	    return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
	}

	function isDeclarationBlockAtrule() {
	    for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
	        if (type === RIGHTCURLYBRACKET$1) {
	            return true;
	        }

	        if (type === LEFTCURLYBRACKET$1 ||
	            type === ATKEYWORD) {
	            return false;
	        }
	    }

	    return false;
	}

	var Atrule = {
	    name: 'Atrule',
	    structure: {
	        name: String,
	        prelude: ['AtrulePrelude', 'Raw', null],
	        block: ['Block', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var nameLowerCase;
	        var prelude = null;
	        var block = null;

	        this.eat(ATKEYWORD);

	        name = this.scanner.substrToCursor(start + 1);
	        nameLowerCase = name.toLowerCase();
	        this.scanner.skipSC();

	        // parse prelude
	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$1 &&
	            this.scanner.tokenType !== SEMICOLON) {
	            if (this.parseAtrulePrelude) {
	                prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);

	                // turn empty AtrulePrelude into null
	                if (prelude.type === 'AtrulePrelude' && prelude.children.head === null) {
	                    prelude = null;
	                }
	            } else {
	                prelude = consumeRaw.call(this, this.scanner.tokenIndex);
	            }

	            this.scanner.skipSC();
	        }

	        switch (this.scanner.tokenType) {
	            case SEMICOLON:
	                this.scanner.next();
	                break;

	            case LEFTCURLYBRACKET$1:
	                if (this.atrule.hasOwnProperty(nameLowerCase) &&
	                    typeof this.atrule[nameLowerCase].block === 'function') {
	                    block = this.atrule[nameLowerCase].block.call(this);
	                } else {
	                    // TODO: should consume block content as Raw?
	                    block = this.Block(isDeclarationBlockAtrule.call(this));
	                }

	                break;
	        }

	        return {
	            type: 'Atrule',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.chunk('@');
	        this.chunk(node.name);

	        if (node.prelude !== null) {
	            this.chunk(' ');
	            this.node(node.prelude);
	        }

	        if (node.block) {
	            this.node(node.block);
	        } else {
	            this.chunk(';');
	        }
	    },
	    walkContext: 'atrule'
	};

	var TYPE$c = tokenizer.TYPE;

	var SEMICOLON$1 = TYPE$c.Semicolon;
	var LEFTCURLYBRACKET$2 = TYPE$c.LeftCurlyBracket;

	var AtrulePrelude = {
	    name: 'AtrulePrelude',
	    structure: {
	        children: [[]]
	    },
	    parse: function(name) {
	        var children = null;

	        if (name !== null) {
	            name = name.toLowerCase();
	        }

	        this.scanner.skipSC();

	        if (this.atrule.hasOwnProperty(name) &&
	            typeof this.atrule[name].prelude === 'function') {
	            // custom consumer
	            children = this.atrule[name].prelude.call(this);
	        } else {
	            // default consumer
	            children = this.readSequence(this.scope.AtrulePrelude);
	        }

	        this.scanner.skipSC();

	        if (this.scanner.eof !== true &&
	            this.scanner.tokenType !== LEFTCURLYBRACKET$2 &&
	            this.scanner.tokenType !== SEMICOLON$1) {
	            this.error('Semicolon or block is expected');
	        }

	        if (children === null) {
	            children = this.createList();
	        }

	        return {
	            type: 'AtrulePrelude',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'atrulePrelude'
	};

	var TYPE$d = tokenizer.TYPE;

	var IDENT$4 = TYPE$d.Ident;
	var STRING = TYPE$d.String;
	var COLON = TYPE$d.Colon;
	var LEFTSQUAREBRACKET$1 = TYPE$d.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$1 = TYPE$d.RightSquareBracket;
	var DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
	var ASTERISK$1 = 0x002A;         // U+002A ASTERISK (*)
	var EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
	var CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
	var VERTICALLINE$1 = 0x007C;     // U+007C VERTICAL LINE (|)
	var TILDE = 0x007E;            // U+007E TILDE (~)

	function getAttributeName() {
	    if (this.scanner.eof) {
	        this.error('Unexpected end of input');
	    }

	    var start = this.scanner.tokenStart;
	    var expectIdent = false;
	    var checkColon = true;

	    if (this.scanner.isDelim(ASTERISK$1)) {
	        expectIdent = true;
	        checkColon = false;
	        this.scanner.next();
	    } else if (!this.scanner.isDelim(VERTICALLINE$1)) {
	        this.eat(IDENT$4);
	    }

	    if (this.scanner.isDelim(VERTICALLINE$1)) {
	        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
	            this.scanner.next();
	            this.eat(IDENT$4);
	        } else if (expectIdent) {
	            this.error('Identifier is expected', this.scanner.tokenEnd);
	        }
	    } else if (expectIdent) {
	        this.error('Vertical line is expected');
	    }

	    if (checkColon && this.scanner.tokenType === COLON) {
	        this.scanner.next();
	        this.eat(IDENT$4);
	    }

	    return {
	        type: 'Identifier',
	        loc: this.getLocation(start, this.scanner.tokenStart),
	        name: this.scanner.substrToCursor(start)
	    };
	}

	function getOperator() {
	    var start = this.scanner.tokenStart;
	    var code = this.scanner.source.charCodeAt(start);

	    if (code !== EQUALSSIGN &&        // =
	        code !== TILDE &&             // ~=
	        code !== CIRCUMFLEXACCENT &&  // ^=
	        code !== DOLLARSIGN &&        // $=
	        code !== ASTERISK$1 &&          // *=
	        code !== VERTICALLINE$1         // |=
	    ) {
	        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
	    }

	    this.scanner.next();

	    if (code !== EQUALSSIGN) {
	        if (!this.scanner.isDelim(EQUALSSIGN)) {
	            this.error('Equal sign is expected');
	        }

	        this.scanner.next();
	    }

	    return this.scanner.substrToCursor(start);
	}

	// '[' <wq-name> ']'
	// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
	var AttributeSelector = {
	    name: 'AttributeSelector',
	    structure: {
	        name: 'Identifier',
	        matcher: [String, null],
	        value: ['String', 'Identifier', null],
	        flags: [String, null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var matcher = null;
	        var value = null;
	        var flags = null;

	        this.eat(LEFTSQUAREBRACKET$1);
	        this.scanner.skipSC();

	        name = getAttributeName.call(this);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET$1) {
	            // avoid case `[name i]`
	            if (this.scanner.tokenType !== IDENT$4) {
	                matcher = getOperator.call(this);

	                this.scanner.skipSC();

	                value = this.scanner.tokenType === STRING
	                    ? this.String()
	                    : this.Identifier();

	                this.scanner.skipSC();
	            }

	            // attribute flags
	            if (this.scanner.tokenType === IDENT$4) {
	                flags = this.scanner.getTokenValue();
	                this.scanner.next();

	                this.scanner.skipSC();
	            }
	        }

	        this.eat(RIGHTSQUAREBRACKET$1);

	        return {
	            type: 'AttributeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            matcher: matcher,
	            value: value,
	            flags: flags
	        };
	    },
	    generate: function(node) {
	        var flagsPrefix = ' ';

	        this.chunk('[');
	        this.node(node.name);

	        if (node.matcher !== null) {
	            this.chunk(node.matcher);

	            if (node.value !== null) {
	                this.node(node.value);

	                // space between string and flags is not required
	                if (node.value.type === 'String') {
	                    flagsPrefix = '';
	                }
	            }
	        }

	        if (node.flags !== null) {
	            this.chunk(flagsPrefix);
	            this.chunk(node.flags);
	        }

	        this.chunk(']');
	    }
	};

	var TYPE$e = tokenizer.TYPE;
	var rawMode$1 = Raw.mode;

	var WHITESPACE$5 = TYPE$e.WhiteSpace;
	var COMMENT$4 = TYPE$e.Comment;
	var SEMICOLON$2 = TYPE$e.Semicolon;
	var ATKEYWORD$1 = TYPE$e.AtKeyword;
	var LEFTCURLYBRACKET$3 = TYPE$e.LeftCurlyBracket;
	var RIGHTCURLYBRACKET$2 = TYPE$e.RightCurlyBracket;

	function consumeRaw$1(startToken) {
	    return this.Raw(startToken, null, true);
	}
	function consumeRule() {
	    return this.parseWithFallback(this.Rule, consumeRaw$1);
	}
	function consumeRawDeclaration(startToken) {
	    return this.Raw(startToken, rawMode$1.semicolonIncluded, true);
	}
	function consumeDeclaration() {
	    if (this.scanner.tokenType === SEMICOLON$2) {
	        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
	    }

	    var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

	    if (this.scanner.tokenType === SEMICOLON$2) {
	        this.scanner.next();
	    }

	    return node;
	}

	var Block = {
	    name: 'Block',
	    structure: {
	        children: [[
	            'Atrule',
	            'Rule',
	            'Declaration'
	        ]]
	    },
	    parse: function(isDeclaration) {
	        var consumer = isDeclaration ? consumeDeclaration : consumeRule;

	        var start = this.scanner.tokenStart;
	        var children = this.createList();

	        this.eat(LEFTCURLYBRACKET$3);

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case RIGHTCURLYBRACKET$2:
	                    break scan;

	                case WHITESPACE$5:
	                case COMMENT$4:
	                    this.scanner.next();
	                    break;

	                case ATKEYWORD$1:
	                    children.push(this.parseWithFallback(this.Atrule, consumeRaw$1));
	                    break;

	                default:
	                    children.push(consumer.call(this));
	            }
	        }

	        if (!this.scanner.eof) {
	            this.eat(RIGHTCURLYBRACKET$2);
	        }

	        return {
	            type: 'Block',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('{');
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	        this.chunk('}');
	    },
	    walkContext: 'block'
	};

	var TYPE$f = tokenizer.TYPE;

	var LEFTSQUAREBRACKET$2 = TYPE$f.LeftSquareBracket;
	var RIGHTSQUAREBRACKET$2 = TYPE$f.RightSquareBracket;

	var Brackets = {
	    name: 'Brackets',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTSQUAREBRACKET$2);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTSQUAREBRACKET$2);
	        }

	        return {
	            type: 'Brackets',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('[');
	        this.children(node);
	        this.chunk(']');
	    }
	};

	var CDC = tokenizer.TYPE.CDC;

	var CDC_1 = {
	    name: 'CDC',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDC); // -->

	        return {
	            type: 'CDC',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('-->');
	    }
	};

	var CDO = tokenizer.TYPE.CDO;

	var CDO_1 = {
	    name: 'CDO',
	    structure: [],
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(CDO); // <!--

	        return {
	            type: 'CDO',
	            loc: this.getLocation(start, this.scanner.tokenStart)
	        };
	    },
	    generate: function() {
	        this.chunk('<!--');
	    }
	};

	var TYPE$g = tokenizer.TYPE;

	var IDENT$5 = TYPE$g.Ident;
	var FULLSTOP = 0x002E; // U+002E FULL STOP (.)

	// '.' ident
	var ClassSelector = {
	    name: 'ClassSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        if (!this.scanner.isDelim(FULLSTOP)) {
	            this.error('Full stop is expected');
	        }

	        this.scanner.next();

	        return {
	            type: 'ClassSelector',
	            loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
	            name: this.consume(IDENT$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk('.');
	        this.chunk(node.name);
	    }
	};

	var TYPE$h = tokenizer.TYPE;

	var IDENT$6 = TYPE$h.Ident;
	var PLUSSIGN$4 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
	var GREATERTHANSIGN$1 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var TILDE$1 = 0x007E;           // U+007E TILDE (~)

	// + | > | ~ | /deep/
	var Combinator = {
	    name: 'Combinator',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	        switch (code) {
	            case GREATERTHANSIGN$1:
	            case PLUSSIGN$4:
	            case TILDE$1:
	                this.scanner.next();
	                break;

	            case SOLIDUS:
	                this.scanner.next();

	                if (this.scanner.tokenType !== IDENT$6 || this.scanner.lookupValue(0, 'deep') === false) {
	                    this.error('Identifier `deep` is expected');
	                }

	                this.scanner.next();

	                if (!this.scanner.isDelim(SOLIDUS)) {
	                    this.error('Solidus is expected');
	                }

	                this.scanner.next();
	                break;

	            default:
	                this.error('Combinator is expected');
	        }

	        return {
	            type: 'Combinator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$i = tokenizer.TYPE;

	var COMMENT$5 = TYPE$i.Comment;
	var ASTERISK$2 = 0x002A;        // U+002A ASTERISK (*)
	var SOLIDUS$1 = 0x002F;         // U+002F SOLIDUS (/)

	// '/*' .* '*/'
	var Comment = {
	    name: 'Comment',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var end = this.scanner.tokenEnd;

	        this.eat(COMMENT$5);

	        if ((end - start + 2) >= 2 &&
	            this.scanner.source.charCodeAt(end - 2) === ASTERISK$2 &&
	            this.scanner.source.charCodeAt(end - 1) === SOLIDUS$1) {
	            end -= 2;
	        }

	        return {
	            type: 'Comment',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start + 2, end)
	        };
	    },
	    generate: function(node) {
	        this.chunk('/*');
	        this.chunk(node.value);
	        this.chunk('*/');
	    }
	};

	var isCustomProperty$1 = names.isCustomProperty;
	var TYPE$j = tokenizer.TYPE;
	var rawMode$2 = Raw.mode;

	var IDENT$7 = TYPE$j.Ident;
	var HASH$1 = TYPE$j.Hash;
	var COLON$1 = TYPE$j.Colon;
	var SEMICOLON$3 = TYPE$j.Semicolon;
	var DELIM$2 = TYPE$j.Delim;
	var EXCLAMATIONMARK$2 = 0x0021; // U+0021 EXCLAMATION MARK (!)
	var NUMBERSIGN$2 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var DOLLARSIGN$1 = 0x0024;      // U+0024 DOLLAR SIGN ($)
	var AMPERSAND$1 = 0x0026;       // U+0026 ANPERSAND (&)
	var ASTERISK$3 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$5 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$2 = 0x002F;         // U+002F SOLIDUS (/)

	function consumeValueRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, true);
	}

	function consumeCustomPropertyRaw(startToken) {
	    return this.Raw(startToken, rawMode$2.exclamationMarkOrSemicolon, false);
	}

	function consumeValue() {
	    var startValueToken = this.scanner.tokenIndex;
	    var value = this.Value();

	    if (value.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== SEMICOLON$3 &&
	        this.scanner.isDelim(EXCLAMATIONMARK$2) === false &&
	        this.scanner.isBalanceEdge(startValueToken) === false) {
	        this.error();
	    }

	    return value;
	}

	var Declaration = {
	    name: 'Declaration',
	    structure: {
	        important: [Boolean, String],
	        property: String,
	        value: ['Value', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var startToken = this.scanner.tokenIndex;
	        var property = readProperty$1.call(this);
	        var customProperty = isCustomProperty$1(property);
	        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
	        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
	        var important = false;
	        var value;

	        this.scanner.skipSC();
	        this.eat(COLON$1);

	        if (!customProperty) {
	            this.scanner.skipSC();
	        }

	        if (parseValue) {
	            value = this.parseWithFallback(consumeValue, consumeRaw);
	        } else {
	            value = consumeRaw.call(this, this.scanner.tokenIndex);
	        }

	        if (this.scanner.isDelim(EXCLAMATIONMARK$2)) {
	            important = getImportant.call(this);
	            this.scanner.skipSC();
	        }

	        // Do not include semicolon to range per spec
	        // https://drafts.csswg.org/css-syntax/#declaration-diagram

	        if (this.scanner.eof === false &&
	            this.scanner.tokenType !== SEMICOLON$3 &&
	            this.scanner.isBalanceEdge(startToken) === false) {
	            this.error();
	        }

	        return {
	            type: 'Declaration',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            important: important,
	            property: property,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.property);
	        this.chunk(':');
	        this.node(node.value);

	        if (node.important) {
	            this.chunk(node.important === true ? '!important' : '!' + node.important);
	        }
	    },
	    walkContext: 'declaration'
	};

	function readProperty$1() {
	    var start = this.scanner.tokenStart;

	    // hacks
	    if (this.scanner.tokenType === DELIM$2) {
	        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
	            case ASTERISK$3:
	            case DOLLARSIGN$1:
	            case PLUSSIGN$5:
	            case NUMBERSIGN$2:
	            case AMPERSAND$1:
	                this.scanner.next();
	                break;

	            // TODO: not sure we should support this hack
	            case SOLIDUS$2:
	                this.scanner.next();
	                if (this.scanner.isDelim(SOLIDUS$2)) {
	                    this.scanner.next();
	                }
	                break;
	        }
	    }

	    if (this.scanner.tokenType === HASH$1) {
	        this.eat(HASH$1);
	    } else {
	        this.eat(IDENT$7);
	    }

	    return this.scanner.substrToCursor(start);
	}

	// ! ws* important
	function getImportant() {
	    this.eat(DELIM$2);
	    this.scanner.skipSC();

	    var important = this.consume(IDENT$7);

	    // store original value in case it differ from `important`
	    // for better original source restoring and hacks like `!ie` support
	    return important === 'important' ? true : important;
	}

	var TYPE$k = tokenizer.TYPE;
	var rawMode$3 = Raw.mode;

	var WHITESPACE$6 = TYPE$k.WhiteSpace;
	var COMMENT$6 = TYPE$k.Comment;
	var SEMICOLON$4 = TYPE$k.Semicolon;

	function consumeRaw$2(startToken) {
	    return this.Raw(startToken, rawMode$3.semicolonIncluded, true);
	}

	var DeclarationList = {
	    name: 'DeclarationList',
	    structure: {
	        children: [[
	            'Declaration'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$6:
	                case COMMENT$6:
	                case SEMICOLON$4:
	                    this.scanner.next();
	                    break;

	                default:
	                    children.push(this.parseWithFallback(this.Declaration, consumeRaw$2));
	            }
	        }

	        return {
	            type: 'DeclarationList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function(prev) {
	            if (prev.type === 'Declaration') {
	                this.chunk(';');
	            }
	        });
	    }
	};

	var consumeNumber$3 = utils.consumeNumber;
	var TYPE$l = tokenizer.TYPE;

	var DIMENSION$3 = TYPE$l.Dimension;

	var Dimension = {
	    name: 'Dimension',
	    structure: {
	        value: String,
	        unit: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$3(this.scanner.source, start);

	        this.eat(DIMENSION$3);

	        return {
	            type: 'Dimension',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd),
	            unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk(node.unit);
	    }
	};

	var TYPE$m = tokenizer.TYPE;

	var RIGHTPARENTHESIS$2 = TYPE$m.RightParenthesis;

	// <function-token> <sequence> )
	var _Function = {
	    name: 'Function',
	    structure: {
	        name: String,
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var name = this.consumeFunctionName();
	        var nameLowerCase = name.toLowerCase();
	        var children;

	        children = recognizer.hasOwnProperty(nameLowerCase)
	            ? recognizer[nameLowerCase].call(this, recognizer)
	            : readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$2);
	        }

	        return {
	            type: 'Function',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    },
	    walkContext: 'function'
	};

	var TYPE$n = tokenizer.TYPE;

	var HASH$2 = TYPE$n.Hash;

	// '#' ident
	var HexColor = {
	    name: 'HexColor',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.eat(HASH$2);

	        return {
	            type: 'HexColor',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.value);
	    }
	};

	var TYPE$o = tokenizer.TYPE;

	var IDENT$8 = TYPE$o.Ident;

	var Identifier = {
	    name: 'Identifier',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        return {
	            type: 'Identifier',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            name: this.consume(IDENT$8)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var TYPE$p = tokenizer.TYPE;

	var HASH$3 = TYPE$p.Hash;

	// <hash-token>
	var IdSelector = {
	    name: 'IdSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // TODO: check value is an ident
	        this.eat(HASH$3);

	        return {
	            type: 'IdSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start + 1)
	        };
	    },
	    generate: function(node) {
	        this.chunk('#');
	        this.chunk(node.name);
	    }
	};

	var TYPE$q = tokenizer.TYPE;

	var IDENT$9 = TYPE$q.Ident;
	var NUMBER$4 = TYPE$q.Number;
	var DIMENSION$4 = TYPE$q.Dimension;
	var LEFTPARENTHESIS$2 = TYPE$q.LeftParenthesis;
	var RIGHTPARENTHESIS$3 = TYPE$q.RightParenthesis;
	var COLON$2 = TYPE$q.Colon;
	var DELIM$3 = TYPE$q.Delim;

	var MediaFeature = {
	    name: 'MediaFeature',
	    structure: {
	        name: String,
	        value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var name;
	        var value = null;

	        this.eat(LEFTPARENTHESIS$2);
	        this.scanner.skipSC();

	        name = this.consume(IDENT$9);
	        this.scanner.skipSC();

	        if (this.scanner.tokenType !== RIGHTPARENTHESIS$3) {
	            this.eat(COLON$2);
	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case NUMBER$4:
	                    if (this.lookupNonWSType(1) === DELIM$3) {
	                        value = this.Ratio();
	                    } else {
	                        value = this.Number();
	                    }

	                    break;

	                case DIMENSION$4:
	                    value = this.Dimension();
	                    break;

	                case IDENT$9:
	                    value = this.Identifier();

	                    break;

	                default:
	                    this.error('Number, dimension, ratio or identifier is expected');
	            }

	            this.scanner.skipSC();
	        }

	        this.eat(RIGHTPARENTHESIS$3);

	        return {
	            type: 'MediaFeature',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.chunk(node.name);
	        if (node.value !== null) {
	            this.chunk(':');
	            this.node(node.value);
	        }
	        this.chunk(')');
	    }
	};

	var TYPE$r = tokenizer.TYPE;

	var WHITESPACE$7 = TYPE$r.WhiteSpace;
	var COMMENT$7 = TYPE$r.Comment;
	var IDENT$a = TYPE$r.Ident;
	var LEFTPARENTHESIS$3 = TYPE$r.LeftParenthesis;

	var MediaQuery = {
	    name: 'MediaQuery',
	    structure: {
	        children: [[
	            'Identifier',
	            'MediaFeature',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        this.scanner.skipSC();

	        var children = this.createList();
	        var child = null;
	        var space = null;

	        scan:
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case COMMENT$7:
	                    this.scanner.next();
	                    continue;

	                case WHITESPACE$7:
	                    space = this.WhiteSpace();
	                    continue;

	                case IDENT$a:
	                    child = this.Identifier();
	                    break;

	                case LEFTPARENTHESIS$3:
	                    child = this.MediaFeature();
	                    break;

	                default:
	                    break scan;
	            }

	            if (space !== null) {
	                children.push(space);
	                space = null;
	            }

	            children.push(child);
	        }

	        if (child === null) {
	            this.error('Identifier or parenthesis is expected');
	        }

	        return {
	            type: 'MediaQuery',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var COMMA$1 = tokenizer.TYPE.Comma;

	var MediaQueryList = {
	    name: 'MediaQueryList',
	    structure: {
	        children: [[
	            'MediaQuery'
	        ]]
	    },
	    parse: function(relative) {
	        var children = this.createList();

	        this.scanner.skipSC();

	        while (!this.scanner.eof) {
	            children.push(this.MediaQuery(relative));

	            if (this.scanner.tokenType !== COMMA$1) {
	                break;
	            }

	            this.scanner.next();
	        }

	        return {
	            type: 'MediaQueryList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    }
	};

	var Nth = {
	    name: 'Nth',
	    structure: {
	        nth: ['AnPlusB', 'Identifier'],
	        selector: ['SelectorList', null]
	    },
	    parse: function(allowOfClause) {
	        this.scanner.skipSC();

	        var start = this.scanner.tokenStart;
	        var end = start;
	        var selector = null;
	        var query;

	        if (this.scanner.lookupValue(0, 'odd') || this.scanner.lookupValue(0, 'even')) {
	            query = this.Identifier();
	        } else {
	            query = this.AnPlusB();
	        }

	        this.scanner.skipSC();

	        if (allowOfClause && this.scanner.lookupValue(0, 'of')) {
	            this.scanner.next();

	            selector = this.SelectorList();

	            if (this.needPositions) {
	                end = this.getLastListNode(selector.children).loc.end.offset;
	            }
	        } else {
	            if (this.needPositions) {
	                end = query.loc.end.offset;
	            }
	        }

	        return {
	            type: 'Nth',
	            loc: this.getLocation(start, end),
	            nth: query,
	            selector: selector
	        };
	    },
	    generate: function(node) {
	        this.node(node.nth);
	        if (node.selector !== null) {
	            this.chunk(' of ');
	            this.node(node.selector);
	        }
	    }
	};

	var NUMBER$5 = tokenizer.TYPE.Number;

	var _Number = {
	    name: 'Number',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'Number',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(NUMBER$5)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	// '/' | '*' | ',' | ':' | '+' | '-'
	var Operator = {
	    name: 'Operator',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        this.scanner.next();

	        return {
	            type: 'Operator',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$s = tokenizer.TYPE;

	var LEFTPARENTHESIS$4 = TYPE$s.LeftParenthesis;
	var RIGHTPARENTHESIS$4 = TYPE$s.RightParenthesis;

	var Parentheses = {
	    name: 'Parentheses',
	    structure: {
	        children: [[]]
	    },
	    parse: function(readSequence, recognizer) {
	        var start = this.scanner.tokenStart;
	        var children = null;

	        this.eat(LEFTPARENTHESIS$4);

	        children = readSequence.call(this, recognizer);

	        if (!this.scanner.eof) {
	            this.eat(RIGHTPARENTHESIS$4);
	        }

	        return {
	            type: 'Parentheses',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('(');
	        this.children(node);
	        this.chunk(')');
	    }
	};

	var consumeNumber$4 = utils.consumeNumber;
	var TYPE$t = tokenizer.TYPE;

	var PERCENTAGE$1 = TYPE$t.Percentage;

	var Percentage = {
	    name: 'Percentage',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var numberEnd = consumeNumber$4(this.scanner.source, start);

	        this.eat(PERCENTAGE$1);

	        return {
	            type: 'Percentage',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.source.substring(start, numberEnd)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	        this.chunk('%');
	    }
	};

	var TYPE$u = tokenizer.TYPE;

	var IDENT$b = TYPE$u.Ident;
	var FUNCTION$1 = TYPE$u.Function;
	var COLON$3 = TYPE$u.Colon;
	var RIGHTPARENTHESIS$5 = TYPE$u.RightParenthesis;

	// : [ <ident> | <function-token> <any-value>? ) ]
	var PseudoClassSelector = {
	    name: 'PseudoClassSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$3);

	        if (this.scanner.tokenType === FUNCTION$1) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$5);
	        } else {
	            name = this.consume(IDENT$b);
	        }

	        return {
	            type: 'PseudoClassSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk(':');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var TYPE$v = tokenizer.TYPE;

	var IDENT$c = TYPE$v.Ident;
	var FUNCTION$2 = TYPE$v.Function;
	var COLON$4 = TYPE$v.Colon;
	var RIGHTPARENTHESIS$6 = TYPE$v.RightParenthesis;

	// :: [ <ident> | <function-token> <any-value>? ) ]
	var PseudoElementSelector = {
	    name: 'PseudoElementSelector',
	    structure: {
	        name: String,
	        children: [['Raw'], null]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = null;
	        var name;
	        var nameLowerCase;

	        this.eat(COLON$4);
	        this.eat(COLON$4);

	        if (this.scanner.tokenType === FUNCTION$2) {
	            name = this.consumeFunctionName();
	            nameLowerCase = name.toLowerCase();

	            if (this.pseudo.hasOwnProperty(nameLowerCase)) {
	                this.scanner.skipSC();
	                children = this.pseudo[nameLowerCase].call(this);
	                this.scanner.skipSC();
	            } else {
	                children = this.createList();
	                children.push(
	                    this.Raw(this.scanner.tokenIndex, null, false)
	                );
	            }

	            this.eat(RIGHTPARENTHESIS$6);
	        } else {
	            name = this.consume(IDENT$c);
	        }

	        return {
	            type: 'PseudoElementSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: name,
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.chunk('::');
	        this.chunk(node.name);

	        if (node.children !== null) {
	            this.chunk('(');
	            this.children(node);
	            this.chunk(')');
	        }
	    },
	    walkContext: 'function'
	};

	var isDigit$5 = tokenizer.isDigit;
	var TYPE$w = tokenizer.TYPE;

	var NUMBER$6 = TYPE$w.Number;
	var DELIM$4 = TYPE$w.Delim;
	var SOLIDUS$3 = 0x002F;  // U+002F SOLIDUS (/)
	var FULLSTOP$1 = 0x002E; // U+002E FULL STOP (.)

	// Terms of <ratio> should be a positive numbers (not zero or negative)
	// (see https://drafts.csswg.org/mediaqueries-3/#values)
	// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
	// and this is using by various sites. Therefore we relax checking on parse
	// to test a term is unsigned number without an exponent part.
	// Additional checking may be applied on lexer validation.
	function consumeNumber$5() {
	    this.scanner.skipWS();

	    var value = this.consume(NUMBER$6);

	    for (var i = 0; i < value.length; i++) {
	        var code = value.charCodeAt(i);
	        if (!isDigit$5(code) && code !== FULLSTOP$1) {
	            this.error('Unsigned number is expected', this.scanner.tokenStart - value.length + i);
	        }
	    }

	    if (Number(value) === 0) {
	        this.error('Zero number is not allowed', this.scanner.tokenStart - value.length);
	    }

	    return value;
	}

	// <positive-integer> S* '/' S* <positive-integer>
	var Ratio = {
	    name: 'Ratio',
	    structure: {
	        left: String,
	        right: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var left = consumeNumber$5.call(this);
	        var right;

	        this.scanner.skipWS();

	        if (!this.scanner.isDelim(SOLIDUS$3)) {
	            this.error('Solidus is expected');
	        }
	        this.eat(DELIM$4);
	        right = consumeNumber$5.call(this);

	        return {
	            type: 'Ratio',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            left: left,
	            right: right
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.left);
	        this.chunk('/');
	        this.chunk(node.right);
	    }
	};

	var TYPE$x = tokenizer.TYPE;
	var rawMode$4 = Raw.mode;

	var LEFTCURLYBRACKET$4 = TYPE$x.LeftCurlyBracket;

	function consumeRaw$3(startToken) {
	    return this.Raw(startToken, rawMode$4.leftCurlyBracket, true);
	}

	function consumePrelude() {
	    var prelude = this.SelectorList();

	    if (prelude.type !== 'Raw' &&
	        this.scanner.eof === false &&
	        this.scanner.tokenType !== LEFTCURLYBRACKET$4) {
	        this.error();
	    }

	    return prelude;
	}

	var Rule = {
	    name: 'Rule',
	    structure: {
	        prelude: ['SelectorList', 'Raw'],
	        block: ['Block']
	    },
	    parse: function() {
	        var startToken = this.scanner.tokenIndex;
	        var startOffset = this.scanner.tokenStart;
	        var prelude;
	        var block;

	        if (this.parseRulePrelude) {
	            prelude = this.parseWithFallback(consumePrelude, consumeRaw$3);
	        } else {
	            prelude = consumeRaw$3.call(this, startToken);
	        }

	        block = this.Block(true);

	        return {
	            type: 'Rule',
	            loc: this.getLocation(startOffset, this.scanner.tokenStart),
	            prelude: prelude,
	            block: block
	        };
	    },
	    generate: function(node) {
	        this.node(node.prelude);
	        this.node(node.block);
	    },
	    walkContext: 'rule'
	};

	var Selector = {
	    name: 'Selector',
	    structure: {
	        children: [[
	            'TypeSelector',
	            'IdSelector',
	            'ClassSelector',
	            'AttributeSelector',
	            'PseudoClassSelector',
	            'PseudoElementSelector',
	            'Combinator',
	            'WhiteSpace'
	        ]]
	    },
	    parse: function() {
	        var children = this.readSequence(this.scope.Selector);

	        // nothing were consumed
	        if (this.getFirstListNode(children) === null) {
	            this.error('Selector is expected');
	        }

	        return {
	            type: 'Selector',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var TYPE$y = tokenizer.TYPE;

	var COMMA$2 = TYPE$y.Comma;

	var SelectorList = {
	    name: 'SelectorList',
	    structure: {
	        children: [[
	            'Selector',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var children = this.createList();

	        while (!this.scanner.eof) {
	            children.push(this.Selector());

	            if (this.scanner.tokenType === COMMA$2) {
	                this.scanner.next();
	                continue;
	            }

	            break;
	        }

	        return {
	            type: 'SelectorList',
	            loc: this.getLocationFromList(children),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node, function() {
	            this.chunk(',');
	        });
	    },
	    walkContext: 'selector'
	};

	var STRING$1 = tokenizer.TYPE.String;

	var _String = {
	    name: 'String',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        return {
	            type: 'String',
	            loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	            value: this.consume(STRING$1)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var TYPE$z = tokenizer.TYPE;

	var WHITESPACE$8 = TYPE$z.WhiteSpace;
	var COMMENT$8 = TYPE$z.Comment;
	var ATKEYWORD$2 = TYPE$z.AtKeyword;
	var CDO$1 = TYPE$z.CDO;
	var CDC$1 = TYPE$z.CDC;
	var EXCLAMATIONMARK$3 = 0x0021; // U+0021 EXCLAMATION MARK (!)

	function consumeRaw$4(startToken) {
	    return this.Raw(startToken, null, false);
	}

	var StyleSheet = {
	    name: 'StyleSheet',
	    structure: {
	        children: [[
	            'Comment',
	            'CDO',
	            'CDC',
	            'Atrule',
	            'Rule',
	            'Raw'
	        ]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.createList();
	        var child;

	        
	        while (!this.scanner.eof) {
	            switch (this.scanner.tokenType) {
	                case WHITESPACE$8:
	                    this.scanner.next();
	                    continue;

	                case COMMENT$8:
	                    // ignore comments except exclamation comments (i.e. /*! .. */) on top level
	                    if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK$3) {
	                        this.scanner.next();
	                        continue;
	                    }

	                    child = this.Comment();
	                    break;

	                case CDO$1: // <!--
	                    child = this.CDO();
	                    break;

	                case CDC$1: // -->
	                    child = this.CDC();
	                    break;

	                // CSS Syntax Module Level 3
	                // §2.2 Error handling
	                // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
	                case ATKEYWORD$2:
	                    child = this.parseWithFallback(this.Atrule, consumeRaw$4);
	                    break;

	                // Anything else starts a qualified rule ...
	                default:
	                    child = this.parseWithFallback(this.Rule, consumeRaw$4);
	            }

	            children.push(child);
	        }

	        return {
	            type: 'StyleSheet',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    },
	    walkContext: 'stylesheet'
	};

	var TYPE$A = tokenizer.TYPE;

	var IDENT$d = TYPE$A.Ident;
	var ASTERISK$4 = 0x002A;     // U+002A ASTERISK (*)
	var VERTICALLINE$2 = 0x007C; // U+007C VERTICAL LINE (|)

	function eatIdentifierOrAsterisk() {
	    if (this.scanner.tokenType !== IDENT$d &&
	        this.scanner.isDelim(ASTERISK$4) === false) {
	        this.error('Identifier or asterisk is expected');
	    }

	    this.scanner.next();
	}

	// ident
	// ident|ident
	// ident|*
	// *
	// *|ident
	// *|*
	// |ident
	// |*
	var TypeSelector = {
	    name: 'TypeSelector',
	    structure: {
	        name: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        if (this.scanner.isDelim(VERTICALLINE$2)) {
	            this.scanner.next();
	            eatIdentifierOrAsterisk.call(this);
	        } else {
	            eatIdentifierOrAsterisk.call(this);

	            if (this.scanner.isDelim(VERTICALLINE$2)) {
	                this.scanner.next();
	                eatIdentifierOrAsterisk.call(this);
	            }
	        }

	        return {
	            type: 'TypeSelector',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            name: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.name);
	    }
	};

	var isHexDigit$4 = tokenizer.isHexDigit;
	var cmpChar$4 = tokenizer.cmpChar;
	var TYPE$B = tokenizer.TYPE;
	var NAME$3 = tokenizer.NAME;

	var IDENT$e = TYPE$B.Ident;
	var NUMBER$7 = TYPE$B.Number;
	var DIMENSION$5 = TYPE$B.Dimension;
	var PLUSSIGN$6 = 0x002B;     // U+002B PLUS SIGN (+)
	var HYPHENMINUS$4 = 0x002D;  // U+002D HYPHEN-MINUS (-)
	var QUESTIONMARK$2 = 0x003F; // U+003F QUESTION MARK (?)
	var U$1 = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

	function eatHexSequence(offset, allowDash) {
	    for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
	        var code = this.scanner.source.charCodeAt(pos);

	        if (code === HYPHENMINUS$4 && allowDash && len !== 0) {
	            if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
	                this.error();
	            }

	            return -1;
	        }

	        if (!isHexDigit$4(code)) {
	            this.error(
	                allowDash && len !== 0
	                    ? 'HyphenMinus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
	                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
	                pos
	            );
	        }

	        if (++len > 6) {
	            this.error('Too many hex digits', pos);
	        }    }

	    this.scanner.next();
	    return len;
	}

	function eatQuestionMarkSequence(max) {
	    var count = 0;

	    while (this.scanner.isDelim(QUESTIONMARK$2)) {
	        if (++count > max) {
	            this.error('Too many question marks');
	        }

	        this.scanner.next();
	    }
	}

	function startsWith$1(code) {
	    if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
	        this.error(NAME$3[code] + ' is expected');
	    }
	}

	// https://drafts.csswg.org/css-syntax/#urange
	// Informally, the <urange> production has three forms:
	// U+0001
	//      Defines a range consisting of a single code point, in this case the code point "1".
	// U+0001-00ff
	//      Defines a range of codepoints between the first and the second value, in this case
	//      the range between "1" and "ff" (255 in decimal) inclusive.
	// U+00??
	//      Defines a range of codepoints where the "?" characters range over all hex digits,
	//      in this case defining the same as the value U+0000-00ff.
	// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
	//
	// <urange> =
	//   u '+' <ident-token> '?'* |
	//   u <dimension-token> '?'* |
	//   u <number-token> '?'* |
	//   u <number-token> <dimension-token> |
	//   u <number-token> <number-token> |
	//   u '+' '?'+
	function scanUnicodeRange() {
	    var hexLength = 0;

	    // u '+' <ident-token> '?'*
	    // u '+' '?'+
	    if (this.scanner.isDelim(PLUSSIGN$6)) {
	        this.scanner.next();

	        if (this.scanner.tokenType === IDENT$e) {
	            hexLength = eatHexSequence.call(this, 0, true);
	            if (hexLength > 0) {
	                eatQuestionMarkSequence.call(this, 6 - hexLength);
	            }
	            return;
	        }

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            this.scanner.next();
	            eatQuestionMarkSequence.call(this, 5);
	            return;
	        }

	        this.error('Hex digit or question mark is expected');
	        return;
	    }

	    // u <number-token> '?'*
	    // u <number-token> <dimension-token>
	    // u <number-token> <number-token>
	    if (this.scanner.tokenType === NUMBER$7) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (this.scanner.isDelim(QUESTIONMARK$2)) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	            return;
	        }

	        if (this.scanner.tokenType === DIMENSION$5 ||
	            this.scanner.tokenType === NUMBER$7) {
	            startsWith$1.call(this, HYPHENMINUS$4);
	            eatHexSequence.call(this, 1, false);
	            return;
	        }

	        return;
	    }

	    // u <dimension-token> '?'*
	    if (this.scanner.tokenType === DIMENSION$5) {
	        startsWith$1.call(this, PLUSSIGN$6);
	        hexLength = eatHexSequence.call(this, 1, true);

	        if (hexLength > 0) {
	            eatQuestionMarkSequence.call(this, 6 - hexLength);
	        }

	        return;
	    }

	    this.error();
	}

	var UnicodeRange = {
	    name: 'UnicodeRange',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;

	        // U or u
	        if (!cmpChar$4(this.scanner.source, start, U$1)) {
	            this.error('U is expected');
	        }

	        if (!cmpChar$4(this.scanner.source, start + 1, PLUSSIGN$6)) {
	            this.error('Plus sign is expected');
	        }

	        this.scanner.next();
	        scanUnicodeRange.call(this);

	        return {
	            type: 'UnicodeRange',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: this.scanner.substrToCursor(start)
	        };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var isWhiteSpace$2 = tokenizer.isWhiteSpace;
	var cmpStr$4 = tokenizer.cmpStr;
	var TYPE$C = tokenizer.TYPE;

	var FUNCTION$3 = TYPE$C.Function;
	var URL$2 = TYPE$C.Url;
	var RIGHTPARENTHESIS$7 = TYPE$C.RightParenthesis;

	// <url-token> | <function-token> <string> )
	var Url = {
	    name: 'Url',
	    structure: {
	        value: ['String', 'Raw']
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var value;

	        switch (this.scanner.tokenType) {
	            case URL$2:
	                var rawStart = start + 4;
	                var rawEnd = this.scanner.tokenEnd - 1;

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawStart))) {
	                    rawStart++;
	                }

	                while (rawStart < rawEnd && isWhiteSpace$2(this.scanner.source.charCodeAt(rawEnd - 1))) {
	                    rawEnd--;
	                }

	                value = {
	                    type: 'Raw',
	                    loc: this.getLocation(rawStart, rawEnd),
	                    value: this.scanner.source.substring(rawStart, rawEnd)
	                };

	                this.eat(URL$2);
	                break;

	            case FUNCTION$3:
	                if (!cmpStr$4(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')) {
	                    this.error('Function name must be `url`');
	                }

	                this.eat(FUNCTION$3);
	                this.scanner.skipSC();
	                value = this.String();
	                this.scanner.skipSC();
	                this.eat(RIGHTPARENTHESIS$7);
	                break;

	            default:
	                this.error('Url or Function is expected');
	        }

	        return {
	            type: 'Url',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            value: value
	        };
	    },
	    generate: function(node) {
	        this.chunk('url');
	        this.chunk('(');
	        this.node(node.value);
	        this.chunk(')');
	    }
	};

	var Value = {
	    name: 'Value',
	    structure: {
	        children: [[]]
	    },
	    parse: function() {
	        var start = this.scanner.tokenStart;
	        var children = this.readSequence(this.scope.Value);

	        return {
	            type: 'Value',
	            loc: this.getLocation(start, this.scanner.tokenStart),
	            children: children
	        };
	    },
	    generate: function(node) {
	        this.children(node);
	    }
	};

	var WHITESPACE$9 = tokenizer.TYPE.WhiteSpace;
	var SPACE$2 = Object.freeze({
	    type: 'WhiteSpace',
	    loc: null,
	    value: ' '
	});

	var WhiteSpace$1 = {
	    name: 'WhiteSpace',
	    structure: {
	        value: String
	    },
	    parse: function() {
	        this.eat(WHITESPACE$9);
	        return SPACE$2;

	        // return {
	        //     type: 'WhiteSpace',
	        //     loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
	        //     value: this.consume(WHITESPACE)
	        // };
	    },
	    generate: function(node) {
	        this.chunk(node.value);
	    }
	};

	var node = {
	    AnPlusB: AnPlusB,
	    Atrule: Atrule,
	    AtrulePrelude: AtrulePrelude,
	    AttributeSelector: AttributeSelector,
	    Block: Block,
	    Brackets: Brackets,
	    CDC: CDC_1,
	    CDO: CDO_1,
	    ClassSelector: ClassSelector,
	    Combinator: Combinator,
	    Comment: Comment,
	    Declaration: Declaration,
	    DeclarationList: DeclarationList,
	    Dimension: Dimension,
	    Function: _Function,
	    HexColor: HexColor,
	    Identifier: Identifier,
	    IdSelector: IdSelector,
	    MediaFeature: MediaFeature,
	    MediaQuery: MediaQuery,
	    MediaQueryList: MediaQueryList,
	    Nth: Nth,
	    Number: _Number,
	    Operator: Operator,
	    Parentheses: Parentheses,
	    Percentage: Percentage,
	    PseudoClassSelector: PseudoClassSelector,
	    PseudoElementSelector: PseudoElementSelector,
	    Ratio: Ratio,
	    Raw: Raw,
	    Rule: Rule,
	    Selector: Selector,
	    SelectorList: SelectorList,
	    String: _String,
	    StyleSheet: StyleSheet,
	    TypeSelector: TypeSelector,
	    UnicodeRange: UnicodeRange,
	    Url: Url,
	    Value: Value,
	    WhiteSpace: WhiteSpace$1
	};

	var lexer = {
	    generic: true,
	    types: data.types,
	    atrules: data.atrules,
	    properties: data.properties,
	    node: node
	};

	var cmpChar$5 = tokenizer.cmpChar;
	var cmpStr$5 = tokenizer.cmpStr;
	var TYPE$D = tokenizer.TYPE;

	var IDENT$f = TYPE$D.Ident;
	var STRING$2 = TYPE$D.String;
	var NUMBER$8 = TYPE$D.Number;
	var FUNCTION$4 = TYPE$D.Function;
	var URL$3 = TYPE$D.Url;
	var HASH$4 = TYPE$D.Hash;
	var DIMENSION$6 = TYPE$D.Dimension;
	var PERCENTAGE$2 = TYPE$D.Percentage;
	var LEFTPARENTHESIS$5 = TYPE$D.LeftParenthesis;
	var LEFTSQUAREBRACKET$3 = TYPE$D.LeftSquareBracket;
	var COMMA$3 = TYPE$D.Comma;
	var DELIM$5 = TYPE$D.Delim;
	var NUMBERSIGN$3 = 0x0023;  // U+0023 NUMBER SIGN (#)
	var ASTERISK$5 = 0x002A;    // U+002A ASTERISK (*)
	var PLUSSIGN$7 = 0x002B;    // U+002B PLUS SIGN (+)
	var HYPHENMINUS$5 = 0x002D; // U+002D HYPHEN-MINUS (-)
	var SOLIDUS$4 = 0x002F;     // U+002F SOLIDUS (/)
	var U$2 = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

	var _default = function defaultRecognizer(context) {
	    switch (this.scanner.tokenType) {
	        case HASH$4:
	            return this.HexColor();

	        case COMMA$3:
	            context.space = null;
	            context.ignoreWSAfter = true;
	            return this.Operator();

	        case LEFTPARENTHESIS$5:
	            return this.Parentheses(this.readSequence, context.recognizer);

	        case LEFTSQUAREBRACKET$3:
	            return this.Brackets(this.readSequence, context.recognizer);

	        case STRING$2:
	            return this.String();

	        case DIMENSION$6:
	            return this.Dimension();

	        case PERCENTAGE$2:
	            return this.Percentage();

	        case NUMBER$8:
	            return this.Number();

	        case FUNCTION$4:
	            return cmpStr$5(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, 'url(')
	                ? this.Url()
	                : this.Function(this.readSequence, context.recognizer);

	        case URL$3:
	            return this.Url();

	        case IDENT$f:
	            // check for unicode range, it should start with u+ or U+
	            if (cmpChar$5(this.scanner.source, this.scanner.tokenStart, U$2) &&
	                cmpChar$5(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN$7)) {
	                return this.UnicodeRange();
	            } else {
	                return this.Identifier();
	            }

	        case DELIM$5:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            if (code === SOLIDUS$4 ||
	                code === ASTERISK$5 ||
	                code === PLUSSIGN$7 ||
	                code === HYPHENMINUS$5) {
	                return this.Operator(); // TODO: replace with Delim
	            }

	            // TODO: produce a node with Delim node type

	            if (code === NUMBERSIGN$3) {
	                this.error('Hex or identifier is expected', this.scanner.tokenStart + 1);
	            }

	            break;
	    }
	};

	var atrulePrelude = {
	    getNode: _default
	};

	var TYPE$E = tokenizer.TYPE;

	var DELIM$6 = TYPE$E.Delim;
	var IDENT$g = TYPE$E.Ident;
	var DIMENSION$7 = TYPE$E.Dimension;
	var PERCENTAGE$3 = TYPE$E.Percentage;
	var NUMBER$9 = TYPE$E.Number;
	var HASH$5 = TYPE$E.Hash;
	var COLON$5 = TYPE$E.Colon;
	var LEFTSQUAREBRACKET$4 = TYPE$E.LeftSquareBracket;
	var NUMBERSIGN$4 = 0x0023;      // U+0023 NUMBER SIGN (#)
	var ASTERISK$6 = 0x002A;        // U+002A ASTERISK (*)
	var PLUSSIGN$8 = 0x002B;        // U+002B PLUS SIGN (+)
	var SOLIDUS$5 = 0x002F;         // U+002F SOLIDUS (/)
	var FULLSTOP$2 = 0x002E;        // U+002E FULL STOP (.)
	var GREATERTHANSIGN$2 = 0x003E; // U+003E GREATER-THAN SIGN (>)
	var VERTICALLINE$3 = 0x007C;    // U+007C VERTICAL LINE (|)
	var TILDE$2 = 0x007E;           // U+007E TILDE (~)

	function getNode(context) {
	    switch (this.scanner.tokenType) {
	        case LEFTSQUAREBRACKET$4:
	            return this.AttributeSelector();

	        case HASH$5:
	            return this.IdSelector();

	        case COLON$5:
	            if (this.scanner.lookupType(1) === COLON$5) {
	                return this.PseudoElementSelector();
	            } else {
	                return this.PseudoClassSelector();
	            }

	        case IDENT$g:
	            return this.TypeSelector();

	        case NUMBER$9:
	        case PERCENTAGE$3:
	            return this.Percentage();

	        case DIMENSION$7:
	            // throws when .123ident
	            if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP$2) {
	                this.error('Identifier is expected', this.scanner.tokenStart + 1);
	            }
	            break;

	        case DELIM$6:
	            var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);

	            switch (code) {
	                case PLUSSIGN$8:
	                case GREATERTHANSIGN$2:
	                case TILDE$2:
	                    context.space = null;
	                    context.ignoreWSAfter = true;
	                    return this.Combinator();

	                case SOLIDUS$5:  // /deep/
	                    return this.Combinator();

	                case FULLSTOP$2:
	                    return this.ClassSelector();

	                case ASTERISK$6:
	                case VERTICALLINE$3:
	                    return this.TypeSelector();

	                case NUMBERSIGN$4:
	                    return this.IdSelector();
	            }

	            break;
	    }
	}
	var selector = {
	    getNode: getNode
	};

	// https://drafts.csswg.org/css-images-4/#element-notation
	// https://developer.mozilla.org/en-US/docs/Web/CSS/element
	var element = function() {
	    this.scanner.skipSC();

	    var children = this.createSingleNodeList(
	        this.IdSelector()
	    );

	    this.scanner.skipSC();

	    return children;
	};

	// legacy IE function
	// expression( <any-value> )
	var expression = function() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	};

	var TYPE$F = tokenizer.TYPE;
	var rawMode$5 = Raw.mode;

	var COMMA$4 = TYPE$F.Comma;

	// var( <ident> , <value>? )
	var _var = function() {
	    var children = this.createList();

	    this.scanner.skipSC();

	    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
	    children.push(this.Identifier());

	    this.scanner.skipSC();

	    if (this.scanner.tokenType === COMMA$4) {
	        children.push(this.Operator());
	        children.push(this.parseCustomProperty
	            ? this.Value(null)
	            : this.Raw(this.scanner.tokenIndex, rawMode$5.exclamationMarkOrSemicolon, false)
	        );
	    }

	    return children;
	};

	var value = {
	    getNode: _default,
	    '-moz-element': element,
	    'element': element,
	    'expression': expression,
	    'var': _var
	};

	var scope = {
	    AtrulePrelude: atrulePrelude,
	    Selector: selector,
	    Value: value
	};

	var fontFace = {
	    parse: {
	        prelude: null,
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$G = tokenizer.TYPE;

	var STRING$3 = TYPE$G.String;
	var IDENT$h = TYPE$G.Ident;
	var URL$4 = TYPE$G.Url;
	var FUNCTION$5 = TYPE$G.Function;
	var LEFTPARENTHESIS$6 = TYPE$G.LeftParenthesis;

	var _import = {
	    parse: {
	        prelude: function() {
	            var children = this.createList();

	            this.scanner.skipSC();

	            switch (this.scanner.tokenType) {
	                case STRING$3:
	                    children.push(this.String());
	                    break;

	                case URL$4:
	                case FUNCTION$5:
	                    children.push(this.Url());
	                    break;

	                default:
	                    this.error('String or url() is expected');
	            }

	            if (this.lookupNonWSType(0) === IDENT$h ||
	                this.lookupNonWSType(0) === LEFTPARENTHESIS$6) {
	                children.push(this.WhiteSpace());
	                children.push(this.MediaQueryList());
	            }

	            return children;
	        },
	        block: null
	    }
	};

	var media = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.MediaQueryList()
	            );
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var page = {
	    parse: {
	        prelude: function() {
	            return this.createSingleNodeList(
	                this.SelectorList()
	            );
	        },
	        block: function() {
	            return this.Block(true);
	        }
	    }
	};

	var TYPE$H = tokenizer.TYPE;

	var WHITESPACE$a = TYPE$H.WhiteSpace;
	var COMMENT$9 = TYPE$H.Comment;
	var IDENT$i = TYPE$H.Ident;
	var FUNCTION$6 = TYPE$H.Function;
	var COLON$6 = TYPE$H.Colon;
	var LEFTPARENTHESIS$7 = TYPE$H.LeftParenthesis;

	function consumeRaw$5() {
	    return this.createSingleNodeList(
	        this.Raw(this.scanner.tokenIndex, null, false)
	    );
	}

	function parentheses() {
	    this.scanner.skipSC();

	    if (this.scanner.tokenType === IDENT$i &&
	        this.lookupNonWSType(1) === COLON$6) {
	        return this.createSingleNodeList(
	            this.Declaration()
	        );
	    }

	    return readSequence.call(this);
	}

	function readSequence() {
	    var children = this.createList();
	    var space = null;
	    var child;

	    this.scanner.skipSC();

	    scan:
	    while (!this.scanner.eof) {
	        switch (this.scanner.tokenType) {
	            case WHITESPACE$a:
	                space = this.WhiteSpace();
	                continue;

	            case COMMENT$9:
	                this.scanner.next();
	                continue;

	            case FUNCTION$6:
	                child = this.Function(consumeRaw$5, this.scope.AtrulePrelude);
	                break;

	            case IDENT$i:
	                child = this.Identifier();
	                break;

	            case LEFTPARENTHESIS$7:
	                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
	                break;

	            default:
	                break scan;
	        }

	        if (space !== null) {
	            children.push(space);
	            space = null;
	        }

	        children.push(child);
	    }

	    return children;
	}

	var supports = {
	    parse: {
	        prelude: function() {
	            var children = readSequence.call(this);

	            if (this.getFirstListNode(children) === null) {
	                this.error('Condition is expected');
	            }

	            return children;
	        },
	        block: function() {
	            return this.Block(false);
	        }
	    }
	};

	var atrule = {
	    'font-face': fontFace,
	    'import': _import,
	    'media': media,
	    'page': page,
	    'supports': supports
	};

	var dir = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var has$1 = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var lang = {
	    parse: function() {
	        return this.createSingleNodeList(
	            this.Identifier()
	        );
	    }
	};

	var selectorList = {
	    parse: function selectorList() {
	        return this.createSingleNodeList(
	            this.SelectorList()
	        );
	    }
	};

	var matches = selectorList;

	var not = selectorList;

	var ALLOW_OF_CLAUSE = true;

	var nthWithOfClause = {
	    parse: function nthWithOfClause() {
	        return this.createSingleNodeList(
	            this.Nth(ALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthChild = nthWithOfClause;

	var nthLastChild = nthWithOfClause;

	var DISALLOW_OF_CLAUSE = false;

	var nth$1 = {
	    parse: function nth() {
	        return this.createSingleNodeList(
	            this.Nth(DISALLOW_OF_CLAUSE)
	        );
	    }
	};

	var nthLastOfType = nth$1;

	var nthOfType = nth$1;

	var slotted = {
	    parse: function compoundSelector() {
	        return this.createSingleNodeList(
	            this.Selector()
	        );
	    }
	};

	var pseudo = {
	    'dir': dir,
	    'has': has$1,
	    'lang': lang,
	    'matches': matches,
	    'not': not,
	    'nth-child': nthChild,
	    'nth-last-child': nthLastChild,
	    'nth-last-of-type': nthLastOfType,
	    'nth-of-type': nthOfType,
	    'slotted': slotted
	};

	var parser = {
	    parseContext: {
	        default: 'StyleSheet',
	        stylesheet: 'StyleSheet',
	        atrule: 'Atrule',
	        atrulePrelude: function(options) {
	            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
	        },
	        mediaQueryList: 'MediaQueryList',
	        mediaQuery: 'MediaQuery',
	        rule: 'Rule',
	        selectorList: 'SelectorList',
	        selector: 'Selector',
	        block: function() {
	            return this.Block(true);
	        },
	        declarationList: 'DeclarationList',
	        declaration: 'Declaration',
	        value: 'Value'
	    },
	    scope: scope,
	    atrule: atrule,
	    pseudo: pseudo,
	    node: node
	};

	var walker = {
	    node: node
	};

	function merge() {
	    var dest = {};

	    for (var i = 0; i < arguments.length; i++) {
	        var src = arguments[i];
	        for (var key in src) {
	            dest[key] = src[key];
	        }
	    }

	    return dest;
	}

	var syntax = create$5.create(
	    merge(
	        lexer,
	        parser,
	        walker
	    )
	);

	var lib = syntax;

	class Sheet {
		constructor(url, hooks) {

			if (hooks) {
				this.hooks = hooks;
			} else {
				this.hooks = {};
				this.hooks.onUrl = new Hook(this);
				this.hooks.onAtPage = new Hook(this);
				this.hooks.onAtMedia = new Hook(this);
				this.hooks.onRule = new Hook(this);
				this.hooks.onDeclaration = new Hook(this);
				this.hooks.onSelector = new Hook(this);
				this.hooks.onPseudoSelector = new Hook(this);

				this.hooks.onContent = new Hook(this);
				this.hooks.onImport = new Hook(this);

				this.hooks.beforeTreeParse = new Hook(this);
				this.hooks.beforeTreeWalk = new Hook(this);
				this.hooks.afterTreeWalk = new Hook(this);
			}

			try {
				this.url = new URL(url, window.location.href);
			} catch (e) {
				this.url = new URL(window.location.href);
			}
		}



		// parse
		async parse(text) {
			this.text = text;

			await this.hooks.beforeTreeParse.trigger(this.text, this);

			// send to csstree
			this.ast = lib.parse(this._text);

			await this.hooks.beforeTreeWalk.trigger(this.ast);

			// Replace urls
			this.replaceUrls(this.ast);

			// Scope
			this.id = UUID();
			// this.addScope(this.ast, this.uuid);

			// Replace IDs with data-id
			this.replaceIds(this.ast);

			this.imported = [];

			// Trigger Hooks
			this.urls(this.ast);
			this.rules(this.ast);
			this.atrules(this.ast);

			await this.hooks.afterTreeWalk.trigger(this.ast, this);

			// return ast
			return this.ast;
		}



		insertRule(rule) {
			let inserted = this.ast.children.appendData(rule);
			inserted.forEach((item) => {
				this.declarations(item);
			});
		}

		urls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					this.hooks.onUrl.trigger(node, item, list);
				}
			});
		}

		atrules(ast) {
			lib.walk(ast, {
				visit: "Atrule",
				enter: (node, item, list) => {
					const basename = lib.keyword(node.name).basename;

					if (basename === "page") {
						this.hooks.onAtPage.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "media") {
						this.hooks.onAtMedia.trigger(node, item, list);
						this.declarations(node, item, list);
					}

					if (basename === "import") {
						this.hooks.onImport.trigger(node, item, list);
						this.imports(node, item, list);
					}
				}
			});
		}


		rules(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (ruleNode, ruleItem, rulelist) => {
					// console.log("rule", ruleNode);

					this.hooks.onRule.trigger(ruleNode, ruleItem, rulelist);
					this.declarations(ruleNode, ruleItem, rulelist);
					this.onSelector(ruleNode, ruleItem, rulelist);

				}
			});
		}

		declarations(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Declaration",
				enter: (declarationNode, dItem, dList) => {
					// console.log(declarationNode);

					this.hooks.onDeclaration.trigger(declarationNode, dItem, dList, {ruleNode, ruleItem, rulelist});

					if (declarationNode.property === "content") {
						lib.walk(declarationNode, {
							visit: "Function",
							enter: (funcNode, fItem, fList) => {
								this.hooks.onContent.trigger(funcNode, fItem, fList, {declarationNode, dItem, dList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}

				}
			});
		}

		// add pseudo elements to parser
		onSelector(ruleNode, ruleItem, rulelist) {
			lib.walk(ruleNode, {
				visit: "Selector",
				enter: (selectNode, selectItem, selectList) => {
					// console.log(selectNode);
					this.hooks.onSelector.trigger(selectNode, selectItem, selectList, {ruleNode, ruleItem, rulelist});

					if (selectNode.children.forEach(node => {if (node.type === "PseudoElementSelector") {
						lib.walk(node, {
							visit: "PseudoElementSelector",
							enter: (pseudoNode, pItem, pList) => {
								this.hooks.onPseudoSelector.trigger(pseudoNode, pItem, pList, {selectNode, selectItem, selectList}, {ruleNode, ruleItem, rulelist});
							}
						});
					}}));
					// else {
					// 	console.log("dommage");
					// }

				}
			});
		}

		replaceUrls(ast) {
			lib.walk(ast, {
				visit: "Url",
				enter: (node, item, list) => {
					let content = node.value.value;
					if ((node.value.type === "Raw" && content.startsWith("data:")) || (node.value.type === "String" && (content.startsWith("\"data:") || content.startsWith("'data:")))) ; else {
						let href = content.replace(/["']/g, "");
						let url = new URL(href, this.url);
						node.value.value = url.toString();
					}
				}
			});
		}

		addScope(ast, id) {
			// Get all selector lists
			// add an id
			lib.walk(ast, {
				visit: "Selector",
				enter: (node, item, list) => {
					let children = node.children;
					children.prepend(children.createItem({
						type: "WhiteSpace",
						value: " "
					}));
					children.prepend(children.createItem({
						type: "IdSelector",
						name: id,
						loc: null,
						children: null
					}));
				}
			});
		}

		getNamedPageSelectors(ast) {
			let namedPageSelectors = {};
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {
					lib.walk(node, {
						visit: "Declaration",
						enter: (declaration, dItem, dList) => {
							if (declaration.property === "page") {
								let value = declaration.value.children.first();
								let name = value.name;
								let selector = lib.generate(node.prelude);
								namedPageSelectors[name] = {
									name: name,
									selector: selector
								};

								// dList.remove(dItem);

								// Add in page break
								declaration.property = "break-before";
								value.type = "Identifier";
								value.name = "always";

							}
						}
					});
				}
			});
			return namedPageSelectors;
		}

		replaceIds(ast) {
			lib.walk(ast, {
				visit: "Rule",
				enter: (node, item, list) => {

					lib.walk(node, {
						visit: "IdSelector",
						enter: (idNode, idItem, idList) => {
							let name = idNode.name;
							idNode.flags = null;
							idNode.matcher = "=";
							idNode.name = {type: "Identifier", loc: null, name: "data-id"};
							idNode.type = "AttributeSelector";
							idNode.value = {type: "String", loc: null, value: `"${name}"`};
						}
					});
				}
			});
		}

		imports(node, item, list) {
			// console.log("import", node, item, list);
			let queries = [];
			lib.walk(node, {
				visit: "MediaQuery",
				enter: (mqNode, mqItem, mqList) => {
					lib.walk(mqNode, {
						visit: "Identifier",
						enter: (identNode, identItem, identList) => {
							queries.push(identNode.name);
						}
					});
				}
			});

			// Just basic media query support for now
			let shouldNotApply = queries.some((query, index) => {
				let q = query;
				if (q === "not") {
					q = queries[index + 1];
					return !(q === "screen" || q === "speech");
				} else {
					return (q === "screen" || q === "speech");
				}
			});

			if (shouldNotApply) {
				return;
			}

			lib.walk(node, {
				visit: "String",
				enter: (urlNode, urlItem, urlList) => {
					let href = urlNode.value.replace(/["']/g, "");
					let url = new URL(href, this.url);
					let value = url.toString();

					this.imported.push(value);

					// Remove the original
					list.remove(item);
				}
			});
		}

		set text(t) {
			this._text = t;
		}

		get text() {
			return this._text;
		}

		// generate string
		toString(ast) {
			return lib.generate(ast || this.ast);
		}
	}

	var baseStyles = `
:root {
	--pagedjs-width: 8.5in;
	--pagedjs-height: 11in;
	--pagedjs-width-right: 8.5in;
	--pagedjs-height-right: 11in;
	--pagedjs-width-left: 8.5in;
	--pagedjs-height-left: 11in;
	--pagedjs-pagebox-width: 8.5in;
	--pagedjs-pagebox-height: 11in;
	--pagedjs-margin-top: 1in;
	--pagedjs-margin-right: 1in;
	--pagedjs-margin-bottom: 1in;
	--pagedjs-margin-left: 1in;
	--pagedjs-padding-top: 0mm;
	--pagedjs-padding-right: 0mm;
	--pagedjs-padding-bottom: 0mm;
	--pagedjs-padding-left: 0mm;
	--pagedjs-border-top: 0mm;
	--pagedjs-border-right: 0mm;
	--pagedjs-border-bottom: 0mm;
	--pagedjs-border-left: 0mm;
	--pagedjs-bleed-top: 0mm;
	--pagedjs-bleed-right: 0mm;
	--pagedjs-bleed-bottom: 0mm;
	--pagedjs-bleed-left: 0mm;
	--pagedjs-bleed-right-top: 0mm;
	--pagedjs-bleed-right-right: 0mm;
	--pagedjs-bleed-right-bottom: 0mm;
	--pagedjs-bleed-right-left: 0mm;
	--pagedjs-bleed-left-top: 0mm;
	--pagedjs-bleed-left-right: 0mm;
	--pagedjs-bleed-left-bottom: 0mm;
	--pagedjs-bleed-left-left: 0mm;
	--pagedjs-crop-color: black;
	--pagedjs-crop-offset: 2mm;
	--pagedjs-crop-stroke: 1px;
	--pagedjs-cross-size: 5mm;
	--pagedjs-mark-cross-display: none;
	--pagedjs-mark-crop-display: none;
	--pagedjs-page-count: 0;
	--pagedjs-page-counter-increment: 1;
}

@page {
	size: letter;
	margin: 0;
}

.pagedjs_sheet {
	box-sizing: border-box;
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
	overflow: hidden;
	position: relative;
	display: grid;
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left) - var(--pagedjs-bleed-right)) [bleed-right] var(--pagedjs-bleed-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-top) - var(--pagedjs-bleed-bottom)) [bleed-bottom] var(--pagedjs-bleed-bottom);
}

.pagedjs_right_page .pagedjs_sheet {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-right-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-right-left) - var(--pagedjs-bleed-right-right)) [bleed-right] var(--pagedjs-bleed-right-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-right-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-right-top) - var(--pagedjs-bleed-right-bottom)) [bleed-bottom] var(--pagedjs-bleed-right-bottom);
}

.pagedjs_left_page .pagedjs_sheet {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
	grid-template-columns: [bleed-left] var(--pagedjs-bleed-left-left) [sheet-center] calc(var(--pagedjs-width) - var(--pagedjs-bleed-left-left) - var(--pagedjs-bleed-left-right)) [bleed-right] var(--pagedjs-bleed-left-right);
	grid-template-rows: [bleed-top] var(--pagedjs-bleed-left-top) [sheet-middle] calc(var(--pagedjs-height) - var(--pagedjs-bleed-left-top) - var(--pagedjs-bleed-left-bottom)) [bleed-bottom] var(--pagedjs-bleed-left-bottom);
}

.pagedjs_bleed {
	display: flex;
	align-items: center;
	justify-content: center;
	flex-wrap: nowrap;
	overflow: hidden;
}

.pagedjs_bleed-top {
	grid-column: bleed-left / -1;
	grid-row: bleed-top;
	flex-direction: row;
}

.pagedjs_bleed-bottom {
	grid-column: bleed-left / -1;
	grid-row: bleed-bottom;
	flex-direction: row;
}

.pagedjs_bleed-left {
	grid-column: bleed-left;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_bleed-right {
	grid-column: bleed-right;
	grid-row: bleed-top / -1;
	flex-direction: column;
}

.pagedjs_marks-crop {
	display: var(--pagedjs-mark-crop-display);
	flex-grow: 0;
	flex-shrink: 0;
	z-index: 9999999999;
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-stroke));
	border-right: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(1) {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-stroke));
	border-left: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop:nth-child(3) {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-top .pagedjs_marks-crop {
	align-self: flex-start;
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-top .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-bottom .pagedjs_marks-crop {
	align-self: flex-end;
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_right_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-bottom .pagedjs_marks-crop {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-top) - var(--pagedjs-crop-stroke));
	border-bottom: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-right-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(1),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(1) {
	height: calc(var(--pagedjs-bleed-left-top) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-bottom) - var(--pagedjs-crop-stroke));
	border-top: var(--pagedjs-crop-stroke) solid var(--pagedjs-crop-color);
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-right-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop:nth-child(3),
.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop:nth-child(3) {
	height: calc(var(--pagedjs-bleed-left-bottom) - var(--pagedjs-crop-stroke));
}

.pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left) - var(--pagedjs-crop-offset));
	align-self: flex-start;
}

.pagedjs_right_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-left) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-left .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-left) - var(--pagedjs-crop-offset));
}

.pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right) - var(--pagedjs-crop-offset));
	align-self: flex-end;
}

.pagedjs_right_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-right-right) - var(--pagedjs-crop-offset));
}

.pagedjs_left_page .pagedjs_bleed-right .pagedjs_marks-crop {
	width: calc(var(--pagedjs-bleed-left-right) - var(--pagedjs-crop-offset));
}

.pagedjs_marks-middle {
	display: flex;
	flex-grow: 1;
	flex-shrink: 0;
	align-items: center;
	justify-content: center;
}

.pagedjs_marks-cross {
	display: var(--pagedjs-mark-cross-display);
	background-image: url(data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz48IURPQ1RZUEUgc3ZnIFBVQkxJQyAiLS8vVzNDLy9EVEQgU1ZHIDEuMS8vRU4iICJodHRwOi8vd3d3LnczLm9yZy9HcmFwaGljcy9TVkcvMS4xL0RURC9zdmcxMS5kdGQiPjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iTGF5ZXJfMSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxuczp4bGluaz0iaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluayIgeD0iMHB4IiB5PSIwcHgiIHdpZHRoPSIzMi41MzdweCIgaGVpZ2h0PSIzMi41MzdweCIgdmlld0JveD0iMC4xMDQgMC4xMDQgMzIuNTM3IDMyLjUzNyIgZW5hYmxlLWJhY2tncm91bmQ9Im5ldyAwLjEwNCAwLjEwNCAzMi41MzcgMzIuNTM3IiB4bWw6c3BhY2U9InByZXNlcnZlIj48cGF0aCBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIGQ9Ik0yOS45MzEsMTYuMzczYzAsNy40ODktNi4wNjgsMTMuNTYtMTMuNTU4LDEzLjU2Yy03LjQ4MywwLTEzLjU1Ny02LjA3Mi0xMy41NTctMTMuNTZjMC03LjQ4Niw2LjA3NC0xMy41NTQsMTMuNTU3LTEzLjU1NEMyMy44NjIsMi44MTksMjkuOTMxLDguODg3LDI5LjkzMSwxNi4zNzN6Ii8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjMuMzg5MyIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMC4xMDQiIHkxPSIxNi4zNzMiIHgyPSIzMi42NDIiIHkyPSIxNi4zNzMiLz48bGluZSBmaWxsPSJub25lIiBzdHJva2U9IiNGRkZGRkYiIHN0cm9rZS13aWR0aD0iMy4zODkzIiBzdHJva2UtbWl0ZXJsaW1pdD0iMTAiIHgxPSIxNi4zNzMiIHkxPSIwLjEwNCIgeDI9IjE2LjM3MyIgeTI9IjMyLjY0MiIvPjxwYXRoIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIzLjM4OTMiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgZD0iTTI0LjUwOCwxNi4zNzNjMCw0LjQ5Ni0zLjYzOCw4LjEzNS04LjEzNSw4LjEzNWMtNC40OTEsMC04LjEzNS0zLjYzOC04LjEzNS04LjEzNWMwLTQuNDg5LDMuNjQ0LTguMTM1LDguMTM1LTguMTM1QzIwLjg2OSw4LjIzOSwyNC41MDgsMTEuODg0LDI0LjUwOCwxNi4zNzN6Ii8+PHBhdGggZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiBkPSJNMjkuOTMxLDE2LjM3M2MwLDcuNDg5LTYuMDY4LDEzLjU2LTEzLjU1OCwxMy41NmMtNy40ODMsMC0xMy41NTctNi4wNzItMTMuNTU3LTEzLjU2YzAtNy40ODYsNi4wNzQtMTMuNTU0LDEzLjU1Ny0xMy41NTRDMjMuODYyLDIuODE5LDI5LjkzMSw4Ljg4NywyOS45MzEsMTYuMzczeiIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iIzAwMDAwMCIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjAuMTA0IiB5MT0iMTYuMzczIiB4Mj0iMzIuNjQyIiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjMDAwMDAwIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iMC4xMDQiIHgyPSIxNi4zNzMiIHkyPSIzMi42NDIiLz48cGF0aCBkPSJNMjQuNTA4LDE2LjM3M2MwLDQuNDk2LTMuNjM4LDguMTM1LTguMTM1LDguMTM1Yy00LjQ5MSwwLTguMTM1LTMuNjM4LTguMTM1LTguMTM1YzAtNC40ODksMy42NDQtOC4xMzUsOC4xMzUtOC4xMzVDMjAuODY5LDguMjM5LDI0LjUwOCwxMS44ODQsMjQuNTA4LDE2LjM3MyIvPjxsaW5lIGZpbGw9Im5vbmUiIHN0cm9rZT0iI0ZGRkZGRiIgc3Ryb2tlLXdpZHRoPSIwLjY3NzgiIHN0cm9rZS1taXRlcmxpbWl0PSIxMCIgeDE9IjguMjM5IiB5MT0iMTYuMzczIiB4Mj0iMjQuNTA4IiB5Mj0iMTYuMzczIi8+PGxpbmUgZmlsbD0ibm9uZSIgc3Ryb2tlPSIjRkZGRkZGIiBzdHJva2Utd2lkdGg9IjAuNjc3OCIgc3Ryb2tlLW1pdGVybGltaXQ9IjEwIiB4MT0iMTYuMzczIiB5MT0iOC4yMzkiIHgyPSIxNi4zNzMiIHkyPSIyNC41MDgiLz48L3N2Zz4=);
  background-repeat: no-repeat;
  background-position: 50% 50%;
  background-size: var(--pagedjs-cross-size);

  z-index: 2147483647;
	width: var(--pagedjs-cross-size);
	height: var(--pagedjs-cross-size);
}

.pagedjs_pagebox {
	box-sizing: border-box;
	width: var(--pagedjs-pagebox-width);
	height: var(--pagedjs-pagebox-height);
	position: relative;
	display: grid;
	grid-template-columns: [left] var(--pagedjs-margin-left) [center] calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right)) [right] var(--pagedjs-margin-right);
	grid-template-rows: [header] var(--pagedjs-margin-top) [page] calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom)) [footer] var(--pagedjs-margin-bottom);
	grid-column: sheet-center;
	grid-row: sheet-middle;
}

.pagedjs_pagebox * {
	box-sizing: border-box;
}

.pagedjs_margin-top {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-top);
	grid-column: center;
	grid-row: header;
	flex-wrap: nowrap;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-top-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: left;
	grid-row: header;
}

.pagedjs_margin-top-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-top);
	display: flex;
	grid-column: right;
	grid-row: header;
}

.pagedjs_margin-top-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-top-right-corner {
	width: var(--pagedjs-margin-right);
}

.pagedjs_margin-right {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-right);
	right: 0;
	grid-column: right;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.3333%);
	grid-template-columns: 100%;
}

.pagedjs_margin-bottom {
	width: calc(var(--pagedjs-pagebox-width) - var(--pagedjs-margin-left) - var(--pagedjs-margin-right));
	height: var(--pagedjs-margin-bottom);
	grid-column: center;
	grid-row: footer;
	display: grid;
	grid-template-columns: repeat(3, 1fr);
	grid-template-rows: 100%;
}

.pagedjs_margin-bottom-left-corner-holder {
	width: var(--pagedjs-margin-left);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: left;
	grid-row: footer;
}

.pagedjs_margin-bottom-right-corner-holder {
	width: var(--pagedjs-margin-right);
	height: var(--pagedjs-margin-bottom);
	display: flex;
	grid-column: right;
	grid-row: footer;
}

.pagedjs_margin-bottom-left-corner {
	width: var(--pagedjs-margin-left);
}

.pagedjs_margin-bottom-right-corner {
	width: var(--pagedjs-margin-right);
}



.pagedjs_margin-left {
	height: calc(var(--pagedjs-pagebox-height) - var(--pagedjs-margin-top) - var(--pagedjs-margin-bottom));
	width: var(--pagedjs-margin-left);
	grid-column: left;
	grid-row: page;
	display: grid;
	grid-template-rows: repeat(3, 33.33333%);
	grid-template-columns: 100%;
}

.pagedjs_pages .pagedjs_pagebox .pagedjs_margin:not(.hasContent) {
	visibility: hidden;
}

.pagedjs_pagebox > .pagedjs_area {
	grid-column: center;
	grid-row: page;
	width: 100%;
	height: 100%;
	padding: var(--pagedjs-padding-top) var(--pagedjs-padding-right) var(--pagedjs-padding-bottom) var(--pagedjs-padding-left);
	border-top: var(--pagedjs-border-top);
	border-right: var(--pagedjs-border-right);
	border-bottom: var(--pagedjs-border-bottom);
	border-left: var(--pagedjs-border-left);
}

.pagedjs_pagebox > .pagedjs_area > .pagedjs_page_content {
	width: 100%;
	height: 100%;
	position: relative;
	column-fill: auto;
}

.pagedjs_page {
	counter-increment: page var(--pagedjs-page-counter-increment);
	width: var(--pagedjs-width);
	height: var(--pagedjs-height);
}

.pagedjs_page.pagedjs_right_page {
	width: var(--pagedjs-width-right);
	height: var(--pagedjs-height-right);
}

.pagedjs_page.pagedjs_left_page {
	width: var(--pagedjs-width-left);
	height: var(--pagedjs-height-left);
}

.pagedjs_pages {
	counter-reset: pages var(--pagedjs-page-count);
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_margin-right-middle,
.pagedjs_margin-left-middle  {
	display: flex;
	align-items: center;
}

.pagedjs_margin-right-top,
.pagedjs_margin-left-top  {
	display: flex;
	align-items: flex-top;
}


.pagedjs_margin-right-bottom,
.pagedjs_margin-left-bottom  {
	display: flex;
	align-items: flex-end;
}



/*
.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center {
	height: 100%;
	display: none;
	align-items: center;
	flex: 1 0 33%;
	margin: 0 auto;
}

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-right-top {
	display: none;
	align-items: flex-start;
}

.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-left-middle {
	display: none;
	align-items: center;
}

.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-bottom {
	display: none;
	align-items: flex-end;
}
*/

.pagedjs_pagebox .pagedjs_margin-top-left,
.pagedjs_pagebox .pagedjs_margin-top-right-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-left,
.pagedjs_pagebox .pagedjs_margin-bottom-right-corner { text-align: left; }

.pagedjs_pagebox .pagedjs_margin-top-left-corner,
.pagedjs_pagebox .pagedjs_margin-top-right,
.pagedjs_pagebox .pagedjs_margin-bottom-left-corner,
.pagedjs_pagebox .pagedjs_margin-bottom-right { text-align: right; }

.pagedjs_pagebox .pagedjs_margin-top-center,
.pagedjs_pagebox .pagedjs_margin-bottom-center,
.pagedjs_pagebox .pagedjs_margin-left-top,
.pagedjs_pagebox .pagedjs_margin-left-middle,
.pagedjs_pagebox .pagedjs_margin-left-bottom,
.pagedjs_pagebox .pagedjs_margin-right-top,
.pagedjs_pagebox .pagedjs_margin-right-middle,
.pagedjs_pagebox .pagedjs_margin-right-bottom { text-align: center; }

.pagedjs_pages .pagedjs_margin .pagedjs_margin-content {
	width: 100%;
}

.pagedjs_pages .pagedjs_margin-left .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-top .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-right .pagedjs_margin-content::after,
.pagedjs_pages .pagedjs_margin-bottom .pagedjs_margin-content::after {
	display: block;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to] {
	margin-bottom: unset;
	padding-bottom: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] {
	text-indent: unset;
	margin-top: unset;
	padding-top: unset;
	initial-letter: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from] > *::first-letter,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::first-letter {
	color: unset;
	font-size: unset;
	font-weight: unset;
	font-family: unset;
	color: unset;
	line-height: unset;
	float: unset;
	padding: unset;
	margin: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]:after,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-to]::after {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]:before,
.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div [data-split-from]::before {
	content: unset;
}

.pagedjs_pages > .pagedjs_page > .pagedjs_sheet > .pagedjs_pagebox > .pagedjs_area > div li[data-split-from]:first-of-type {
	list-style: none;
}

/*
[data-page]:not([data-split-from]),
[data-break-before="page"]:not([data-split-from]),
[data-break-before="always"]:not([data-split-from]),
[data-break-before="left"]:not([data-split-from]),
[data-break-before="right"]:not([data-split-from]),
[data-break-before="recto"]:not([data-split-from]),
[data-break-before="verso"]:not([data-split-from])
{
	break-before: column;
}

[data-page]:not([data-split-to]),
[data-break-after="page"]:not([data-split-to]),
[data-break-after="always"]:not([data-split-to]),
[data-break-after="left"]:not([data-split-to]),
[data-break-after="right"]:not([data-split-to]),
[data-break-after="recto"]:not([data-split-to]),
[data-break-after="verso"]:not([data-split-to])
{
	break-after: column;
}
*/

.pagedjs_clear-after::after {
	content: none !important;
}

[data-align-last-split-element='justify'] {
	text-align-last: justify;
}


@media print {
	html {
		width: 100%;
		height: 100%;
	}
	body {
		margin: 0;
		padding: 0;
		width: 100% !important;
		height: 100% !important;
		min-width: 100%;
		max-width: 100%;
		min-height: 100%;
		max-height: 100%;
	}
	.pagedjs_pages {
		width: auto;
		display: block !important;
		transform: none !important;
		height: 100% !important;
		min-height: 100%;
		max-height: 100%;
		overflow: visible;
	}
	.pagedjs_page {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
		page-break-after: always;
		break-after: page;
	}
	.pagedjs_sheet {
		margin: 0;
		padding: 0;
		max-height: 100%;
		min-height: 100%;
		height: 100% !important;
	}
}
`;

	async function request(url, options={}) {
		return new Promise(function(resolve, reject) {
			let request = new XMLHttpRequest();

			request.open(options.method || "get", url, true);

			for (let i in options.headers) {
				request.setRequestHeader(i, options.headers[i]);
			}

			request.withCredentials = options.credentials === "include";

			request.onload = () => {
				// Chrome returns a status code of 0 for local files
				const status = request.status === 0 && url.startsWith("file://") ? 200 : request.status;
				resolve(new Response(request.responseText, {status}));
			};

			request.onerror = reject;

			request.send(options.body || null);
		});
	}

	class Polisher {
		constructor(setup) {
			this.sheets = [];
			this.inserted = [];

			this.hooks = {};
			this.hooks.onUrl = new Hook(this);
			this.hooks.onAtPage = new Hook(this);
			this.hooks.onAtMedia = new Hook(this);
			this.hooks.onRule = new Hook(this);
			this.hooks.onDeclaration = new Hook(this);
			this.hooks.onContent = new Hook(this);
			this.hooks.onSelector = new Hook(this);
			this.hooks.onPseudoSelector = new Hook(this);

			this.hooks.onImport = new Hook(this);

			this.hooks.beforeTreeParse = new Hook(this);
			this.hooks.beforeTreeWalk = new Hook(this);
			this.hooks.afterTreeWalk = new Hook(this);

			if (setup !== false) {
				this.setup();
			}
		}

		setup() {
			this.base = this.insert(baseStyles);
			this.styleEl = document.createElement("style");
			document.head.appendChild(this.styleEl);
			this.styleSheet = this.styleEl.sheet;
			return this.styleSheet;
		}

		async add() {
			let fetched = [];
			let urls = [];

			for (var i = 0; i < arguments.length; i++) {
				let f;

				if (typeof arguments[i] === "object") {
					for (let url in arguments[i]) {
						let obj = arguments[i];
						f = new Promise(function(resolve, reject) {
							urls.push(url);
							resolve(obj[url]);
						});
					}
				} else {
					urls.push(arguments[i]);
					f = request(arguments[i]).then((response) => {
						return response.text();
					});
				}


				fetched.push(f);
			}

			return await Promise.all(fetched)
				.then(async (originals) => {
					let text = "";
					for (let index = 0; index < originals.length; index++) {
						text = await this.convertViaSheet(originals[index], urls[index]);
						this.insert(text);
					}
					return text;
				});
		}

		async convertViaSheet(cssStr, href) {
			let sheet = new Sheet(href, this.hooks);
			await sheet.parse(cssStr);

			// Insert the imported sheets first
			for (let url of sheet.imported) {
				let str = await request(url).then((response) => {
					return response.text();
				});
				let text = await this.convertViaSheet(str, url);
				this.insert(text);
			}

			this.sheets.push(sheet);

			if (typeof sheet.width !== "undefined") {
				this.width = sheet.width;
			}
			if (typeof sheet.height !== "undefined") {
				this.height = sheet.height;
			}
			if (typeof sheet.orientation !== "undefined") {
				this.orientation = sheet.orientation;
			}
			return sheet.toString();
		}

		insert(text){
			let head = document.querySelector("head");
			let style = document.createElement("style");
			style.type = "text/css";
			style.setAttribute("data-pagedjs-inserted-styles", "true");

			style.appendChild(document.createTextNode(text));

			head.appendChild(style);

			this.inserted.push(style);
			return style;
		}

		destroy() {
			this.styleEl.remove();
			this.inserted.forEach((s) => {
				s.remove();
			});
			this.sheets = [];
		}
	}

	class Handler {
		constructor(chunker, polisher, caller) {
			let hooks = Object.assign({}, chunker && chunker.hooks, polisher && polisher.hooks, caller && caller.hooks);
			this.chunker = chunker;
			this.polisher = polisher;
			this.caller = caller;

			for (let name in hooks) {
				if (name in this) {
					let hook = hooks[name];
					hook.register(this[name].bind(this));
				}
			}
		}
	}

	eventEmitter(Handler.prototype);

	// https://www.w3.org/TR/css3-page/#page-size-prop

	var pageSizes = {
		"A0": {
			width: {
				value: 841,
				unit: "mm"
			},
			height: {
				value: 1189,
				unit: "mm"
			}
		},
		"A1": {
			width: {
				value: 594,
				unit: "mm"
			},
			height: {
				value: 841,
				unit: "mm"
			}
		},
		"A2": {
			width: {
				value: 420,
				unit: "mm"
			},
			height: {
				value: 594,
				unit: "mm"
			}
		},
		"A3": {
			width: {
				value: 297,
				unit: "mm"
			},
			height: {
				value: 420,
				unit: "mm"
			}
		},
		"A4": {
			width: {
				value: 210,
				unit: "mm"
			},
			height: {
				value: 297,
				unit: "mm"
			}
		},
		"A5": {
			width: {
				value: 148,
				unit: "mm"
			},
			height: {
				value: 210,
				unit: "mm"
			}
		},
		"A6": {
			width: {
				value: 105,
				unit: "mm"
			},
			height: {
				value: 148,
				unit: "mm"
			}
		},
		"A7": {
			width: {
				value: 74,
				unit: "mm"
			},
			height: {
				value: 105,
				unit: "mm"
			}
		},
		"A8": {
			width: {
				value: 52,
				unit: "mm"
			},
			height: {
				value: 74,
				unit: "mm"
			}
		},
		"A9": {
			width: {
				value: 37,
				unit: "mm"
			},
			height: {
				value: 52,
				unit: "mm"
			}
		},
		"A10": {
			width: {
				value: 26,
				unit: "mm"
			},
			height: {
				value: 37,
				unit: "mm"
			}
		},
		"B4": {
			width: {
				value: 250,
				unit: "mm"
			},
			height: {
				value: 353,
				unit: "mm"
			}
		},
		"B5": {
			width: {
				value: 176,
				unit: "mm"
			},
			height: {
				value: 250,
				unit: "mm"
			}
		},
		"letter": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 11,
				unit: "in"
			}
		},
		"legal": {
			width: {
				value: 8.5,
				unit: "in"
			},
			height: {
				value: 14,
				unit: "in"
			}
		},
		"ledger": {
			width: {
				value: 11,
				unit: "in"
			},
			height: {
				value: 17,
				unit: "in"
			}
		}
	};

	class AtPage extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.pages = {};

			this.width = undefined;
			this.height = undefined;
			this.orientation = undefined;
			this.marginalia = {};
		}

		pageModel(selector) {
			return {
				selector: selector,
				name: undefined,
				psuedo: undefined,
				nth: undefined,
				marginalia: {},
				width: undefined,
				height: undefined,
				orientation: undefined,
				margin: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				padding: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				border: {
					top: {},
					right: {},
					left: {},
					bottom: {}
				},
				backgroundOrigin: undefined,
				block: {},
				marks: undefined
			};
		}

		// Find and Remove @page rules
		onAtPage(node, item, list) {
			let page, marginalia;
			let selector = "";
			let named, psuedo, nth;
			let needsMerge = false;

			if (node.prelude) {
				named = this.getTypeSelector(node);
				psuedo = this.getPsuedoSelector(node);
				nth = this.getNthSelector(node);
				selector = lib.generate(node.prelude);
			} else {
				selector = "*";
			}

			if (selector in this.pages) {
				// this.pages[selector] = Object.assign(this.pages[selector], page);
				// console.log("after", selector, this.pages[selector]);

				// this.pages[selector].added = false;
				page = this.pages[selector];
				marginalia = this.replaceMarginalia(node);
				needsMerge = true;
			} else {
				page = this.pageModel(selector);
				marginalia = this.replaceMarginalia(node);
				this.pages[selector] = page;
			}

			page.name = named;
			page.psuedo = psuedo;
			page.nth = nth;

			if (needsMerge) {
				page.marginalia = Object.assign(page.marginalia, marginalia);
			} else {
				page.marginalia = marginalia;
			}

			let declarations = this.replaceDeclarations(node);

			if (declarations.size) {
				page.size = declarations.size;
				page.width = declarations.size.width;
				page.height = declarations.size.height;
				page.orientation = declarations.size.orientation;
				page.format = declarations.size.format;
			}

			if (declarations.bleed && declarations.bleed[0] != "auto") {
				switch (declarations.bleed.length) {
					case 4: // top right bottom left
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[3]
						};
						break;
					case 3: // top right bottom right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[2],
							left: declarations.bleed[1]
						};
						break;
					case 2: // top right top right
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[1],
							bottom: declarations.bleed[0],
							left: declarations.bleed[1]
						};
						break;
					default:
						page.bleed = {
							top: declarations.bleed[0],
							right: declarations.bleed[0],
							bottom: declarations.bleed[0],
							left: declarations.bleed[0]
						};
				}
			}

			if (declarations.marks) {
				if (!declarations.bleed || declarations.bleed && declarations.bleed[0] === "auto") {
					// Spec say 6pt, but needs more space for marks
					page.bleed = {
						top: { value: 6, unit: "mm" },
						right: { value: 6, unit: "mm" },
						bottom: { value: 6, unit: "mm" },
						left: { value: 6, unit: "mm" }
					};
				}

				page.marks = declarations.marks;
			}

			if (declarations.margin) {
				page.margin = declarations.margin;
			}
			if (declarations.padding) {
				page.padding = declarations.padding;
			}

			if (declarations.border) {
				page.border = declarations.border;
			}

			if (declarations.marks) {
				page.marks = declarations.marks;
			}

			if (needsMerge) {
				page.block.children.appendList(node.block.children);
			} else {
				page.block = node.block;
			}

			// Remove the rule
			list.remove(item);
		}

		/* Handled in breaks */
		/*
		afterParsed(parsed) {
			for (let b in this.named) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					elements[i].setAttribute("data-page", this.named[b]);
				}
			}
		}
		*/

		afterTreeWalk(ast, sheet) {
			this.addPageClasses(this.pages, ast, sheet);

			if ("*" in this.pages) {
				let width = this.pages["*"].width;
				let height = this.pages["*"].height;
				let format = this.pages["*"].format;
				let orientation = this.pages["*"].orientation;
				let bleed = this.pages["*"].bleed;
				let marks = this.pages["*"].marks;
				let bleedverso = undefined;
				let bleedrecto = undefined;

				if (":left" in this.pages) {
					bleedverso = this.pages[":left"].bleed;
				}

				if (":right" in this.pages) {
					bleedrecto = this.pages[":right"].bleed;
				}

				if ((width && height) &&
					(this.width !== width || this.height !== height)) {
					this.width = width;
					this.height = height;
					this.format = format;
					this.orientation = orientation;

					this.addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks);
					this.addRootPage(ast, this.pages["*"].size, bleed, bleedrecto, bleedverso);

					this.emit("size", { width, height, orientation, format, bleed });
					this.emit("atpages", this.pages);
				}

			}
		}

		getTypeSelector(ast) {
			// Find page name
			let name;

			lib.walk(ast, {
				visit: "TypeSelector",
				enter: (node, item, list) => {
					name = node.name;
				}
			});

			return name;
		}

		getPsuedoSelector(ast) {
			// Find if it has :left & :right & :black & :first
			let name;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name !== "nth") {
						name = node.name;
					}
				}
			});

			return name;
		}

		getNthSelector(ast) {
			// Find if it has :nth
			let nth;
			lib.walk(ast, {
				visit: "PseudoClassSelector",
				enter: (node, item, list) => {
					if (node.name === "nth" && node.children) {
						let raw = node.children.first();
						nth = raw.value;
					}
				}
			});

			return nth;
		}

		replaceMarginalia(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Atrule",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "top") {
						name = "top-center";
					}
					if (name === "right") {
						name = "right-middle";
					}
					if (name === "left") {
						name = "left-middle";
					}
					if (name === "bottom") {
						name = "bottom-center";
					}
					parsed[name] = node.block;
					list.remove(item);
				}
			});

			return parsed;
		}

		replaceDeclarations(ast) {
			let parsed = {};

			lib.walk(ast.block, {
				visit: "Declaration",
				enter: (declaration, dItem, dList) => {
					let prop = lib.property(declaration.property).name;
					// let value = declaration.value;

					if (prop === "marks") {
						parsed.marks = [];
						lib.walk(declaration, {
							visit: "Identifier",
							enter: (ident) => {
								parsed.marks.push(ident.name);
							}
						});
						dList.remove(dItem);
					} else if (prop === "margin") {
						parsed.margin = this.getMargins(declaration);
						dList.remove(dItem);

					} else if (prop.indexOf("margin-") === 0) {
						let m = prop.substring("margin-".length);
						if (!parsed.margin) {
							parsed.margin = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.margin[m] = declaration.value.children.first();
						dList.remove(dItem);

					} else if (prop === "padding") {
						parsed.padding = this.getPaddings(declaration.value);
						dList.remove(dItem);

					} else if (prop.indexOf("padding-") === 0) {
						let p = prop.substring("padding-".length);
						if (!parsed.padding) {
							parsed.padding = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.padding[p] = declaration.value.children.first();
						dList.remove(dItem);
					}

					else if (prop === "border") {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						parsed.border.top = lib.generate(declaration.value);
						parsed.border.right = lib.generate(declaration.value);
						parsed.border.left = lib.generate(declaration.value);
						parsed.border.bottom = lib.generate(declaration.value);

						dList.remove(dItem);

					}

					else if (prop.indexOf("border-") === 0) {
						if (!parsed.border) {
							parsed.border = {
								top: {},
								right: {},
								left: {},
								bottom: {}
							};
						}
						let p = prop.substring("border-".length);

						parsed.border[p] = lib.generate(declaration.value);
						dList.remove(dItem);

					}

					else if (prop === "size") {
						parsed.size = this.getSize(declaration);
						dList.remove(dItem);
					} else if (prop === "bleed") {
						parsed.bleed = [];

						lib.walk(declaration, {
							enter: (subNode) => {
								switch (subNode.type) {
									case "String": // bleed: "auto"
										if (subNode.value.indexOf("auto") > -1) {
											parsed.bleed.push("auto");
										}
										break;
									case "Dimension": // bleed: 1in 2in, bleed: 20px ect.
										parsed.bleed.push({
											value: subNode.value,
											unit: subNode.unit
										});
										break;
									case "Number":
										parsed.bleed.push({
											value: subNode.value,
											unit: "px"
										});
										break;
									// ignore
								}

							}
						});

						dList.remove(dItem);
					}

				}
			});

			return parsed;

		}
		getSize(declaration) {
			let width, height, orientation, format;

			// Get size: Xmm Ymm
			lib.walk(declaration, {
				visit: "Dimension",
				enter: (node, item, list) => {
					let { value, unit } = node;
					if (typeof width === "undefined") {
						width = { value, unit };
					} else if (typeof height === "undefined") {
						height = { value, unit };
					}
				}
			});

			// Get size: "A4"
			lib.walk(declaration, {
				visit: "String",
				enter: (node, item, list) => {
					let name = node.value.replace(/["|']/g, "");
					let s = pageSizes[name];
					if (s) {
						width = s.width;
						height = s.height;
					}
				}
			});

			// Get Format or Landscape or Portrait
			lib.walk(declaration, {
				visit: "Identifier",
				enter: (node, item, list) => {
					let name = node.name;
					if (name === "landscape" || name === "portrait") {
						orientation = node.name;
					} else if (name !== "auto") {
						let s = pageSizes[name];
						if (s) {
							width = s.width;
							height = s.height;
						}
						format = name;
					}
				}
			});

			return {
				width,
				height,
				orientation,
				format
			};
		}

		getMargins(declaration) {
			let margins = [];
			let margin = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // margin: 1in 2in, margin: 20px, etc...
							margins.push(node);
							break;
						case "Number": // margin: 0
							margins.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});

			if (margins.length === 1) {
				for (let m in margin) {
					margin[m] = margins[0];
				}
			} else if (margins.length === 2) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[0];
				margin.left = margins[1];
			} else if (margins.length === 3) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[1];
			} else if (margins.length === 4) {
				margin.top = margins[0];
				margin.right = margins[1];
				margin.bottom = margins[2];
				margin.left = margins[3];
			}

			return margin;
		}

		getPaddings(declaration) {
			let paddings = [];
			let padding = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			lib.walk(declaration, {
				enter: (node) => {
					switch (node.type) {
						case "Dimension": // padding: 1in 2in, padding: 20px, etc...
							paddings.push(node);
							break;
						case "Number": // padding: 0
							paddings.push({value: node.value, unit: "px"});
							break;
						// ignore
					}
				}
			});
			if (paddings.length === 1) {
				for (let p in padding) {
					padding[p] = paddings[0];
				}
			} else if (paddings.length === 2) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[0];
				padding.left = paddings[1];
			} else if (paddings.length === 3) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[1];
			} else if (paddings.length === 4) {

				padding.top = paddings[0];
				padding.right = paddings[1];
				padding.bottom = paddings[2];
				padding.left = paddings[3];
			}
			return padding;
		}

		// get values for the border on the @page to pass them to the element with the .pagedjs_area class
		getBorders(declaration) {
			let border = {
				top: {},
				right: {},
				left: {},
				bottom: {}
			};

			if (declaration.prop == "border") {
				border.top = lib.generate(declaration.value);
				border.right = lib.generate(declaration.value);
				border.bottom = lib.generate(declaration.value);
				border.left = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-top") {
				border.top = lib.generate(declaration.value);
			}
			else if (declaration.prop == "border-right") {
				border.right = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-bottom") {
				border.bottom = lib.generate(declaration.value);

			}
			else if (declaration.prop == "border-left") {
				border.left = lib.generate(declaration.value);
			}

			return border;
		}


		addPageClasses(pages, ast, sheet) {
			// First add * page
			if ("*" in pages) {
				let p = this.createPage(pages["*"], ast.children, sheet);
				sheet.insertRule(p);
			}
			// Add :left & :right
			if (":left" in pages) {
				let left = this.createPage(pages[":left"], ast.children, sheet);
				sheet.insertRule(left);
			}
			if (":right" in pages) {
				let right = this.createPage(pages[":right"], ast.children, sheet);
				sheet.insertRule(right);
			}
			// Add :first & :blank
			if (":first" in pages) {
				let first = this.createPage(pages[":first"], ast.children, sheet);
				sheet.insertRule(first);
			}
			if (":blank" in pages) {
				let blank = this.createPage(pages[":blank"], ast.children, sheet);
				sheet.insertRule(blank);
			}
			// Add nth pages
			for (let pg in pages) {
				if (pages[pg].nth) {
					let nth = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(nth);
				}
			}

			// Add named pages
			for (let pg in pages) {
				if (pages[pg].name) {
					let named = this.createPage(pages[pg], ast.children, sheet);
					sheet.insertRule(named);
				}
			}

		}

		createPage(page, ruleList, sheet) {

			let selectors = this.selectorsForPage(page);
			let children = page.block.children.copy();
			let block = {
				type: "Block",
				loc: 0,
				children: children
			};


			let rule = this.createRule(selectors, block);

			this.addMarginVars(page.margin, children, children.first());
			this.addPaddingVars(page.padding, children, children.first());
			this.addBorderVars(page.border, children, children.first());


			if (page.width) {
				this.addDimensions(page.width, page.height, page.orientation, children, children.first());
			}

			if (page.marginalia) {
				this.addMarginaliaStyles(page, ruleList, rule, sheet);
				this.addMarginaliaContent(page, ruleList, rule, sheet);
			}
			return rule;
		}

		addMarginVars(margin, list, item) {
			// variables for margins
			for (let m in margin) {
				if (typeof margin[m].value !== "undefined") {
					let value = margin[m].value + (margin[m].unit || "");
					let mVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-margin-" + m,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(mVar, item);

				}
			}
		}

		addPaddingVars(padding, list, item) {
			// variables for padding
			for (let p in padding) {

				if (typeof padding[p].value !== "undefined") {
					let value = padding[p].value + (padding[p].unit || "");
					let pVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-padding-" + p,
						value: {
							type: "Raw",
							value: value
						}
					});

					list.append(pVar, item);
				}

			}
		}

		addBorderVars(border, list, item) {
			// variables for borders
			for (let b in border) {
				if (typeof border[b] !== "undefined") {
					let value = border[b];
					let bVar = list.createItem({
						type: "Declaration",
						property: "--pagedjs-border-" + b,
						value: {
							type: "Raw",
							value: value
						}
					});
					list.append(bVar, item);
				}

			}
		}

		addDimensions(width, height, orientation, list, item) {
			let widthString, heightString;

			widthString = CSSValueToString(width);
			heightString = CSSValueToString(height);

			if (orientation && orientation !== "portrait") {
				// reverse for orientation
				[widthString, heightString] = [heightString, widthString];
			}

			// width variable
			let wVar = this.createVariable("--pagedjs-pagebox-width", widthString);
			list.appendData(wVar);

			// height variable
			let hVar = this.createVariable("--pagedjs-pagebox-height", heightString);
			list.appendData(hVar);

			// let w = this.createDimension("width", width);
			// let h = this.createDimension("height", height);
			// list.appendData(w);
			// list.appendData(h);
		}

		addMarginaliaStyles(page, list, item, sheet) {
			for (let loc in page.marginalia) {
				let block = lib.clone(page.marginalia[loc]);
				let hasContent = false;

				if (block.children.isEmpty()) {
					continue;
				}

				lib.walk(block, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property === "content") {
							if (node.value.children && node.value.children.first().name === "none") {
								hasContent = false;
							} else {
								hasContent = true;
							}
							list.remove(item);
						}
						if (node.property === "vertical-align") {
							lib.walk(node, {
								visit: "Identifier",
								enter: (identNode, identItem, identlist) => {
									let name = identNode.name;
									if (name === "top") {
										identNode.name = "flex-start";
									} else if (name === "middle") {
										identNode.name = "center";
									} else if (name === "bottom") {
										identNode.name = "flex-end";
									}
								}
							});
							node.property = "align-items";
						}

						if (node.property === "width" &&
							(loc === "top-left" ||
								loc === "top-center" ||
								loc === "top-right" ||
								loc === "bottom-left" ||
								loc === "bottom-center" ||
								loc === "bottom-right")) {
							let c = lib.clone(node);
							c.property = "max-width";
							list.appendData(c);
						}

						if (node.property === "height" &&
							(loc === "left-top" ||
								loc === "left-middle" ||
								loc === "left-bottom" ||
								loc === "right-top" ||
								loc === "right-middle" ||
								loc === "right-bottom")) {
							let c = lib.clone(node);
							c.property = "max-height";
							list.appendData(c);
						}
					}
				});

				let marginSelectors = this.selectorsForPageMargin(page, loc);
				let marginRule = this.createRule(marginSelectors, block);

				list.appendData(marginRule);

				let sel = lib.generate({
					type: "Selector",
					children: marginSelectors
				});

				this.marginalia[sel] = {
					page: page,
					selector: sel,
					block: page.marginalia[loc],
					hasContent: hasContent
				};

			}
		}

		addMarginaliaContent(page, list, item, sheet) {
			let displayNone;
			// Just content
			for (let loc in page.marginalia) {
				let content = lib.clone(page.marginalia[loc]);
				lib.walk(content, {
					visit: "Declaration",
					enter: (node, item, list) => {
						if (node.property !== "content") {
							list.remove(item);
						}

						if (node.value.children && node.value.children.first().name === "none") {
							displayNone = true;
						}
					}
				});

				if (content.children.isEmpty()) {
					continue;
				}

				let displaySelectors = this.selectorsForPageMargin(page, loc);
				let displayDeclaration;

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				displaySelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				displaySelectors.insertData({
					type: "TypeSelector",
					name: "*"
				});

				if (displayNone) {
					displayDeclaration = this.createDeclaration("display", "none");
				} else {
					displayDeclaration = this.createDeclaration("display", "block");
				}

				let displayRule = this.createRule(displaySelectors, [displayDeclaration]);
				sheet.insertRule(displayRule);

				// insert content rule
				let contentSelectors = this.selectorsForPageMargin(page, loc);

				contentSelectors.insertData({
					type: "Combinator",
					name: ">"
				});

				contentSelectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_margin-content"
				});

				contentSelectors.insertData({
					type: "PseudoElementSelector",
					name: "after",
					children: null
				});

				let contentRule = this.createRule(contentSelectors, content);
				sheet.insertRule(contentRule);
			}
		}

		addRootVars(ast, width, height, orientation, bleed, bleedrecto, bleedverso, marks) {
			let rules = [];
			let selectors = new lib.List();
			selectors.insertData({
				type: "PseudoClassSelector",
				name: "root",
				children: null
			});

			let widthString, heightString;
			let widthStringRight, heightStringRight;
			let widthStringLeft, heightStringLeft;

			if (!bleed) {
				widthString = CSSValueToString(width);
				heightString = CSSValueToString(height);
				widthStringRight = CSSValueToString(width);
				heightStringRight = CSSValueToString(height);
				widthStringLeft = CSSValueToString(width);
				heightStringLeft = CSSValueToString(height);
			} else {
				widthString = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightString = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleed.left)} + ${CSSValueToString(bleed.right)} )`;
				heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleed.top)} + ${CSSValueToString(bleed.bottom)} )`;

				let bleedTop = this.createVariable("--pagedjs-bleed-top", CSSValueToString(bleed.top));
				let bleedRight = this.createVariable("--pagedjs-bleed-right", CSSValueToString(bleed.right));
				let bleedBottom = this.createVariable("--pagedjs-bleed-bottom", CSSValueToString(bleed.bottom));
				let bleedLeft = this.createVariable("--pagedjs-bleed-left", CSSValueToString(bleed.left));

				let bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleed.top));
				let bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleed.right));
				let bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleed.left));

				let bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleed.top));
				let bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleed.right));
				let bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleed.bottom));
				let bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleed.left));

				if (bleedrecto) {
					bleedTopRecto = this.createVariable("--pagedjs-bleed-right-top", CSSValueToString(bleedrecto.top));
					bleedRightRecto = this.createVariable("--pagedjs-bleed-right-right", CSSValueToString(bleedrecto.right));
					bleedBottomRecto = this.createVariable("--pagedjs-bleed-right-bottom", CSSValueToString(bleedrecto.bottom));
					bleedLeftRecto = this.createVariable("--pagedjs-bleed-right-left", CSSValueToString(bleedrecto.left));

					widthStringRight = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedrecto.left)} + ${CSSValueToString(bleedrecto.right)} )`;
					heightStringRight = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedrecto.top)} + ${CSSValueToString(bleedrecto.bottom)} )`;
				}
				if (bleedverso) {
					bleedTopVerso = this.createVariable("--pagedjs-bleed-left-top", CSSValueToString(bleedverso.top));
					bleedRightVerso = this.createVariable("--pagedjs-bleed-left-right", CSSValueToString(bleedverso.right));
					bleedBottomVerso = this.createVariable("--pagedjs-bleed-left-bottom", CSSValueToString(bleedverso.bottom));
					bleedLeftVerso = this.createVariable("--pagedjs-bleed-left-left", CSSValueToString(bleedverso.left));

					widthStringLeft = `calc( ${CSSValueToString(width)} + ${CSSValueToString(bleedverso.left)} + ${CSSValueToString(bleedverso.right)} )`;
					heightStringLeft = `calc( ${CSSValueToString(height)} + ${CSSValueToString(bleedverso.top)} + ${CSSValueToString(bleedverso.bottom)} )`;
				}

				let pageWidthVar = this.createVariable("--pagedjs-width", CSSValueToString(width));
				let pageHeightVar = this.createVariable("--pagedjs-height", CSSValueToString(height));

				rules.push(
					bleedTop,
					bleedRight,
					bleedBottom,
					bleedLeft,
					bleedTopRecto,
					bleedRightRecto,
					bleedBottomRecto,
					bleedLeftRecto,
					bleedTopVerso,
					bleedRightVerso,
					bleedBottomVerso,
					bleedLeftVerso,
					pageWidthVar,
					pageHeightVar
				);
			}

			if (marks) {
				marks.forEach((mark) => {
					let markDisplay = this.createVariable("--pagedjs-mark-" + mark + "-display", "block");
					rules.push(markDisplay);
				});
			}

			// orientation variable
			if (orientation) {
				let oVar = this.createVariable("--pagedjs-orientation", orientation);
				rules.push(oVar);

				if (orientation !== "portrait") {
					// reverse for orientation
					[widthString, heightString] = [heightString, widthString];
					[widthStringRight, heightStringRight] = [heightStringRight, widthStringRight];
					[widthStringLeft, heightStringLeft] = [heightStringLeft, widthStringLeft];
				}
			}

			let wVar = this.createVariable("--pagedjs-width", widthString);
			let hVar = this.createVariable("--pagedjs-height", heightString);

			let wVarR = this.createVariable("--pagedjs-width-right", widthStringRight);
			let hVarR = this.createVariable("--pagedjs-height-right", heightStringRight);

			let wVarL = this.createVariable("--pagedjs-width-left", widthStringLeft);
			let hVarL = this.createVariable("--pagedjs-height-left", heightStringLeft);

			rules.push(wVar, hVar, wVarR, hVarR, wVarL, hVarL);

			let rule = this.createRule(selectors, rules);

			ast.children.appendData(rule);
		}

		/*
		@page {
			size: var(--pagedjs-width) var(--pagedjs-height);
			margin: 0;
			padding: 0;
		}
		*/
		addRootPage(ast, size, bleed, bleedrecto, bleedverso) {
			let { width, height, orientation, format } = size;
			let children = new lib.List();
			let childrenLeft = new lib.List();
			let childrenRight = new lib.List();
			let dimensions = new lib.List();
			let dimensionsLeft = new lib.List();
			let dimensionsRight = new lib.List();

			if (bleed) {
				let widthCalculations = new lib.List();
				let heightCalculations = new lib.List();

				// width
				widthCalculations.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.left.unit,
					value: bleed.left.value
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculations.appendData({
					type: "Dimension",
					unit: bleed.right.unit,
					value: bleed.right.value
				});

				// height
				heightCalculations.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.top.unit,
					value: bleed.top.value
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculations.appendData({
					type: "Dimension",
					unit: bleed.bottom.unit,
					value: bleed.bottom.value
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculations
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculations
				});

			} else if (format) {
				dimensions.appendData({
					type: "Identifier",
					name: format
				});

				if (orientation) {
					dimensions.appendData({
						type: "WhiteSpace",
						value: " "
					});

					dimensions.appendData({
						type: "Identifier",
						name: orientation
					});
				}
			} else {
				dimensions.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				dimensions.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensions.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});
			}

			children.appendData({
				type: "Declaration",
				property: "size",
				loc: null,
				value: {
					type: "Value",
					children: dimensions
				}
			});

			children.appendData({
				type: "Declaration",
				property: "margin",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			children.appendData({
				type: "Declaration",
				property: "padding",
				loc: null,
				value: {
					type: "Value",
					children: [{
						type: "Dimension",
						unit: "px",
						value: 0
					}]
				}
			});

			let rule = ast.children.createItem({
				type: "Atrule",
				prelude: null,
				name: "page",
				block: {
					type: "Block",
					loc: null,
					children: children
				}
			});

			ast.children.append(rule);

			if (bleedverso) {
				let widthCalculationsLeft = new lib.List();
				let heightCalculationsLeft = new lib.List();

				// width
				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.left.unit,
					value: bleedverso.left.value
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.right.unit,
					value: bleedverso.right.value
				});

				// height
				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.top.unit,
					value: bleedverso.top.value
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsLeft.appendData({
					type: "Dimension",
					unit: bleedverso.bottom.unit,
					value: bleedverso.bottom.value
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsLeft
				});

				dimensionsLeft.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsLeft.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsLeft
				});

				childrenLeft.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsLeft
					}
				});

				let ruleLeft = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :left",
					block: {
						type: "Block",
						loc: null,
						children: childrenLeft
					}
				});

				ast.children.append(ruleLeft);

			}

			if (bleedrecto) {
				let widthCalculationsRight = new lib.List();
				let heightCalculationsRight = new lib.List();

				// width
				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: width.unit,
					value: width.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.left.unit,
					value: bleedrecto.left.value
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				widthCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				widthCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.right.unit,
					value: bleedrecto.right.value
				});

				// height
				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: height.unit,
					value: height.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.top.unit,
					value: bleedrecto.top.value
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Operator",
					value: "+"
				});

				heightCalculationsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				heightCalculationsRight.appendData({
					type: "Dimension",
					unit: bleedrecto.bottom.unit,
					value: bleedrecto.bottom.value
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: widthCalculationsRight
				});

				dimensionsRight.appendData({
					type: "WhiteSpace",
					value: " "
				});

				dimensionsRight.appendData({
					type: "Function",
					name: "calc",
					children: heightCalculationsRight
				});

				childrenRight.appendData({
					type: "Declaration",
					property: "size",
					loc: null,
					value: {
						type: "Value",
						children: dimensionsRight
					}
				});

				let ruleRight = ast.children.createItem({
					type: "Atrule",
					prelude: null,
					name: "page :right",
					block: {
						type: "Block",
						loc: null,
						children: childrenRight
					}
				});

				ast.children.append(ruleRight);

			}
		}

		getNth(nth) {
			let n = nth.indexOf("n");
			let plus = nth.indexOf("+");
			let splitN = nth.split("n");
			let splitP = nth.split("+");
			let a = null;
			let b = null;
			if (n > -1) {
				a = splitN[0];
				if (plus > -1) {
					b = splitP[1];
				}
			} else {
				b = nth;
			}

			return {
				type: "Nth",
				loc: null,
				selector: null,
				nth: {
					type: "AnPlusB",
					loc: null,
					a: a,
					b: b
				}
			};
		}

		addPageAttributes(page, start, pages) {
			let named = start.dataset.page;

			if (named) {
				page.name = named;
				page.element.classList.add("pagedjs_named_page");
				page.element.classList.add("pagedjs_" + named + "_page");

				if (!start.dataset.splitFrom) {
					page.element.classList.add("pagedjs_" + named + "_first_page");
				}
			}
		}

		getStartElement(content, breakToken) {
			let node = breakToken && breakToken.node;

			if (!content && !breakToken) {
				return;
			}

			// No break
			if (!node) {
				return content.children[0];
			}

			// Top level element
			if (node.nodeType === 1 && node.parentNode.nodeType === 11) {
				return node;
			}

			// Named page
			if (node.nodeType === 1 && node.dataset.page) {
				return node;
			}

			// Get top level Named parent
			let fragment = rebuildAncestors(node);
			let pages = fragment.querySelectorAll("[data-page]");

			if (pages.length) {
				return pages[pages.length - 1];
			} else {
				return fragment.children[0];
			}
		}

		beforePageLayout(page, contents, breakToken, chunker) {
			let start = this.getStartElement(contents, breakToken);
			if (start) {
				this.addPageAttributes(page, start, chunker.pages);
			}
			// page.element.querySelector('.paged_area').style.color = red;
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			for (let m in this.marginalia) {
				let margin = this.marginalia[m];
				let sels = m.split(" ");

				let content;
				if (page.element.matches(sels[0]) && margin.hasContent) {
					content = page.element.querySelector(sels[1]);
					content.classList.add("hasContent");
				}
			}

			// check center
			["top", "bottom"].forEach((loc) => {
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let center = page.element.querySelector(".pagedjs_margin-" + loc + "-center");
				let left = page.element.querySelector(".pagedjs_margin-" + loc + "-left");
				let right = page.element.querySelector(".pagedjs_margin-" + loc + "-right");

				let centerContent = center.classList.contains("hasContent");
				let leftContent = left.classList.contains("hasContent");
				let rightContent = right.classList.contains("hasContent");
				let centerWidth, leftWidth, rightWidth;

				if (leftContent) {
					leftWidth = window.getComputedStyle(left)["max-width"];
				}

				if (rightContent) {
					rightWidth = window.getComputedStyle(right)["max-width"];
				}


				if (centerContent) {
					centerWidth = window.getComputedStyle(center)["max-width"];

					if (centerWidth === "none" || centerWidth === "auto") {
						if (!leftContent && !rightContent) {
							marginGroup.style["grid-template-columns"] = "0 1fr 0";
						} else if (leftContent) {
							if (!rightContent) {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto auto 1fr";
									left.style["white-space"] = "nowrap";
									center.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let centerOuterWidth = center.offsetWidth;
									let outerwidths = leftOuterWidth + centerOuterWidth;
									let newcenterWidth = centerOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
									left.style["white-space"] = "normal";
									center.style["white-space"] = "normal";
								}
							} else {
								if (leftWidth !== "none" && leftWidth !== "auto") {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + leftWidth;
									}
								} else {
									if (rightWidth !== "none" && rightWidth !== "auto") {
										marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
									} else {
										marginGroup.style["grid-template-columns"] = "auto auto 1fr";
										left.style["white-space"] = "nowrap";
										center.style["white-space"] = "nowrap";
										right.style["white-space"] = "nowrap";
										let leftOuterWidth = left.offsetWidth;
										let centerOuterWidth = center.offsetWidth;
										let rightOuterWidth = right.offsetWidth;
										let outerwidths = leftOuterWidth + centerOuterWidth + rightOuterWidth;
										let newcenterWidth = centerOuterWidth * 100 / outerwidths;
										if (newcenterWidth > 40) {
											marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
										} else {
											marginGroup.style["grid-template-columns"] = "repeat(3, 1fr)";
										}
										left.style["white-space"] = "normal";
										center.style["white-space"] = "normal";
										right.style["white-space"] = "normal";
									}
								}
							}
						} else {
							if (rightWidth !== "none" && rightWidth !== "auto") {
								marginGroup.style["grid-template-columns"] = rightWidth + " 1fr " + rightWidth;
							} else {
								marginGroup.style["grid-template-columns"] = "auto auto 1fr";
								right.style["white-space"] = "nowrap";
								center.style["white-space"] = "nowrap";
								let rightOuterWidth = right.offsetWidth;
								let centerOuterWidth = center.offsetWidth;
								let outerwidths = rightOuterWidth + centerOuterWidth;
								let newcenterWidth = centerOuterWidth * 100 / outerwidths;
								marginGroup.style["grid-template-columns"] = "minmax(16.66%, 1fr) minmax(33%, " + newcenterWidth + "%) minmax(16.66%, 1fr)";
								right.style["white-space"] = "normal";
								center.style["white-space"] = "normal";
							}
						}
					} else if (centerWidth !== "none" && centerWidth !== "auto") {
						if (leftContent && leftWidth !== "none" && leftWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = leftWidth + " " + centerWidth + " 1fr";
						} else if (rightContent && rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "1fr " + centerWidth + " 1fr";
						}

					}

				} else {
					if (leftContent) {
						if (!rightContent) {
							marginGroup.style["grid-template-columns"] = "1fr 0 0";
						} else {
							if (leftWidth !== "none" && leftWidth !== "auto") {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = leftWidth + " 1fr " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = leftWidth + " 0 1fr";
								}
							} else {
								if (rightWidth !== "none" && rightWidth !== "auto") {
									marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
								} else {
									marginGroup.style["grid-template-columns"] = "auto 1fr auto";
									left.style["white-space"] = "nowrap";
									right.style["white-space"] = "nowrap";
									let leftOuterWidth = left.offsetWidth;
									let rightOuterWidth = right.offsetWidth;
									let outerwidths = leftOuterWidth + rightOuterWidth;
									let newLeftWidth = leftOuterWidth * 100 / outerwidths;
									marginGroup.style["grid-template-columns"] = "minmax(16.66%, " + newLeftWidth + "%) 0 1fr";
									left.style["white-space"] = "normal";
									right.style["white-space"] = "normal";
								}
							}
						}
					} else {
						if (rightWidth !== "none" && rightWidth !== "auto") {
							marginGroup.style["grid-template-columns"] = "1fr 0 " + rightWidth;
						} else {
							marginGroup.style["grid-template-columns"] = "0 0 1fr";
						}
					}
				}
			});

			// check middle
			["left", "right"].forEach((loc) => {
				let middle = page.element.querySelector(".pagedjs_margin-" + loc + "-middle.hasContent");
				let marginGroup = page.element.querySelector(".pagedjs_margin-" + loc);
				let top = page.element.querySelector(".pagedjs_margin-" + loc + "-top");
				let bottom = page.element.querySelector(".pagedjs_margin-" + loc + "-bottom");
				let topContent = top.classList.contains("hasContent");
				let bottomContent = bottom.classList.contains("hasContent");
				let middleHeight, topHeight, bottomHeight;

				if (topContent) {
					topHeight = window.getComputedStyle(top)["max-height"];
				}

				if (bottomContent) {
					bottomHeight = window.getComputedStyle(bottom)["max-height"];
				}

				if (middle) {
					middleHeight = window.getComputedStyle(middle)["max-height"];

					if (middleHeight === "none" || middleHeight === "auto") {
						if (!topContent && !bottomContent) {
							marginGroup.style["grid-template-rows"] = "0 1fr 0";
						} else if (topContent) {
							if (!bottomContent) {
								if (topHeight !== "none" && topHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
								}
							} else {
								if (topHeight !== "none" && topHeight !== "auto") {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + " - " + bottomHeight + ") " + bottomHeight;
									} else {
										marginGroup.style["grid-template-rows"] = topHeight + " calc(100% - " + topHeight + "*2) " + topHeight;
									}
								} else {
									if (bottomHeight !== "none" && bottomHeight !== "auto") {
										marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
									}
								}
							}
						} else {
							if (bottomHeight !== "none" && bottomHeight !== "auto") {
								marginGroup.style["grid-template-rows"] = bottomHeight + " calc(100% - " + bottomHeight + "*2) " + bottomHeight;
							}
						}
					} else {
						if (topContent && topHeight !== "none" && topHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = topHeight + " " + middleHeight + " calc(100% - (" + topHeight + " + " + middleHeight + "))";
						} else if (bottomContent && bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr " + middleHeight + " " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "calc((100% - " + middleHeight + ")/2) " + middleHeight + " calc((100% - " + middleHeight + ")/2)";
						}

					}

				} else {
					if (topContent) {
						if (!bottomContent) {
							marginGroup.style["grid-template-rows"] = "1fr 0 0";
						} else {
							if (topHeight !== "none" && topHeight !== "auto") {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = topHeight + " 1fr " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = topHeight + " 0 1fr";
								}
							} else {
								if (bottomHeight !== "none" && bottomHeight !== "auto") {
									marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
								} else {
									marginGroup.style["grid-template-rows"] = "1fr 0 1fr";
								}
							}
						}
					} else {
						if (bottomHeight !== "none" && bottomHeight !== "auto") {
							marginGroup.style["grid-template-rows"] = "1fr 0 " + bottomHeight;
						} else {
							marginGroup.style["grid-template-rows"] = "0 0 1fr";
						}
					}
				}



			});

		}

		// CSS Tree Helpers

		selectorsForPage(page) {
			let nthlist;
			let nth;

			let selectors = new lib.List();

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_page"
			});

			// Named page
			if (page.name) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_named_page"
				});

				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_page"
				});
			}

			// PsuedoSelector
			if (page.psuedo && !(page.name && page.psuedo === "first")) {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.psuedo + "_page"
				});
			}

			if (page.name && page.psuedo === "first") {
				selectors.insertData({
					type: "ClassSelector",
					name: "pagedjs_" + page.name + "_" + page.psuedo + "_page"
				});
			}

			// Nth
			if (page.nth) {
				nthlist = new lib.List();
				nth = this.getNth(page.nth);

				nthlist.insertData(nth);

				selectors.insertData({
					type: "PseudoClassSelector",
					name: "nth-of-type",
					children: nthlist
				});
			}

			return selectors;
		}

		selectorsForPageMargin(page, margin) {
			let selectors = this.selectorsForPage(page);

			selectors.insertData({
				type: "Combinator",
				name: " "
			});

			selectors.insertData({
				type: "ClassSelector",
				name: "pagedjs_margin-" + margin
			});

			return selectors;
		}

		createDeclaration(property, value, important) {
			let children = new lib.List();

			children.insertData({
				type: "Identifier",
				loc: null,
				name: value
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createVariable(property, value) {
			return {
				type: "Declaration",
				loc: null,
				property: property,
				value: {
					type: "Raw",
					value: value
				}
			};
		}

		createCalculatedDimension(property, items, important, operator = "+") {
			let children = new lib.List();
			let calculations = new lib.List();

			items.forEach((item, index) => {
				calculations.appendData({
					type: "Dimension",
					unit: item.unit,
					value: item.value
				});

				calculations.appendData({
					type: "WhiteSpace",
					value: " "
				});

				if (index + 1 < items.length) {
					calculations.appendData({
						type: "Operator",
						value: operator
					});

					calculations.appendData({
						type: "WhiteSpace",
						value: " "
					});
				}
			});

			children.insertData({
				type: "Function",
				loc: null,
				name: "calc",
				children: calculations
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createDimension(property, cssValue, important) {
			let children = new lib.List();

			children.insertData({
				type: "Dimension",
				loc: null,
				value: cssValue.value,
				unit: cssValue.unit
			});

			return {
				type: "Declaration",
				loc: null,
				important: important,
				property: property,
				value: {
					type: "Value",
					loc: null,
					children: children
				}
			};
		}

		createBlock(declarations) {
			let block = new lib.List();

			declarations.forEach((declaration) => {
				block.insertData(declaration);
			});

			return {
				type: "Block",
				loc: null,
				children: block
			};
		}

		createRule(selectors, block) {
			let selectorList = new lib.List();
			selectorList.insertData({
				type: "Selector",
				children: selectors
			});

			if (Array.isArray(block)) {
				block = this.createBlock(block);
			}

			return {
				type: "Rule",
				prelude: {
					type: "SelectorList",
					children: selectorList
				},
				block: block
			};
		}

	}

	class Breaks extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.breaks = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "page") {
				let children = declaration.value.children.first();
				let value = children.name;
				let selector = lib.generate(rule.ruleNode.prelude);
				let name = value;

				let breaker = {
					property: property,
					value: value,
					selector: selector,
					name: name
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				dList.remove(dItem);
			}

			if (property === "break-before" ||
					property === "break-after" ||
					property === "page-break-before" ||
					property === "page-break-after"
			) {
				let child = declaration.value.children.first();
				let value = child.name;
				let selector = lib.generate(rule.ruleNode.prelude);

				if (property === "page-break-before") {
					property = "break-before";
				} else if (property === "page-break-after") {
					property = "break-after";
				}

				let breaker = {
					property: property,
					value: value,
					selector: selector
				};

				selector.split(",").forEach((s) => {
					if (!this.breaks[s]) {
						this.breaks[s] = [breaker];
					} else {
						this.breaks[s].push(breaker);
					}
				});

				// Remove from CSS -- handle right / left in module
				dList.remove(dItem);
			}
		}

		afterParsed(parsed) {
			this.processBreaks(parsed, this.breaks);
		}

		processBreaks(parsed, breaks) {
			for (let b in breaks) {
				// Find elements
				let elements = parsed.querySelectorAll(b);
				// Add break data
				for (var i = 0; i < elements.length; i++) {
					for (let prop of breaks[b]) {

						if (prop.property === "break-after") {
							let nodeAfter = displayedElementAfter(elements[i], parsed);

							elements[i].setAttribute("data-break-after", prop.value);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-previous-break-after", prop.value);
							}
						} else if (prop.property === "break-before") {
							let nodeBefore = displayedElementBefore(elements[i], parsed);

							// Breaks are only allowed between siblings, not between a box and its container.
							// If we cannot find a node before we should not break!
							// https://drafts.csswg.org/css-break-3/#break-propagation
							if (nodeBefore) {
								if (prop.value === "page" && needsPageBreak(elements[i], nodeBefore)) {
									// we ignore this explicit page break because an implicit page break is already needed
									continue;
								}
								elements[i].setAttribute("data-break-before", prop.value);
								nodeBefore.setAttribute("data-next-break-before", prop.value);
							}
						} else if (prop.property === "page") {
							elements[i].setAttribute("data-page", prop.value);

							let nodeAfter = displayedElementAfter(elements[i], parsed);

							if (nodeAfter) {
								nodeAfter.setAttribute("data-after-page", prop.value);
							}
						} else {
							elements[i].setAttribute("data-" + prop.property, prop.value);
						}
					}
				}
			}
		}

		mergeBreaks(pageBreaks, newBreaks) {
			for (let b in newBreaks) {
				if (b in pageBreaks) {
					pageBreaks[b] = pageBreaks[b].concat(newBreaks[b]);
				} else {
					pageBreaks[b] = newBreaks[b];
				}
			}
			return pageBreaks;
		}

		addBreakAttributes(pageElement, page) {
			let before = pageElement.querySelector("[data-break-before]");
			let after = pageElement.querySelector("[data-break-after]");
			let previousBreakAfter = pageElement.querySelector("[data-previous-break-after]");

			if (before) {
				if (before.dataset.splitFrom) {
					page.splitFrom = before.dataset.splitFrom;
					pageElement.setAttribute("data-split-from", before.dataset.splitFrom);
				} else if (before.dataset.breakBefore && before.dataset.breakBefore !== "avoid") {
					page.breakBefore = before.dataset.breakBefore;
					pageElement.setAttribute("data-break-before", before.dataset.breakBefore);
				}
			}

			if (after && after.dataset) {
				if (after.dataset.splitTo) {
					page.splitTo = after.dataset.splitTo;
					pageElement.setAttribute("data-split-to", after.dataset.splitTo);
				} else if (after.dataset.breakAfter && after.dataset.breakAfter !== "avoid") {
					page.breakAfter = after.dataset.breakAfter;
					pageElement.setAttribute("data-break-after", after.dataset.breakAfter);
				}
			}

			if (previousBreakAfter && previousBreakAfter.dataset) {
				if (previousBreakAfter.dataset.previousBreakAfter && previousBreakAfter.dataset.previousBreakAfter !== "avoid") {
					page.previousBreakAfter = previousBreakAfter.dataset.previousBreakAfter;
				}
			}
		}

		afterPageLayout(pageElement, page) {
			this.addBreakAttributes(pageElement, page);
		}
	}

	class PrintMedia extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		onAtMedia(node, item, list) {
			let media = this.getMediaName(node);
			let rules;

			if (media === "print") {
				rules = node.block.children;

				// Remove rules from the @media block
				node.block.children = new lib.List();

				// Append rules to the end of main rules list
				list.appendList(rules);
			}

		}

		getMediaName(node) {
			let media = "";

			if (typeof node.prelude === "undefined" ||
					node.prelude.type !== "AtrulePrelude" ) {
				return;
			}

			lib.walk(node.prelude, {
				visit: "Identifier",
				enter: (identNode, iItem, iList) => {
					media = identNode.name;
				}
			});
			return media;
		}


	}

	class Splits extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			let splits = Array.from(pageElement.querySelectorAll("[data-split-from]"));
			let pages = pageElement.parentNode;
			let index = Array.prototype.indexOf.call(pages.children, pageElement);
			let prevPage;

			if (index === 0) {
				return;
			}

			prevPage = pages.children[index - 1];

			let from; // Capture the last from element
			splits.forEach((split) => {
				let ref = split.dataset.ref;
				from = prevPage.querySelector("[data-ref='"+ ref +"']:not([data-split-to])");

				if (from) {
					from.dataset.splitTo = ref;

					if (!from.dataset.splitFrom) {
						from.dataset.splitOriginal = true;
					}
				}
			});

			// Fix alignment on the deepest split element
			if (from) {
				this.handleAlignment(from);
			}
		}

		handleAlignment(node) {
			let styles = window.getComputedStyle(node);
			let align = styles["text-align"];
			let alignLast = styles["text-align-last"];
			node.dataset.lastSplitElement = "true";
			if (align === "justify" && alignLast === "auto") {
				node.dataset.alignLastSplitElement = "justify";
			} else {
				node.dataset.alignLastSplitElement = alignLast;
			}
		}

	}

	class Counters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.counters = {};
			this.resetCountersMap = new Map();
		}

		onDeclaration(declaration, dItem, dList, rule) {
			let property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			} else if (property === "counter-reset") {
				let reset = this.handleReset(declaration, rule);
				if (reset) {
					dList.remove(dItem);
				}
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "counter") ;
		}

		afterParsed(parsed) {
			this.processCounters(parsed, this.counters);
			this.scopeCounters(this.counters);
		}

		addCounter(name) {
			if (name in this.counters) {
				return this.counters[name];
			}

			this.counters[name] = {
				name: name,
				increments: {},
				resets: {}
			};

			return this.counters[name];
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name === "page" || name.indexOf("target-counter-") === 0) {
				return;
			}

			let selector = lib.generate(rule.ruleNode.prelude);

			let counter;
			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.increments[selector] = {
				selector: selector,
				number
			};
		}

		handleReset(declaration, rule) {
			let identifier = declaration.value.children.first();
			let number = declaration.value.children.getSize() > 1
								&& declaration.value.children.last().value;
			let name = identifier && identifier.name;
			let selector = lib.generate(rule.ruleNode.prelude);
			let counter;

			if (!(name in this.counters)) {
				counter = this.addCounter(name);
			} else {
				counter = this.counters[name];
			}

			return counter.resets[selector] = {
				selector: selector,
				number: number || 0
			};
		}

		processCounters(parsed, counters) {
			let counter;
			for (let c in counters) {
				counter = this.counters[c];
				this.processCounterIncrements(parsed, counter);
				this.processCounterResets(parsed, counter);
				if (c !== "page") {
					this.addCounterValues(parsed, counter);
				}
			}
		}

		scopeCounters(counters) {
			let countersArray = [];
			for (let c in counters) {
				if(c !== "page") {
					countersArray.push(`${counters[c].name} 0`);
				}
			}
			// Add to pages to allow cross page scope
			this.insertRule(`.pagedjs_pages { counter-reset: ${countersArray.join(" ")} page 0 pages var(--pagedjs-page-count)}`);
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}

		processCounterIncrements(parsed, counter) {
			let increment;
			for (let inc in counter.increments) {
				increment = counter.increments[inc];
				// Find elements for increments
				let incrementElements = parsed.querySelectorAll(increment.selector);
				// Add counter data
				for (let i = 0; i < incrementElements.length; i++) {
					incrementElements[i].setAttribute("data-counter-"+ counter.name +"-increment", increment.number);
					incrementElements[i].setAttribute("data-counter-increment", counter.name);
				}
			}
		}

		processCounterResets(parsed, counter) {
			let reset;
			for (let r in counter.resets) {
				reset = counter.resets[r];
				// Find elements for resets
				let resetElements = parsed.querySelectorAll(reset.selector);
				// Add counter data
				for (var i = 0; i < resetElements.length; i++) {
					resetElements[i].setAttribute("data-counter-"+ counter.name +"-reset", reset.number);
					resetElements[i].setAttribute("data-counter-reset", counter.name);
				}
			}
		}

		addCounterValues(parsed, counter) {
			const counterName = counter.name;
			const elements = parsed.querySelectorAll("[data-counter-"+ counterName +"-reset], [data-counter-"+ counterName +"-increment]");

			let count = 0;
			let element;
			let increment, reset;
			let resetValue, incrementValue, resetDelta;
			let incrementArray;

			for (let i = 0; i < elements.length; i++) {
				element = elements[i];
				resetDelta = 0;
				incrementArray = [];

				if (element.hasAttribute("data-counter-"+ counterName +"-reset")) {
					reset = element.getAttribute("data-counter-"+ counterName +"-reset");
					resetValue = parseInt(reset);

					// Use negative increment value inplace of reset
					resetDelta = resetValue - count;
					incrementArray.push(`${counterName} ${resetDelta}`);

					count = resetValue;
				}

				if (element.hasAttribute("data-counter-"+ counterName +"-increment")) {

					increment = element.getAttribute("data-counter-"+ counterName +"-increment");
					incrementValue = parseInt(increment);

					count += incrementValue;

					element.setAttribute("data-counter-"+counterName+"-value", count);

					incrementArray.push(`${counterName} ${incrementValue}`);
				}

				if (incrementArray.length > 0) {
					this.incrementCounterForElement(element, incrementArray);
				}

			}
		}

		incrementCounterForElement(element, incrementArray) {
			if (!element || !incrementArray || incrementArray.length === 0) return;

			const ref = element.dataset.ref;
			const prevIncrements = Array.from(this.styleSheet.cssRules).filter((rule) => {
				return rule.selectorText === `[data-ref="${element.dataset.ref}"]:not([data-split-from])`
							 && rule.style[0] === "counter-increment";
			});

			const increments = [];
			for (let styleRule of prevIncrements) {
				let values = styleRule.style.counterIncrement.split(" ");
				for (let i = 0; i < values.length; i+=2) {
					increments.push(values[i] + " " + values[i+1]);
				}
			}

			Array.prototype.push.apply(increments, incrementArray);

			this.insertRule(`[data-ref="${ref}"]:not([data-split-from]) { counter-increment: ${increments.join(" ")} }`);
		}

		afterPageLayout(pageElement, page) {
			let pgreset = pageElement.querySelectorAll("[data-counter-page-reset]");
			pgreset.forEach((reset) => {
				const ref = reset.dataset && reset.dataset.ref;
				if (ref && this.resetCountersMap.has(ref)) ; else {
					if (ref) {
						this.resetCountersMap.set(ref, "");
					}
					let value = reset.dataset.counterPageReset;
					this.styleSheet.insertRule(`[data-page-number="${pageElement.dataset.pageNumber}"] { counter-increment: none; counter-reset: page ${value}; }`, this.styleSheet.cssRules.length);
				}
			});
		}

	}

	class Lists extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}
		afterParsed(content) {
			const orderedLists = content.querySelectorAll("ol");

			for (var list of orderedLists) {
				this.addDataNumbers(list);
			}
		}

		afterPageLayout(pageElement, page, breakToken, chunker) {
			var orderedLists = pageElement.getElementsByTagName("ol");
			for (var list of orderedLists) {
				if (list.hasChildNodes()) {
					list.start = list.firstElementChild.dataset.itemNum;
				}
				else {
					list.parentNode.removeChild(list);
				}
			}
		}

		addDataNumbers(list) {
			let start = 1;
			if (list.hasAttribute("start")) {
				start = parseInt(list.getAttribute("start"), 10);
				if (isNaN(start)) {
					start = 1;
				}
			}
			let items = list.children;
			for (var i = 0; i < items.length; i++) {
				items[i].setAttribute("data-item-num", i + start);
			}
		}

	}

	class PositionFixed extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.styleSheet = polisher.styleSheet;
			this.fixedElementsSelector = [];
			this.fixedElements = [];
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position" && declaration.value.children.first().name === "fixed") {
				let selector = lib.generate(rule.ruleNode.prelude);
				this.fixedElementsSelector.push(selector);
				dList.remove(dItem);
			}
		}

		afterParsed(fragment) {
			this.fixedElementsSelector.forEach(fixedEl => {
				fragment.querySelectorAll(`${fixedEl}`).forEach(el => {
					el.style.setProperty("position", "absolute");
					this.fixedElements.push(el);
					el.remove();
				});
			});
		}

		afterPageLayout(pageElement, page, breakToken) {
			this.fixedElements.forEach(el => {
				const clone = el.cloneNode(true);
				pageElement.querySelector(".pagedjs_pagebox").insertAdjacentElement("afterbegin", clone);
			});
		}
	}

	class PageCounterIncrement extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.pageCounter = {
				name: "page",
				increments: {},
				resets: {}
			};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			const property = declaration.property;

			if (property === "counter-increment") {
				let inc = this.handleIncrement(declaration, rule);
				if (inc) {
					dList.remove(dItem);
				}
			}
		}

		afterParsed(_) {
			for (const inc in this.pageCounter.increments) {
				const increment = this.pageCounter.increments[inc];
				this.insertRule(`${increment.selector} { --pagedjs-page-counter-increment: ${increment.number} }`);
			}
		}

		handleIncrement(declaration, rule) {
			const identifier = declaration.value.children.first();
			const number = declaration.value.children.getSize() > 1 ? declaration.value.children.last().value : 1;
			const name = identifier && identifier.name;

			if (name.indexOf("target-counter-") === 0) {
				return;
			}
			// A counter named page is automatically created and incremented by 1 on every page of the document,
			// unless the counter-increment property in the page context explicitly specifies a different increment for the page counter.
			// https://www.w3.org/TR/css-page-3/#page-based-counters
			if (name !== "page") {
				return;
			}
			// the counter-increment property is not defined on the page context (i.e. @page rule), ignoring...
			if (rule.ruleNode.name === "page" && rule.ruleNode.type === "Atrule") {
				return;
			}
			const selector = lib.generate(rule.ruleNode.prelude);
			return this.pageCounter.increments[selector] = {
				selector: selector,
				number
			};
		}

		insertRule(rule) {
			this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
		}
	}

	class NthOfType extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/:(first|last|nth)-of-type/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "nth-of-type-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataNthOfType = elements[i].getAttribute("data-nth-of-type");

					if (dataNthOfType && dataNthOfType != "") {
						dataNthOfType = `${dataNthOfType},${selectors[s][0]}`;
						elements[i].setAttribute("data-nth-of-type", dataNthOfType);
					} else {
						elements[i].setAttribute("data-nth-of-type", selectors[s][0]);
					}
				}

				let rule = `*[data-nth-of-type*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	class Following extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.selectors = {};
		}

		onRule(ruleNode, ruleItem, rulelist) {
			let selector = lib.generate(ruleNode.prelude);
			if (selector.match(/\+/)) {
				
				let declarations = lib.generate(ruleNode.block);
				declarations = declarations.replace(/[{}]/g,"");

				let uuid = "following-" + UUID();

				selector.split(",").forEach((s) => {
					if (!this.selectors[s]) {
						this.selectors[s] = [uuid, declarations];
					} else {
						this.selectors[s][1] = `${this.selectors[s][1]};${declarations}` ;
					}
				});

				rulelist.remove(ruleItem);
			}
		}

		afterParsed(parsed) {
			this.processSelectors(parsed, this.selectors);
		}

		processSelectors(parsed, selectors) {
			// add the new attributes to matching elements
			for (let s in selectors) {
				let elements = parsed.querySelectorAll(s);

				for (var i = 0; i < elements.length; i++) {
					let dataFollowing = elements[i].getAttribute("data-following");

					if (dataFollowing && dataFollowing != "") {
						dataFollowing = `${dataFollowing},${selectors[s][0]}`;
						elements[i].setAttribute("data-following", dataFollowing);
					} else {
						elements[i].setAttribute("data-following", selectors[s][0]);
					}
				}

				let rule = `*[data-following*='${selectors[s][0]}'] { ${selectors[s][1]}; }`;
				this.styleSheet.insertRule(rule, this.styleSheet.cssRules.length);
			}
		}
	}

	var pagedMediaHandlers = [
		AtPage,
		Breaks,
		PrintMedia,
		Splits,
		Counters,
		Lists,
		PositionFixed,
		PageCounterIncrement,
		NthOfType,
		Following
	];

	class RunningHeaders extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.runningSelectors = {};
			this.elements = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "position") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let identifier = declaration.value.children.first().name;

				if (identifier === "running") {
					let value;
					lib.walk(declaration, {
						visit: "Function",
						enter: (node, item, list) => {
							value = node.children.first().name;
						}
					});

					this.runningSelectors[value] = {
						identifier: identifier,
						value: value,
						selector: selector
					};
				}
			}

			if (declaration.property === "content") {

				lib.walk(declaration, {
					visit: "Function",
					enter: (funcNode, fItem, fList) => {

						if (funcNode.name.indexOf("element") > -1) {

							let selector = lib.generate(rule.ruleNode.prelude);

							let func = funcNode.name;

							let value = funcNode.children.first().name;

							let args = [value];

							// we only handle first for now
							let style = "first";

							selector.split(",").forEach((s) => {
								// remove before / after
								s = s.replace(/::after|::before/, "");

								this.elements[s] = {
									func: func,
									args: args,
									value: value,
									style: style ,
									selector: s,
									fullSelector: selector
								};
							});
						}

					}
				});
			}
		}

		afterParsed(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = Array.from(fragment.querySelectorAll(set.selector));

				if (set.identifier === "running") {
					for (let header of selected) {
						header.style.display = "none";
					}
				}

			}
		}

		afterPageLayout(fragment) {
			for (let name of Object.keys(this.runningSelectors)) {
				let set = this.runningSelectors[name];
				let selected = fragment.querySelector(set.selector);
				if (selected) {
					// let cssVar;
					if (set.identifier === "running") {
						// cssVar = selected.textContent.replace(/\\([\s\S])|(["|'])/g,"\\$1$2");
						// this.styleSheet.insertRule(`:root { --string-${name}: "${cssVar}"; }`, this.styleSheet.cssRules.length);
						// fragment.style.setProperty(`--string-${name}`, `"${cssVar}"`);
						set.first = selected;
					} else {
						console.warn(set.value + "needs css replacement");
					}
				}
			}

			// move elements
			if (!this.orderedSelectors) {
				this.orderedSelectors = this.orderSelectors(this.elements);
			}

			for (let selector of this.orderedSelectors) {
				if (selector) {

					let el = this.elements[selector];
					let selected = fragment.querySelector(selector);
					if (selected) {
						let running = this.runningSelectors[el.args[0]];
						if (running && running.first) {
							selected.innerHTML = ""; // Clear node
							// selected.classList.add("pagedjs_clear-after"); // Clear ::after
							let clone = running.first.cloneNode(true);
							clone.style.display = null;
							selected.appendChild(clone);
						}
					}
				}
			}
		}

		/**
		* Assign a weight to @page selector classes
		* 1) page
		* 2) left & right
		* 3) blank
		* 4) first & nth
		* 5) named page
		* 6) named left & right
		* 7) named first & nth
		* @param {string} [s] selector string
		* @return {int} weight
		*/
		pageWeight(s) {
			let weight = 1;
			let selector = s.split(" ");
			let parts = selector.length && selector[0].split(".");

			parts.shift(); // remove empty first part

			switch (parts.length) {
				case 4:
					if (parts[3] === "pagedjs_first_page") {
						weight = 7;
					} else if (parts[3] === "pagedjs_left_page" || parts[3] === "pagedjs_right_page") {
						weight = 6;
					}
					break;
				case 3:
					if (parts[1] === "pagedjs_named_page") {
						if (parts[2].indexOf(":nth-of-type") > -1) {
							weight = 7;
						} else {
							weight = 5;
						}
					}
					break;
				case 2:
					if (parts[1] === "pagedjs_first_page") {
						weight = 4;
					} else if (parts[1] === "pagedjs_blank_page") {
						weight = 3;
					} else if (parts[1] === "pagedjs_left_page" || parts[1] === "pagedjs_right_page") {
						weight = 2;
					}
					break;
				default:
					if (parts[0].indexOf(":nth-of-type") > -1) {
						weight = 4;
					} else {
						weight = 1;
					}
			}

			return weight;
		}

		/**
		* Orders the selectors based on weight
		*
		* Does not try to deduplicate base on specifity of the selector
		* Previous matched selector will just be overwritten
		* @param {obj} [obj] selectors object
		* @return {Array} orderedSelectors
		*/
		orderSelectors(obj) {
			let selectors = Object.keys(obj);
			let weighted = {
				1: [],
				2: [],
				3: [],
				4: [],
				5: [],
				6: [],
				7: []
			};

			let orderedSelectors = [];

			for (let s of selectors) {
				let w = this.pageWeight(s);
				weighted[w].unshift(s);
			}

			for (var i = 1; i <= 7; i++) {
				orderedSelectors = orderedSelectors.concat(weighted[i]);
			}

			return orderedSelectors;
		}

		beforeTreeParse(text, sheet) {
			// element(x) is parsed as image element selector, so update element to element-ident
			sheet.text = text.replace(/element[\s]*\(([^|^#)]*)\)/g, "element-ident($1)");
		}
	}

	function cleanPseudoContent(el, trim = "\"' ") {
		if(el == null) return;
		return el
			.replace(new RegExp(`^[${trim}]+`), "")
			.replace(new RegExp(`[${trim}]+$`), "")
			.replace(/["']/g, match => {
				return "\\" + match;
			})
			.replace(/[\n]/g, match => {
				return "\\00000A";
			});
	}

	function cleanSelector(el) {
		if(el == null) return;
		return el
			.replace(new RegExp("::footnote-call", "g"), "")
			.replace(new RegExp("::footnote-marker", "g"), "");
	}

	class StringSets extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.stringSetSelectors = {};
			this.type;
			// pageLastString = last string variable defined on the page 
			this.pageLastString;

		}
		
		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "string-set") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let identifier = declaration.value.children.first().name;

				let value;
				lib.walk(declaration, {
					visit: "Function",
					enter: (node, item, list) => {
						value = lib.generate(node);
					}
				});

				this.stringSetSelectors[identifier] = {
					identifier,
					value,
					selector
				};
			}
		}

		onContent(funcNode, fItem, fList, declaration, rule) {

			if (funcNode.name === "string") {
				let identifier = funcNode.children && funcNode.children.first().name;
				this.type = funcNode.children.last().name;
				funcNode.name = "var";
				funcNode.children = new lib.List();

	 
				if(this.type === "first" || this.type === "last" || this.type === "start" || this.type === "first-except"){
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-" + this.type + "-" + identifier
						})
					);
				}else {
					funcNode.children.append(
						funcNode.children.createItem({
							type: "Identifier",
							loc: null,
							name: "--pagedjs-string-first-" + identifier
						})
					);
				}
			}
		}

		afterPageLayout(fragment) {

		
			if ( this.pageLastString === undefined )
			{
				this.pageLastString = {};
			}
		
			
			for (let name of Object.keys(this.stringSetSelectors)) {
		
				let set = this.stringSetSelectors[name];
				let selected = fragment.querySelectorAll(set.selector);

				// Get the last found string for the current identifier
				let stringPrevPage = ( name in this.pageLastString ) ? this.pageLastString[name] : "";

				let varFirst, varLast, varStart, varFirstExcept;

				if(selected.length == 0){
					// if there is no sel. on the page
					varFirst = stringPrevPage;
					varLast = stringPrevPage;
					varStart = stringPrevPage;
					varFirstExcept = stringPrevPage;
				}else {

					selected.forEach((sel) => {
						// push each content into the array to define in the variable the first and the last element of the page.
						this.pageLastString[name] = selected[selected.length - 1].textContent;
					
					});	

					/* FIRST */
		
					varFirst = selected[0].textContent;


					/* LAST */

					varLast = selected[selected.length - 1].textContent;


					/* START */

					// Hack to find if the sel. is the first elem of the page / find a better way 
					let selTop = selected[0].getBoundingClientRect().top;
					let pageContent = selected[0].closest(".pagedjs_page_content");
					let pageContentTop = pageContent.getBoundingClientRect().top;

					if(selTop == pageContentTop){
						varStart = varFirst;
					}else {
						varStart = stringPrevPage;
					}

					/* FIRST EXCEPT */

					varFirstExcept = "";
					
				}

				fragment.style.setProperty(`--pagedjs-string-first-${name}`, `"${cleanPseudoContent(varFirst)}`);
				fragment.style.setProperty(`--pagedjs-string-last-${name}`, `"${cleanPseudoContent(varLast)}`);
				fragment.style.setProperty(`--pagedjs-string-start-${name}`, `"${cleanPseudoContent(varStart)}`);
				fragment.style.setProperty(`--pagedjs-string-first-except-${name}`, `"${cleanPseudoContent(varFirstExcept)}`);
				
		
			}
		}
		

	}

	class TargetCounters extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;

			this.counterTargets = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-counter") {
				let selector = lib.generate(rule.ruleNode.prelude);

				let first = funcNode.children.first();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach((child) => {
					if (child.type === "Identifier") {

						args.push(child.name);
					}
				});

				let counter;
				let style;
				let styleIdentifier;

				funcNode.children.forEach((child) => {
					if (child.type === "Identifier") {
						if (!counter) {
							counter = child.name;
						} else if (!style) {
							styleIdentifier = lib.clone(child);
							style = child.name;
						}
					}
				});

				let variable = "target-counter-" + UUID();

				selector.split(",").forEach((s) => {
					this.counterTargets[s] = {
						func: func,
						args: args,
						value: value,
						counter: counter,
						style: style,
						selector: s,
						fullSelector: selector,
						variable: variable
					};
				});

				// Replace with counter
				funcNode.name = "counter";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});

				if (styleIdentifier) {
					funcNode.children.appendData({type: "Operator", loc: null, value: ","});
					funcNode.children.appendData(styleIdentifier);
				}
			}
		}

		afterPageLayout(fragment, page, breakToken, chunker) {
			Object.keys(this.counterTargets).forEach((name) => {
				let target = this.counterTargets[name];
				let split = target.selector.split("::");
				let query = split[0];

				let queried = chunker.pagesArea.querySelectorAll(query + ":not([data-" + target.variable + "])");

				queried.forEach((selected, index) => {
					// TODO: handle func other than attr
					if (target.func !== "attr") {
						return;
					}
					let val = attr(selected, target.args);
					let element = chunker.pagesArea.querySelector(querySelectorEscape(val));

					if (element) {
						let selector = UUID();
						selected.setAttribute("data-" + target.variable, selector);
						// TODO: handle other counter types (by query)
						let pseudo = "";
						if (split.length > 1) {
							pseudo += "::" + split[1];
						}
						if (target.counter === "page") {
							let pages = chunker.pagesArea.querySelectorAll(".pagedjs_page");
							let pg = 0;
							for (let i = 0; i < pages.length; i++) {
								let styles = window.getComputedStyle(pages[i]);
								let reset = styles["counter-reset"].replace("page", "").trim();
								let increment = styles["counter-increment"].replace("page", "").trim();

								if (reset !== "none") {
									pg = parseInt(reset);
								}
								if (increment !== "none") {
									pg += parseInt(increment);
								}

								if (pages[i].contains(element)) {
									break;
								}
							}

							this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${pg}; }`, this.styleSheet.cssRules.length);
						} else {
							let value = element.getAttribute(`data-counter-${target.counter}-value`);
							if (value) {
								this.styleSheet.insertRule(`[data-${target.variable}="${selector}"]${pseudo} { counter-reset: ${target.variable} ${target.variable} ${parseInt(value)}; }`, this.styleSheet.cssRules.length);
							}
						}
					}
				});
			});
		}
	}

	// import { nodeAfter } from "../../utils/dom";

	class TargetText extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);

			this.styleSheet = polisher.styleSheet;
			this.textTargets = {};
			this.beforeContent = "";
			this.afterContent = "";
			this.selector = {};
		}

		onContent(funcNode, fItem, fList, declaration, rule) {
			if (funcNode.name === "target-text") {
				this.selector = lib.generate(rule.ruleNode.prelude);
				let first = funcNode.children.first();
				let last = funcNode.children.last();
				let func = first.name;

				let value = lib.generate(funcNode);

				let args = [];

				first.children.forEach(child => {
					if (child.type === "Identifier") {
						args.push(child.name);
					}
				});

				let style;
				if (last !== first) {
					style = last.name;
				}

				let variable = "--pagedjs-" + UUID();

				this.selector.split(",").forEach(s => {
					this.textTargets[s] = {
						func: func,
						args: args,
						value: value,
						style: style || "content",
						selector: s,
						fullSelector: this.selector,
						variable: variable
					};
				});

				// Replace with variable
				funcNode.name = "var";
				funcNode.children = new lib.List();
				funcNode.children.appendData({
					type: "Identifier",
					loc: 0,
					name: variable
				});
			}
		}

		//   parse this on the ONCONTENT : get all before and after and replace the value with a variable
		onPseudoSelector(pseudoNode, pItem, pList, selector, rule) {
			// console.log(pseudoNode);
			// console.log(rule);

			rule.ruleNode.block.children.forEach(properties => {
				if (pseudoNode.name === "before" && properties.property === "content") {
					// let beforeVariable = "--pagedjs-" + UUID();

					let contenu = properties.value.children;
					contenu.forEach(prop => {
						if (prop.type === "String") {
							this.beforeContent = prop.value;
						}
					});
				} else if (pseudoNode.name === "after" && properties.property === "content") {
					properties.value.children.forEach(prop => {
						if (prop.type === "String") {
							this.afterContent = prop.value;
						}
					});
				}
			});
		}

		afterParsed(fragment) {
			Object.keys(this.textTargets).forEach(name => {
				let target = this.textTargets[name];
				let split = target.selector.split("::");
				let query = split[0];
				let queried = fragment.querySelectorAll(query);
				let textContent;
				queried.forEach((selected, index) => {
					let val = attr(selected, target.args);
					let element = fragment.querySelector(querySelectorEscape(val));
					if (element) {
						// content & first-letter & before & after refactorized
						if (target.style) {
							this.selector = UUID();
							selected.setAttribute("data-target-text", this.selector);

							let psuedo = "";
							if (split.length > 1) {
								psuedo += "::" + split[1];
							}
							
							if (target.style === "before" || target.style === "after") {
								const pseudoType = `${target.style}Content`;
								textContent = cleanPseudoContent(this[pseudoType]);
							} else {
								textContent = cleanPseudoContent(element.textContent, " ");
							}
							textContent = target.style === "first-letter" ? textContent.charAt(0) : textContent;
							this.styleSheet.insertRule(`[data-target-text="${this.selector}"]${psuedo} { ${target.variable}: "${textContent}" }`);
						} else {
							console.warn("missed target", val);
						}
					}
				});
			});
		}
	}

	var generatedContentHandlers = [
		RunningHeaders,
		StringSets,
		TargetCounters,
		TargetText
	];

	class WhiteSpaceFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {

			filterTree(content, (node) => {
				return this.filterEmpty(node);
			}, NodeFilter.SHOW_TEXT);

		}

		filterEmpty(node) {
			if (node.textContent.length > 1 && isIgnorable(node)) {

				// Do not touch the content if text is pre-formatted
				let parent = node.parentNode;
				let pre = isElement(parent) && parent.closest("pre");
				if (pre) {
					return NodeFilter.FILTER_REJECT;
				}

				const previousSibling = previousSignificantNode(node);
				const nextSibling = nextSignificantNode(node);

				if (nextSibling === null && previousSibling === null) {
					// we should not remove a Node that does not have any siblings.
					node.textContent = " ";
					return NodeFilter.FILTER_REJECT;
				}
				if (nextSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}
				if (previousSibling === null) {
					// we can safely remove this node
					return NodeFilter.FILTER_ACCEPT;
				}

				// replace the content with a single space
				node.textContent = " ";

				// TODO: we also need to preserve sequences of white spaces when the parent has "white-space" rule:
				// pre
				// Sequences of white space are preserved. Lines are only broken at newline characters in the source and at <br> elements.
				//
				// pre-wrap
				// Sequences of white space are preserved. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// pre-line
				// Sequences of white space are collapsed. Lines are broken at newline characters, at <br>, and as necessary to fill line boxes.
				//
				// break-spaces
				// The behavior is identical to that of pre-wrap, except that:
				// - Any sequence of preserved white space always takes up space, including at the end of the line.
				// - A line breaking opportunity exists after every preserved white space character, including between white space characters.
				// - Such preserved spaces take up space and do not hang, and thus affect the box’s intrinsic sizes (min-content size and max-content size).
				//
				// See: https://developer.mozilla.org/en-US/docs/Web/CSS/white-space#Values

				return NodeFilter.FILTER_REJECT;
			} else {
				return NodeFilter.FILTER_REJECT;
			}
		}

	}

	class CommentsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			filterTree(content, null, NodeFilter.SHOW_COMMENT);
		}

	}

	class ScriptsFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
		}

		filter(content) {
			content.querySelectorAll("script").forEach( script => { script.remove(); });
		}

	}

	var clearCut = createCommonjsModule(function (module, exports) {
	/**
	 * Originally ported from https://github.com/keeganstreet/specificity/blob/866bf7ab4e7f62a7179c15b13a95af4e1c7b1afa/specificity.js
	 *
	 * Calculates the specificity of CSS selectors
	 * http://www.w3.org/TR/css3-selectors/#specificity
	 *
	 * Returns a selector integer value
	 */

	// The following regular expressions assume that selectors matching the preceding regular expressions have been removed
	var attributeRegex = /(\[[^\]]+\])/g;
	var idRegex = /(#[^\s\+>~\.\[:]+)/g;
	var classRegex = /(\.[^\s\+>~\.\[:]+)/g;
	var pseudoElementRegex = /(::[^\s\+>~\.\[:]+|:first-line|:first-letter|:before|:after)/g;
	var pseudoClassRegex = /(:[^\s\+>~\.\[:]+)/g;
	var elementRegex = /([^\s\+>~\.\[:]+)/g;
	var notRegex = /:not\(([^\)]*)\)/g;
	var ruleRegex = /\{[^]*/gm;
	var separatorRegex = /[\*\s\+>~]/g;
	var straysRegex = /[#\.]/g;

	// Find matches for a regular expression in a string and push their details to parts
	// Type is "a" for IDs, "b" for classes, attributes and pseudo-classes and "c" for elements and pseudo-elements
	var findMatch = function(regex, type, types, selector) {
	  var matches = selector.match(regex);
	  if (matches) {
	    for (var i = 0; i < matches.length; i++) {
	      types[type]++;
	      // Replace this simple selector with whitespace so it won't be counted in further simple selectors
	      selector = selector.replace(matches[i], ' ');
	    }
	  }

	  return selector;
	};

	// Calculate the specificity for a selector by dividing it into simple selectors and counting them
	var calculate = function(selector) {
	  var commaIndex = selector.indexOf(',');
	  if (commaIndex !== -1) {
	    selector = selector.substring(0, commaIndex);
	  }

	  var  types = {
	    a: 0,
	    b: 0,
	    c: 0
	  };

	  // Remove the negation psuedo-class (:not) but leave its argument because specificity is calculated on its argument
	  selector = selector.replace(notRegex, ' $1 ');

	  // Remove anything after a left brace in case a user has pasted in a rule, not just a selector
	  selector = selector.replace(ruleRegex, ' ');

	  // Add attribute selectors to parts collection (type b)
	  selector = findMatch(attributeRegex, 'b', types, selector);

	  // Add ID selectors to parts collection (type a)
	  selector = findMatch(idRegex, 'a', types, selector);

	  // Add class selectors to parts collection (type b)
	  selector = findMatch(classRegex, 'b', types, selector);

	  // Add pseudo-element selectors to parts collection (type c)
	  selector = findMatch(pseudoElementRegex, 'c', types, selector);

	  // Add pseudo-class selectors to parts collection (type b)
	  selector = findMatch(pseudoClassRegex, 'b', types, selector);

	  // Remove universal selector and separator characters
	  selector = selector.replace(separatorRegex, ' ');

	  // Remove any stray dots or hashes which aren't attached to words
	  // These may be present if the user is live-editing this selector
	  selector = selector.replace(straysRegex, ' ');

	  // The only things left should be element selectors (type c)
	  findMatch(elementRegex, 'c', types, selector);

	  return (types.a * 100) + (types.b * 10) + (types.c * 1);
	};

	var specificityCache = {};

	exports.calculateSpecificity = function(selector) {
	  var specificity = specificityCache[selector];
	  if (specificity === undefined) {
	    specificity = calculate(selector);
	    specificityCache[selector] = specificity;
	  }
	  return specificity;
	};

	var validSelectorCache = {};
	var testSelectorElement = null;

	exports.isSelectorValid = function(selector) {
	  var valid = validSelectorCache[selector];
	  if (valid === undefined) {
	    if (testSelectorElement == null) {
	      testSelectorElement = document.createElement('div');
	    }

	    try {
	      testSelectorElement.querySelector(selector);
	      valid = true;
	    } catch (error) {
	      valid = false;
	    }
	    validSelectorCache[selector] = valid;
	  }
	  return valid;
	};

	exports.validateSelector = function(selector) {
	  if (!exports.isSelectorValid(selector)) {
	    var error = new SyntaxError(selector + ' is not a valid selector');
	    error.code = 'EBADSELECTOR';
	    throw error;
	  }
	};
	});
	var clearCut_1 = clearCut.calculateSpecificity;
	var clearCut_2 = clearCut.isSelectorValid;
	var clearCut_3 = clearCut.validateSelector;

	class UndisplayedFilter extends Handler {
		constructor(chunker, polisher, caller) {
			super(chunker, polisher, caller);
			this.displayRules = {};
		}

		onDeclaration(declaration, dItem, dList, rule) {
			if (declaration.property === "display") {
				let selector = lib.generate(rule.ruleNode.prelude);
				let value = declaration.value.children.first().name;

				selector.split(",").forEach((s) => {
					this.displayRules[s] = {
						value: value,
						selector: s,
						specificity: clearCut_1(s),
						important: declaration.important
					};
				});
			}
		}

		filter(content) {
			let { matches, selectors } = this.sortDisplayedSelectors(content, this.displayRules);

			// Find matching elements that have display styles
			for (let i = 0; i < matches.length; i++) {
				let element = matches[i];
				let selector = selectors[i];
				let displayValue = selector[selector.length-1].value;
				if(this.removable(element) && displayValue === "none") {
					element.dataset.undisplayed = "undisplayed";
				}
			}

			// Find elements that have inline styles
			let styledElements = content.querySelectorAll("[style]");
			for (let i = 0; i < styledElements.length; i++) {
				let element = styledElements[i];
				if (this.removable(element)) {
					element.dataset.undisplayed = "undisplayed";
				}
			}
		}

		sorter(a, b) {
			if (a.important && !b.important) {
				return 1;
			}

			if (b.important && !a.important) {
				return -1;
			}

			return a.specificity - b.specificity;
		}

		sortDisplayedSelectors(content, displayRules=[]) {
			let matches = [];
			let selectors = [];
			for (let d in displayRules) {
				let displayItem = displayRules[d];
				let selector = displayItem.selector;
				let query = [];
				try {
					try {
						query = content.querySelectorAll(selector);
					} catch (e) {
						query = content.querySelectorAll(cleanSelector(selector));
					}
				} catch (e) {
					query = [];
				}
				let elements = Array.from(query);
				for (let e of elements) {
					if (matches.includes(e)) {
						let index = matches.indexOf(e);
						selectors[index].push(displayItem);
						selectors[index] = selectors[index].sort(this.sorter);
					} else {
						matches.push(e);
						selectors.push([displayItem]);
					}
				}
			}

			return { matches, selectors };
		}

		removable(element) {
			if (element.style &&
					element.style.display !== "" &&
					element.style.display !== "none") {
				return false;
			}

			return true;
		}
	}

	var filters = [
		WhiteSpaceFilter,
		CommentsFilter,
		ScriptsFilter,
		UndisplayedFilter
	];

	var isImplemented$3 = function () {
		var from = Array.from, arr, result;
		if (typeof from !== "function") return false;
		arr = ["raz", "dwa"];
		result = from(arr);
		return Boolean(result && (result !== arr) && (result[1] === "dwa"));
	};

	var validTypes = { object: true, symbol: true };

	var isImplemented$4 = function () {
		var symbol;
		if (typeof Symbol !== 'function') return false;
		symbol = Symbol('test symbol');
		try { String(symbol); } catch (e) { return false; }

		// Return 'true' also for polyfills
		if (!validTypes[typeof Symbol.iterator]) return false;
		if (!validTypes[typeof Symbol.toPrimitive]) return false;
		if (!validTypes[typeof Symbol.toStringTag]) return false;

		return true;
	};

	var isSymbol = function (x) {
		if (!x) return false;
		if (typeof x === 'symbol') return true;
		if (!x.constructor) return false;
		if (x.constructor.name !== 'Symbol') return false;
		return (x[x.constructor.toStringTag] === 'Symbol');
	};

	var validateSymbol = function (value) {
		if (!isSymbol(value)) throw new TypeError(value + " is not a symbol");
		return value;
	};

	var create$6 = Object.create, defineProperties = Object.defineProperties
	  , defineProperty = Object.defineProperty, objPrototype = Object.prototype
	  , NativeSymbol, SymbolPolyfill, HiddenSymbol, globalSymbols = create$6(null)
	  , isNativeSafe;

	if (typeof Symbol === 'function') {
		NativeSymbol = Symbol;
		try {
			String(NativeSymbol());
			isNativeSafe = true;
		} catch (ignore) {}
	}

	var generateName = (function () {
		var created = create$6(null);
		return function (desc) {
			var postfix = 0, name, ie11BugWorkaround;
			while (created[desc + (postfix || '')]) ++postfix;
			desc += (postfix || '');
			created[desc] = true;
			name = '@@' + desc;
			defineProperty(objPrototype, name, d_1.gs(null, function (value) {
				// For IE11 issue see:
				// https://connect.microsoft.com/IE/feedbackdetail/view/1928508/
				//    ie11-broken-getters-on-dom-objects
				// https://github.com/medikoo/es6-symbol/issues/12
				if (ie11BugWorkaround) return;
				ie11BugWorkaround = true;
				defineProperty(this, name, d_1(value));
				ie11BugWorkaround = false;
			}));
			return name;
		};
	}());

	// Internal constructor (not one exposed) for creating Symbol instances.
	// This one is used to ensure that `someSymbol instanceof Symbol` always return false
	HiddenSymbol = function Symbol(description) {
		if (this instanceof HiddenSymbol) throw new TypeError('Symbol is not a constructor');
		return SymbolPolyfill(description);
	};

	// Exposed `Symbol` constructor
	// (returns instances of HiddenSymbol)
	var polyfill = SymbolPolyfill = function Symbol(description) {
		var symbol;
		if (this instanceof Symbol) throw new TypeError('Symbol is not a constructor');
		if (isNativeSafe) return NativeSymbol(description);
		symbol = create$6(HiddenSymbol.prototype);
		description = (description === undefined ? '' : String(description));
		return defineProperties(symbol, {
			__description__: d_1('', description),
			__name__: d_1('', generateName(description))
		});
	};
	defineProperties(SymbolPolyfill, {
		for: d_1(function (key) {
			if (globalSymbols[key]) return globalSymbols[key];
			return (globalSymbols[key] = SymbolPolyfill(String(key)));
		}),
		keyFor: d_1(function (s) {
			var key;
			validateSymbol(s);
			for (key in globalSymbols) if (globalSymbols[key] === s) return key;
		}),

		// To ensure proper interoperability with other native functions (e.g. Array.from)
		// fallback to eventual native implementation of given symbol
		hasInstance: d_1('', (NativeSymbol && NativeSymbol.hasInstance) || SymbolPolyfill('hasInstance')),
		isConcatSpreadable: d_1('', (NativeSymbol && NativeSymbol.isConcatSpreadable) ||
			SymbolPolyfill('isConcatSpreadable')),
		iterator: d_1('', (NativeSymbol && NativeSymbol.iterator) || SymbolPolyfill('iterator')),
		match: d_1('', (NativeSymbol && NativeSymbol.match) || SymbolPolyfill('match')),
		replace: d_1('', (NativeSymbol && NativeSymbol.replace) || SymbolPolyfill('replace')),
		search: d_1('', (NativeSymbol && NativeSymbol.search) || SymbolPolyfill('search')),
		species: d_1('', (NativeSymbol && NativeSymbol.species) || SymbolPolyfill('species')),
		split: d_1('', (NativeSymbol && NativeSymbol.split) || SymbolPolyfill('split')),
		toPrimitive: d_1('', (NativeSymbol && NativeSymbol.toPrimitive) || SymbolPolyfill('toPrimitive')),
		toStringTag: d_1('', (NativeSymbol && NativeSymbol.toStringTag) || SymbolPolyfill('toStringTag')),
		unscopables: d_1('', (NativeSymbol && NativeSymbol.unscopables) || SymbolPolyfill('unscopables'))
	});

	// Internal tweaks for real symbol producer
	defineProperties(HiddenSymbol.prototype, {
		constructor: d_1(SymbolPolyfill),
		toString: d_1('', function () { return this.__name__; })
	});

	// Proper implementation of methods exposed on Symbol.prototype
	// They won't be accessible on produced symbol instances as they derive from HiddenSymbol.prototype
	defineProperties(SymbolPolyfill.prototype, {
		toString: d_1(function () { return 'Symbol (' + validateSymbol(this).__description__ + ')'; }),
		valueOf: d_1(function () { return validateSymbol(this); })
	});
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toPrimitive, d_1('', function () {
		var symbol = validateSymbol(this);
		if (typeof symbol === 'symbol') return symbol;
		return symbol.toString();
	}));
	defineProperty(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d_1('c', 'Symbol'));

	// Proper implementaton of toPrimitive and toStringTag for returned symbol instances
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toStringTag,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toStringTag]));

	// Note: It's important to define `toPrimitive` as last one, as some implementations
	// implement `toPrimitive` natively without implementing `toStringTag` (or other specified symbols)
	// And that may invoke error in definition flow:
	// See: https://github.com/medikoo/es6-symbol/issues/13#issuecomment-164146149
	defineProperty(HiddenSymbol.prototype, SymbolPolyfill.toPrimitive,
		d_1('c', SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive]));

	var es6Symbol = isImplemented$4() ? Symbol : polyfill;

	var objToString = Object.prototype.toString
	  , id = objToString.call(
		(function () {
			return arguments;
		})()
	);

	var isArguments = function (value) {
		return objToString.call(value) === id;
	};

	var objToString$1 = Object.prototype.toString, id$1 = objToString$1.call(noop);

	var isFunction = function (value) {
		return typeof value === "function" && objToString$1.call(value) === id$1;
	};

	var isImplemented$5 = function () {
		var sign = Math.sign;
		if (typeof sign !== "function") return false;
		return (sign(10) === 1) && (sign(-20) === -1);
	};

	var shim$3 = function (value) {
		value = Number(value);
		if (isNaN(value) || (value === 0)) return value;
		return value > 0 ? 1 : -1;
	};

	var sign = isImplemented$5()
		? Math.sign
		: shim$3;

	var abs = Math.abs, floor = Math.floor;

	var toInteger = function (value) {
		if (isNaN(value)) return 0;
		value = Number(value);
		if ((value === 0) || !isFinite(value)) return value;
		return sign(value) * floor(abs(value));
	};

	var max$1 = Math.max;

	var toPosInteger = function (value) {
	 return max$1(0, toInteger(value));
	};

	var objToString$2 = Object.prototype.toString, id$2 = objToString$2.call("");

	var isString = function (value) {
		return (
			typeof value === "string" ||
			(value &&
				typeof value === "object" &&
				(value instanceof String || objToString$2.call(value) === id$2)) ||
			false
		);
	};

	var iteratorSymbol = es6Symbol.iterator
	  , isArray        = Array.isArray
	  , call           = Function.prototype.call
	  , desc           = { configurable: true, enumerable: true, writable: true, value: null }
	  , defineProperty$1 = Object.defineProperty;

	// eslint-disable-next-line complexity
	var shim$4 = function (arrayLike /*, mapFn, thisArg*/) {
		var mapFn = arguments[1]
		  , thisArg = arguments[2]
		  , Context
		  , i
		  , j
		  , arr
		  , length
		  , code
		  , iterator
		  , result
		  , getIterator
		  , value;

		arrayLike = Object(validValue(arrayLike));

		if (isValue(mapFn)) validCallable(mapFn);
		if (!this || this === Array || !isFunction(this)) {
			// Result: Plain array
			if (!mapFn) {
				if (isArguments(arrayLike)) {
					// Source: Arguments
					length = arrayLike.length;
					if (length !== 1) return Array.apply(null, arrayLike);
					arr = new Array(1);
					arr[0] = arrayLike[0];
					return arr;
				}
				if (isArray(arrayLike)) {
					// Source: Array
					arr = new Array(length = arrayLike.length);
					for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
					return arr;
				}
			}
			arr = [];
		} else {
			// Result: Non plain array
			Context = this;
		}

		if (!isArray(arrayLike)) {
			if ((getIterator = arrayLike[iteratorSymbol]) !== undefined) {
				// Source: Iterator
				iterator = validCallable(getIterator).call(arrayLike);
				if (Context) arr = new Context();
				result = iterator.next();
				i = 0;
				while (!result.done) {
					value = mapFn ? call.call(mapFn, thisArg, result.value, i) : result.value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, i, desc);
					} else {
						arr[i] = value;
					}
					result = iterator.next();
					++i;
				}
				length = i;
			} else if (isString(arrayLike)) {
				// Source: String
				length = arrayLike.length;
				if (Context) arr = new Context();
				for (i = 0, j = 0; i < length; ++i) {
					value = arrayLike[i];
					if (i + 1 < length) {
						code = value.charCodeAt(0);
						// eslint-disable-next-line max-depth
						if (code >= 0xd800 && code <= 0xdbff) value += arrayLike[++i];
					}
					value = mapFn ? call.call(mapFn, thisArg, value, j) : value;
					if (Context) {
						desc.value = value;
						defineProperty$1(arr, j, desc);
					} else {
						arr[j] = value;
					}
					++j;
				}
				length = j;
			}
		}
		if (length === undefined) {
			// Source: array or array-like
			length = toPosInteger(arrayLike.length);
			if (Context) arr = new Context(length);
			for (i = 0; i < length; ++i) {
				value = mapFn ? call.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
				if (Context) {
					desc.value = value;
					defineProperty$1(arr, i, desc);
				} else {
					arr[i] = value;
				}
			}
		}
		if (Context) {
			desc.value = null;
			arr.length = length;
		}
		return arr;
	};

	var from_1 = isImplemented$3()
		? Array.from
		: shim$4;

	var isImplemented$6 = function () {
		var numberIsNaN = Number.isNaN;
		if (typeof numberIsNaN !== "function") return false;
		return !numberIsNaN({}) && numberIsNaN(NaN) && !numberIsNaN(34);
	};

	var shim$5 = function (value) {
		// eslint-disable-next-line no-self-compare
		return value !== value;
	};

	var isNan = isImplemented$6()
		? Number.isNaN
		: shim$5;

	var indexOf$2           = Array.prototype.indexOf
	  , objHasOwnProperty = Object.prototype.hasOwnProperty
	  , abs$1               = Math.abs
	  , floor$1             = Math.floor;

	var eIndexOf = function (searchElement /*, fromIndex*/) {
		var i, length, fromIndex, val;
		if (!isNan(searchElement)) return indexOf$2.apply(this, arguments);

		length = toPosInteger(validValue(this).length);
		fromIndex = arguments[1];
		if (isNaN(fromIndex)) fromIndex = 0;
		else if (fromIndex >= 0) fromIndex = floor$1(fromIndex);
		else fromIndex = toPosInteger(this.length) - floor$1(abs$1(fromIndex));

		for (i = fromIndex; i < length; ++i) {
			if (objHasOwnProperty.call(this, i)) {
				val = this[i];
				if (isNan(val)) return i; // Jslint: ignore
			}
		}
		return -1;
	};

	var forEach$1 = Array.prototype.forEach
	  , splice  = Array.prototype.splice;

	// eslint-disable-next-line no-unused-vars
	var remove = function (itemToRemove /*, …item*/) {
		forEach$1.call(
			arguments,
			function (item) {
				var index = eIndexOf.call(this, item);
				if (index !== -1) splice.call(this, index, 1);
			},
			this
		);
	};

	var map = { function: true, object: true };

	var isObject$1 = function (value) {
		return (isValue(value) && map[typeof value]) || false;
	};

	var validObject = function (value) {
		if (!isObject$1(value)) throw new TypeError(value + " is not an Object");
		return value;
	};

	var emit           = eventEmitter.methods.emit

	  , defineProperty$2 = Object.defineProperty
	  , hasOwnProperty$6 = Object.prototype.hasOwnProperty
	  , getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

	var pipe = function (e1, e2/*, name*/) {
		var pipes, pipe, desc, name;

		(validObject(e1) && validObject(e2));
		name = arguments[2];
		if (name === undefined) name = 'emit';

		pipe = {
			close: function () { remove.call(pipes, e2); }
		};
		if (hasOwnProperty$6.call(e1, '__eePipes__')) {
			(pipes = e1.__eePipes__).push(e2);
			return pipe;
		}
		defineProperty$2(e1, '__eePipes__', d_1('c', pipes = [e2]));
		desc = getOwnPropertyDescriptor(e1, name);
		if (!desc) {
			desc = d_1('c', undefined);
		} else {
			delete desc.get;
			delete desc.set;
		}
		desc.value = function () {
			var i, emitter, data = from_1(pipes);
			emit.apply(this, arguments);
			for (i = 0; (emitter = data[i]); ++i) emit.apply(emitter, arguments);
		};
		defineProperty$2(e1, name, desc);
		return pipe;
	};

	let registeredHandlers = [...pagedMediaHandlers, ...generatedContentHandlers, ...filters];

	class Handlers {
		constructor(chunker, polisher, caller) {

			registeredHandlers.forEach((Handler) => {
				let handler = new Handler(chunker, polisher, caller);
				pipe(handler, this);
			});
		}
	}

	eventEmitter(Handlers.prototype);

	function registerHandlers() {
		for (var i = 0; i < arguments.length; i++) {
			registeredHandlers.push(arguments[i]);
		}
	}

	function initializeHandlers(chunker, polisher, caller) {
		let handlers = new Handlers(chunker, polisher, caller);
		return handlers;
	}

	class Previewer {
		constructor(options) {
			// this.preview = this.getParams("preview") !== "false";

			this.settings = options || {};

			// Process styles
			this.polisher = new Polisher(false);

			// Chunk contents
			this.chunker = new Chunker(undefined, undefined, this.settings);

			// Hooks
			this.hooks = {};
			this.hooks.beforePreview = new Hook(this);
			this.hooks.afterPreview = new Hook(this);

			// default size
			this.size = {
				width: {
					value: 8.5,
					unit: "in"
				},
				height: {
					value: 11,
					unit: "in"
				},
				format: undefined,
				orientation: undefined
			};

			this.chunker.on("page", (page) => {
				this.emit("page", page);
			});

			this.chunker.on("rendering", () => {
				this.emit("rendering", this.chunker);
			});
		}

		initializeHandlers() {
			let handlers = initializeHandlers(this.chunker, this.polisher, this);

			handlers.on("size", (size) => {
				this.size = size;
				this.emit("size", size);
			});

			handlers.on("atpages", (pages) => {
				this.atpages = pages;
				this.emit("atpages", pages);
			});

			return handlers;
		}

		registerHandlers() {
			return registerHandlers.apply(registerHandlers, arguments);
		}

		getParams(name) {
			let param;
			let url = new URL(window.location);
			let params = new URLSearchParams(url.search);
			for(var pair of params.entries()) {
				if(pair[0] === name) {
					param = pair[1];
				}
			}

			return param;
		}

		wrapContent() {
			// Wrap body in template tag
			let body = document.querySelector("body");

			// Check if a template exists
			let template;
			template = body.querySelector(":scope > template[data-ref='pagedjs-content']");

			if (!template) {
				// Otherwise create one
				template = document.createElement("template");
				template.dataset.ref = "pagedjs-content";
				template.innerHTML = body.innerHTML;
				body.innerHTML = "";
				body.appendChild(template);
			}

			return template.content;
		}

		removeStyles(doc=document) {
			// Get all stylesheets
			let stylesheets = Array.from(doc.querySelectorAll("link[rel='stylesheet']"));
			let hrefs = stylesheets.map((sheet) => {
				sheet.remove();
				return sheet.href;
			});

			// Get inline styles
			let inlineStyles = Array.from(doc.querySelectorAll("style:not([data-pagedjs-inserted-styles])"));
			inlineStyles.forEach((inlineStyle) => {
				let obj = {};
				obj[window.location.href] = inlineStyle.textContent;
				hrefs.push(obj);
				inlineStyle.remove();
			});

			return hrefs;
		}

		async preview(content, stylesheets, renderTo) {

			await this.hooks.beforePreview.trigger(content, renderTo);

			if (!content) {
				content = this.wrapContent();
			}

			if (!stylesheets) {
				stylesheets = this.removeStyles();
			}

			this.polisher.setup();

			this.handlers = this.initializeHandlers();

			await this.polisher.add(...stylesheets);

			let startTime = performance.now();

			// Render flow
			let flow = await this.chunker.flow(content, renderTo);

			let endTime = performance.now();

			flow.performance = (endTime - startTime);
			flow.size = this.size;

			this.emit("rendered", flow);

			await this.hooks.afterPreview.trigger(flow.pages);

			return flow;
		}
	}

	eventEmitter(Previewer.prototype);

	var Paged = /*#__PURE__*/Object.freeze({
		__proto__: null,
		Chunker: Chunker,
		Polisher: Polisher,
		Previewer: Previewer,
		Handler: Handler,
		registerHandlers: registerHandlers,
		initializeHandlers: initializeHandlers
	});

	window.Paged = Paged;

	let ready = new Promise(function(resolve, reject){
		if (document.readyState === "interactive" || document.readyState === "complete") {
			resolve(document.readyState);
			return;
		}

		document.onreadystatechange = function ($) {
			if (document.readyState === "interactive") {
				resolve(document.readyState);
			}
		};
	});

	let config = window.PagedConfig || {
		auto: true,
		before: undefined,
		after: undefined,
		content: undefined,
		stylesheets: undefined,
		renderTo: undefined,
		settings: undefined
	};

	let previewer = new Previewer(config.settings);

	ready.then(async function () {
		let done;
		if (config.before) {
			await config.before();
		}

		if(config.auto !== false) {
			done = await previewer.preview(config.content, config.stylesheets, config.renderTo);
		}


		if (config.after) {
			await config.after(done);
		}
	});

	return previewer;

})));
</script>
<script>// Hooks for paged.js
{
  // Utils
  let pandocMeta, pandocMetaToString;
  {
    let el = document.getElementById('pandoc-meta');
    pandocMeta = el ? JSON.parse(el.firstChild.data) : {};
  }

  pandocMetaToString = meta => {
    let el = document.createElement('div');
    el.innerHTML = meta;
    return el.innerText;
  };

  let isString = value => {
    return typeof value === 'string' || value instanceof String;
  };

  let isArray = value => {
    return value && typeof value === 'object' && value.constructor === Array;
  };

  // This hook is an attempt to fix https://github.com/rstudio/pagedown/issues/131
  // Sometimes, the {break-after: avoid;} declaration applied on headers
  // lead to duplicated headers. I hate this bug.
  // This is linked to the way the HTML source is written
  // When we have the \n character like this: <div>\n<h1>...</h1>
  // the header may be duplicated.
  // But, if we have <div><h1>...</h1> without any \n, the problem disappear
  // I think this handler can fix most of cases
  // Obviously, we cannot suppress all the \n in the HTML document
  // because carriage returns are important in <pre> elements.
  // Tested with Chrome 76.0.3809.100/Windows
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
      this.carriageReturn = String.fromCharCode(10);
    }

    checkNode(node) {
      if (!node) return;
      if (node.nodeType !== 3) return;
      if (node.textContent === this.carriageReturn) {
        node.remove();
      }
    }

    afterParsed(parsed) {
      let template = document.querySelector('template').content;
      const breakAfterAvoidElements = template.querySelectorAll('[data-break-after="avoid"], [data-break-before="avoid"]');
      for (let el of breakAfterAvoidElements) {
        this.checkNode(el.previousSibling);
        this.checkNode(el.nextSibling);
      }
    }
  });

  // This hook creates a list of abbreviations
  // Note: we also could implement this feature using a Pandoc filter
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // Find the abbreviation nodes
      const abbrNodeList = content.querySelectorAll('abbr');

      // Return early if there is no abbreviation
      if (abbrNodeList.length === 0) return;

      // Store unique values of abbreviations, see https://github.com/rstudio/pagedown/issues/218
      let abbreviations = [];
      for (const {title, innerHTML} of abbrNodeList.values()) {
        if (abbreviations.find(el => el.title === title && el.innerHTML === innerHTML)) {
          continue;
        }
        abbreviations.push({title: title, innerHTML: innerHTML});
      }

      const loaTitle = pandocMeta['loa-title'] ? pandocMetaToString(pandocMeta['loa-title']) : 'List of Abbreviations';
      const loaId = 'LOA';
      const tocList = content.querySelector('.toc ul');
      let listOfAbbreviations = document.createElement('div');
      let descriptionList = document.createElement('dl');
      content.appendChild(listOfAbbreviations);
      listOfAbbreviations.id = loaId;
      listOfAbbreviations.classList.add('section', 'front-matter', 'level1', 'loa');
      listOfAbbreviations.innerHTML = '<h1>' + loaTitle + '</h1>';
      listOfAbbreviations.appendChild(descriptionList);
      for(let abbr of abbreviations) {
        if(!abbr.title) continue;
        let term = document.createElement('dt');
        let definition = document.createElement('dd');
        descriptionList.appendChild(term);
        descriptionList.appendChild(definition);
        term.innerHTML = abbr.innerHTML;
        definition.innerText = abbr.title;
      }
      if (tocList) {
        const loaTOCItem = document.createElement('li');
        loaTOCItem.innerHTML = '<a href="#' + loaId + '">' + loaTitle + '</a>';
        tocList.appendChild(loaTOCItem);
      }
    }
  });

  // This hook moves the sections of class front-matter in the div.front-matter-container
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const frontMatter = content.querySelector('.front-matter-container');
      if (!frontMatter) return;

      // move front matter sections in the front matter container
      const frontMatterSections = content.querySelectorAll('.level1.front-matter');
      for (const section of frontMatterSections) {
        frontMatter.appendChild(section);
      }

      // add the class front-matter-ref to any <a></a> element
      // referring to an entry in the front matter
      const anchors = content.querySelectorAll('a[href^="#"]:not([href*=":"])');
      for (const a of anchors) {
        const ref = a.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (frontMatter.contains(element)) a.classList.add('front-matter-ref');
      }

      // update the toc, lof and lot for front matter sections
      const frontMatterSectionsLinks = content.querySelectorAll('.toc .front-matter-ref, .lof .front-matter-ref, .lot .front-matter-ref');
      for (let i = frontMatterSectionsLinks.length - 1; i >= 0; i--) {
        const listItem = frontMatterSectionsLinks[i].parentNode;
        const list = listItem.parentNode;
        list.insertBefore(listItem, list.firstChild);
      }
    }
  });

  // This hook expands the links in the lists of figures and tables
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const items = content.querySelectorAll('.lof li, .lot li');
      for (const item of items) {
        const anchor = item.firstChild;
        anchor.innerText = item.innerText;
        item.innerText = '';
        item.append(anchor);
      }
    }
  });

  // This hook adds spans for leading symbols
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
      const anchors = content.querySelectorAll('.toc a, .lof a, .lot a');
      for (const a of anchors) {
        a.innerHTML = a.innerHTML + '<span class="leaders"></span>';
      }
    }
  });

  // This hook appends short titles spans
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }

    beforeParsed(content) {
    /* A factory returning a function that appends short titles spans.
       The text content of these spans are reused for running titles (see default.css).
       Argument: level - An integer between 1 and 6.
    */
    function appendShortTitleSpans(level) {
      return () => {
        const divs = Array.from(content.querySelectorAll('.level' + level));

        function addSpan(div) {
          const mainHeader = div.getElementsByTagName('h' + level)[0];
          if (!mainHeader) return;
          const mainTitle = mainHeader.textContent;
          const spanSectionNumber = mainHeader.getElementsByClassName('header-section-number')[0];
          const mainNumber = !!spanSectionNumber ? spanSectionNumber.textContent : '';
          const runningTitle = 'shortTitle' in div.dataset ? mainNumber + ' ' + div.dataset.shortTitle : mainTitle;
          const span = document.createElement('span');
          span.className = 'shorttitle' + level;
          span.innerText = runningTitle;
          span.style.display = "none";
          mainHeader.appendChild(span);
          if (level == 1 && div.querySelector('.level2') === null) {
            let span2 = document.createElement('span');
            span2.className = 'shorttitle2';
            span2.innerText = ' ';
            span2.style.display = "none";
            span.insertAdjacentElement('afterend', span2);
          }
        }

        for (const div of divs) {
          addSpan(div);
        }
      };
    }

    appendShortTitleSpans(1)();
    appendShortTitleSpans(2)();
    }
  });

  // Footnotes support
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.splittedParagraphRefs = [];
    }

    beforeParsed(content) {
      // remove footnotes in toc, lof, lot
      // see https://github.com/rstudio/pagedown/issues/54
      let removeThese = content.querySelectorAll('.toc .footnote, .lof .footnote, .lot .footnote');
      for (const el of removeThese) {
        el.remove();
      }

      let footnotes = content.querySelectorAll('.footnote');

      for (let footnote of footnotes) {
        let parentElement = footnote.parentElement;
        let footnoteCall = document.createElement('a');
        let footnoteNumber = footnote.dataset.pagedownFootnoteNumber;

        footnoteCall.className = 'footnote-ref'; // same class as Pandoc
        footnoteCall.setAttribute('id', 'fnref' + footnoteNumber); // same notation as Pandoc
        footnoteCall.setAttribute('href', '#' + footnote.id);
        footnoteCall.innerHTML = '<sup>' + footnoteNumber +'</sup>';
        parentElement.insertBefore(footnoteCall, footnote);

        // Here comes a hack. Fortunately, it works with Chrome and FF.
        let handler = document.createElement('p');
        handler.className = 'footnoteHandler';
        parentElement.insertBefore(handler, footnote);
        handler.appendChild(footnote);
        handler.style.display = 'inline-block';
        handler.style.width = '100%';
        handler.style.float = 'right';
        handler.style.pageBreakInside = 'avoid';
      }
    }

    afterPageLayout(pageFragment, page, breakToken) {
      function hasItemParent(node) {
        if (node.parentElement === null) {
          return false;
        } else {
          if (node.parentElement.tagName === 'LI') {
            return true;
          } else {
            return hasItemParent(node.parentElement);
          }
        }
      }
      // If a li item is broken, we store the reference of the p child element
      // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
      if (breakToken !== undefined) {
        if (breakToken.node.nodeName === "#text" && hasItemParent(breakToken.node)) {
          this.splittedParagraphRefs.push(breakToken.node.parentElement.dataset.ref);
        }
      }
    }

    afterRendered(pages) {
      for (let page of pages) {
        const footnotes = page.element.querySelectorAll('.footnote');
        if (footnotes.length === 0) {
          continue;
        }

        const pageContent = page.element.querySelector('.pagedjs_page_content');
        let hr = document.createElement('hr');
        let footnoteArea = document.createElement('div');

        pageContent.style.display = 'flex';
        pageContent.style.flexDirection = 'column';

        hr.className = 'footnote-break';
        hr.style.marginTop = 'auto';
        hr.style.marginBottom = 0;
        hr.style.marginLeft = 0;
        hr.style.marginRight = 'auto';
        pageContent.appendChild(hr);

        footnoteArea.className = 'footnote-area';
        pageContent.appendChild(footnoteArea);

        for (let footnote of footnotes) {
          let handler = footnote.parentElement;

          footnoteArea.appendChild(footnote);
          handler.parentNode.removeChild(handler);

          footnote.innerHTML = '<sup>' + footnote.dataset.pagedownFootnoteNumber + '</sup>' + footnote.innerHTML;
          footnote.style.fontSize = 'x-small';
          footnote.style.marginTop = 0;
          footnote.style.marginBottom = 0;
          footnote.style.paddingTop = 0;
          footnote.style.paddingBottom = 0;
          footnote.style.display = 'block';
        }
      }

      for (let ref of this.splittedParagraphRefs) {
        let paragraphFirstPage = document.querySelector('[data-split-to="' + ref + '"]');
        // We test whether the paragraph is empty
        // see https://github.com/rstudio/pagedown/issues/23#issue-376548000
        if (paragraphFirstPage.innerText === "") {
          paragraphFirstPage.parentElement.style.display = "none";
          let paragraphSecondPage = document.querySelector('[data-split-from="' + ref + '"]');
          paragraphSecondPage.parentElement.style.setProperty('list-style', 'inherit', 'important');
        }
      }
    }
  });

  // Support for "Chapter " label on section with class `.chapter`
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      this.options = pandocMeta['chapter_name'];

      let styles;
      if (isString(this.options)) {
        this.options = pandocMetaToString(this.options);
        styles = `
        :root {
          --chapter-name-before: "${this.options}";
        }
        `;
      }
      if (isArray(this.options)) {
        this.options = this.options.map(pandocMetaToString);
        styles = `
        :root {
          --chapter-name-before: "${this.options[0]}";
          --chapter-name-after: "${this.options[1]}";
        }
        `;
      }
      if (styles) polisher.insert(styles);
    }

    beforeParsed(content) {
      const tocAnchors = content.querySelectorAll('.toc a[href^="#"]:not([href*=":"]');
      for (const anchor of tocAnchors) {
        const ref = anchor.getAttribute('href').replace(/^#/, '');
        const element = content.getElementById(ref);
        if (element.classList.contains('chapter')) {
          anchor.classList.add('chapter-ref');
        }
      }
    }
  });

  // Main text line numbering,
  // see https://github.com/rstudio/pagedown/issues/115
  // Original idea: Julien Taquet, thanks!
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);

      // get the number-lines option from Pandoc metavariables
      this.options = pandocMeta['number-lines'];
      // quit early if the "number-lines" option is false or missing
      if (!this.options) return;
      // retrieve the selector if provided, otherwise use the default selector
      this.selector = this.options.selector ? pandocMetaToString(this.options.selector) : '.level1:not(.front-matter) h1, .level1 h2, .level1 h3, .level1 p';

      const styles = `
      :root {
        --line-numbers-padding-right: 10px;
        --line-numbers-font-size: 8pt;
      }
      .pagedown-linenumbers-container {
        position: absolute;
        margin-top: var(--pagedjs-margin-top);
        right: calc(var(--pagedjs-width) - var(--pagedjs-margin-left));
      }
      .maintextlinenumbers {
        position: absolute;
        right: 0;
        text-align: right;
        padding-right: var(--line-numbers-padding-right);
        font-size: var(--line-numbers-font-size);
      }
      `;
      polisher.insert(styles);

      this.resetLinesCounter();
    }

    appendLineNumbersContainer(page) {
      const pagebox = page.element.querySelector('.pagedjs_pagebox');
      const lineNumbersContainer = document.createElement('div');
      lineNumbersContainer.classList.add('pagedown-linenumbers-container');

      return pagebox.appendChild(lineNumbersContainer);
    }

    lineHeight(element) {
      // If the document stylesheet does not define a value for line-height,
      // Blink returns "normal". Therefore, parseInt may return NaN.
      return parseInt(getComputedStyle(element).lineHeight);
    }

    innerHeight(element) {
      let outerHeight = element.getBoundingClientRect().height;
      let {borderTopWidth,
           borderBottomWidth,
           paddingTop,
           paddingBottom} = getComputedStyle(element);

      borderTopWidth = parseFloat(borderTopWidth);
      borderBottomWidth = parseFloat(borderBottomWidth);
      paddingTop = parseFloat(paddingTop);
      paddingBottom = parseFloat(paddingBottom);

      return Math.round(outerHeight - borderTopWidth - borderBottomWidth - paddingTop - paddingBottom);
    }

    arrayOfInt(from, length) {
      // adapted from https://stackoverflow.com/a/50234108/6500804
      return Array.from(Array(length).keys(), n => n + from);
    }

    incrementLinesCounter(value) {
      this.linesCounter = this.linesCounter + value;
    }

    resetLinesCounter() {
      this.linesCounter = 0;
    }

    isDisplayMath(element) {
      const nodes = element.childNodes;
      if (nodes.length != 1) return false;
      return (nodes[0].nodeName === 'SPAN') && (nodes[0].classList.value === 'math display');
    }

    afterRendered(pages) {
      if (!this.options) return;

      for (let page of pages) {
        const lineNumbersContainer = this.appendLineNumbersContainer(page);
        const pageAreaY = page.area.getBoundingClientRect().y;
        let elementsToNumber = page.area.querySelectorAll(this.selector);

        for (let element of elementsToNumber) {
          // Do not add line numbers for display math environment
          if (this.isDisplayMath(element)) continue;

          // Try to retrieve line height
          const lineHeight = this.lineHeight(element);
          // Test against lineHeight method returns NaN
          if (!lineHeight) {
            console.warn('Failed to compute line height value on "' + page.id + '".');
            continue;
          }

          const innerHeight = this.innerHeight(element);

          // Number of lines estimation
          // There is no built-in method to detect the number of lines in a block.
          // The main caveat is that an actual line height can differ from
          // the line-height CSS property.
          // Mixed fonts, subscripts, superscripts, inline math... can increase
          // the actual line height.
          // Here, we divide the inner height of the block by the line-height
          // computed property and round to the floor to take into account that
          // sometimes the actual line height is greater than its property value.
          // This is far from perfect and can be easily broken especially by
          // inline math.
          const nLines = Math.floor(innerHeight / lineHeight);

          // do not add line numbers for void paragraphs
          if (nLines <= 0) continue;

          const linenumbers = document.createElement('div');
          lineNumbersContainer.appendChild(linenumbers);
          linenumbers.classList.add('maintextlinenumbers');

          const elementY = element.getBoundingClientRect().y;
          linenumbers.style.top = (elementY - pageAreaY) + 'px';

          const cs = getComputedStyle(element);
          const paddingTop = parseFloat(cs.paddingTop) + parseFloat(cs.borderTopWidth);
          linenumbers.style.paddingTop = paddingTop + 'px';

          linenumbers.style.lineHeight = cs.lineHeight;

          linenumbers.innerHTML = this.arrayOfInt(this.linesCounter + 1, nLines)
                                      .reduce((t, v) => t + '<br />' + v);
          this.incrementLinesCounter(nLines);
        }

        if (this.options['reset-page']) {
          this.resetLinesCounter();
        }
      }
    }
  });

  // Clean links to avoid impossible line breaking of long urls in a justified text
  // Author: Julien Taquet (Paged.js core team)
  // see https://github.com/spyrales/gouvdown/issues/37
  Paged.registerHandlers(class extends Paged.Handler {
    constructor(chunker, polisher, caller) {
      super(chunker, polisher, caller);
    }
    beforeParsed(content) {
      // add wbr to / in links
      const links = content.querySelectorAll('a[href^="http"], a[href^="www"]');
      links.forEach(link => {
        // Rerun to avoid large spaces.
        // Break after a colon or a double slash (//)
        // or before a single slash (/), a tilde (~), a period, a comma, a hyphen,
        // an underline (_), a question mark, a number sign, or a percent symbol.
        const content = link.textContent;
        if (!(link.childElementCount === 0 && content.match(/^http|^www/))) return;
        let printableUrl = content.replace(/\/\//g, "//\u003Cwbr\u003E");
        printableUrl = printableUrl.replace(/\,/g, ",\u003Cwbr\u003E");
        // put wbr around everything.
        printableUrl = printableUrl.replace(
          /(\/|\~|\-|\.|\,|\_|\?|\#|\%)/g,
          "\u003Cwbr\u003E$1"
        );
        // turn hyphen in non breaking hyphen
        printableUrl = printableUrl.replace(/\-/g, "\u003Cwbr\u003E&#x2011;");
        link.setAttribute("data-print-url", printableUrl);
        link.innerHTML = printableUrl;
      });
    }
  });

  // Repeat table headers on multiple pages
  // Authors: Julien Taquet, Lucas Maciuga and Tafael Caixeta, see https://gitlab.coko.foundation/pagedjs/pagedjs/-/issues/84
  // TODO: remove this hook when Paged.js integrates this feature
  Paged.registerHandlers(class RepeatingTableHeadersHandler extends Paged.Handler {

    constructor(chunker, polisher, caller) {
        super(chunker, polisher, caller);
        this.splitTablesRefs = [];
    }

    afterPageLayout(pageElement, page, breakToken, chunker) {
        this.chunker = chunker;
        this.splitTablesRefs = [];

        if (breakToken) {
            const node = breakToken.node;
            const tables = this.findAllAncestors(node, "table");
            if (node.tagName === "TABLE") {
                tables.push(node);
            }

            if (tables.length > 0) {
                this.splitTablesRefs = tables.map(t => t.dataset.ref);

                //checks if split inside thead and if so, set breakToken to next sibling element
                let thead = node.tagName === "THEAD" ? node : this.findFirstAncestor(node, "thead");
                if (thead) {
                    let lastTheadNode = thead.hasChildNodes() ? thead.lastChild : thead;
                    breakToken.node = this.nodeAfter(lastTheadNode, chunker.source);
                }

                this.hideEmptyTables(pageElement, node);
            }
        }
    }

    hideEmptyTables(pageElement, breakTokenNode) {
        this.splitTablesRefs.forEach(ref => {
            let table = pageElement.querySelector("[data-ref='" + ref + "']");
            if (table) {
                let sourceBody = table.querySelector("tbody > tr");
                if (!sourceBody || this.refEquals(sourceBody.firstElementChild, breakTokenNode)) {
                    table.style.visibility = "hidden";
                    table.style.position = "absolute";
                    let lineSpacer = table.nextSibling;
                    if (lineSpacer) {
                        lineSpacer.style.visibility = "hidden";
                        lineSpacer.style.position = "absolute";
                    }
                }
            }
        });
    }

    refEquals(a, b) {
        return a && a.dataset && b && b.dataset && a.dataset.ref === b.dataset.ref;
    }

    findFirstAncestor(element, selector) {
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                return element.parentNode;
            }
            element = element.parentNode;
        }
        return null;
    }

    findAllAncestors(element, selector) {
        const ancestors = [];
        while (element.parentNode && element.parentNode.nodeType === 1) {
            if (element.parentNode.matches(selector)) {
                ancestors.unshift(element.parentNode);
            }
            element = element.parentNode;
        }
        return ancestors;
    }

    // The addition of repeating Table Headers is done here because this hook is triggered before overflow handling
    layout(rendered, layout) {
        this.splitTablesRefs.forEach(ref => {
            const renderedTable = rendered.querySelector("[data-ref='" + ref + "']");
            if (renderedTable && renderedTable.hasAttribute("data-split-from")) {
                // this event can be triggered multiple times
                // added a flag repeated-headers to control when table headers already repeated in current page.
                if (!renderedTable.getAttribute("repeated-headers")) {
                    const sourceTable = this.chunker.source.querySelector("[data-ref='" + ref + "']");
                    this.repeatColgroup(sourceTable, renderedTable);
                    this.repeatTHead(sourceTable, renderedTable);
                    renderedTable.setAttribute("repeated-headers", true);
                }
            }
        });
    }

    repeatColgroup(sourceTable, renderedTable) {
        let colgroup = sourceTable.querySelectorAll("colgroup");
        let firstChild = renderedTable.firstChild;
        colgroup.forEach((colgroup) => {
            let clonedColgroup = colgroup.cloneNode(true);
            renderedTable.insertBefore(clonedColgroup, firstChild);
        });
    }

    repeatTHead(sourceTable, renderedTable) {
        let thead = sourceTable.querySelector("thead");
        if (thead) {
            let clonedThead = thead.cloneNode(true);
            renderedTable.insertBefore(clonedThead, renderedTable.firstChild);
        }
    }

    // the functions below are from pagedjs utils/dom.js
    nodeAfter(node, limiter) {
        if (limiter && node === limiter) {
            return;
        }
        let significantNode = this.nextSignificantNode(node);
        if (significantNode) {
            return significantNode;
        }
        if (node.parentNode) {
            while ((node = node.parentNode)) {
                if (limiter && node === limiter) {
                    return;
                }
                significantNode = this.nextSignificantNode(node);
                if (significantNode) {
                    return significantNode;
                }
            }
        }
    }

    nextSignificantNode(sib) {
        while ((sib = sib.nextSibling)) {
            if (!this.isIgnorable(sib)) return sib;
        }
        return null;
    }

    isIgnorable(node) {
        return (node.nodeType === 8) || // A comment node
            ((node.nodeType === 3) && this.isAllWhitespace(node)); // a text node, all whitespace
    }

    isAllWhitespace(node) {
        return !(/[^\t\n\r ]/.test(node.textContent));
    }
  });

}
</script>
<script>$(document).ready(function(){
    if (typeof $('[data-toggle="tooltip"]').tooltip === 'function') {
        $('[data-toggle="tooltip"]').tooltip();
    }
    if ($('[data-toggle="popover"]').popover === 'function') {
        $('[data-toggle="popover"]').popover();
    }
});
</script>
<style type="text/css">
.lightable-minimal {
border-collapse: separate;
border-spacing: 16px 1px;
width: 100%;
margin-bottom: 10px;
}
.lightable-minimal td {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal th {
margin-left: 5px;
margin-right: 5px;
}
.lightable-minimal thead tr:last-child th {
border-bottom: 2px solid #00000050;
empty-cells: hide;
}
.lightable-minimal tbody tr:first-child td {
padding-top: 0.5em;
}
.lightable-minimal.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-minimal.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic {
border-top: 0.16em solid #111111;
border-bottom: 0.16em solid #111111;
width: 100%;
margin-bottom: 10px;
margin: 10px 5px;
}
.lightable-classic tfoot tr td {
border: 0;
}
.lightable-classic tfoot tr:first-child td {
border-top: 0.14em solid #111111;
}
.lightable-classic caption {
color: #222222;
}
.lightable-classic td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic thead tr:last-child th {
border-bottom: 0.10em solid #111111;
}
.lightable-classic.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-classic-2 {
border-top: 3px double #111111;
border-bottom: 3px double #111111;
width: 100%;
margin-bottom: 10px;
}
.lightable-classic-2 tfoot tr td {
border: 0;
}
.lightable-classic-2 tfoot tr:first-child td {
border-top: 3px double #111111;
}
.lightable-classic-2 caption {
color: #222222;
}
.lightable-classic-2 td {
padding-left: 5px;
padding-right: 5px;
color: #222222;
}
.lightable-classic-2 th {
padding-left: 5px;
padding-right: 5px;
font-weight: normal;
color: #222222;
}
.lightable-classic-2 tbody tr:last-child td {
border-bottom: 3px double #111111;
}
.lightable-classic-2 thead tr:last-child th {
border-bottom: 1px solid #111111;
}
.lightable-classic-2.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-classic-2.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #EEE;
border-collapse: collapse;
margin-bottom: 10px;
}
.lightable-material tfoot tr td {
border: 0;
}
.lightable-material tfoot tr:first-child td {
border-top: 1px solid #EEE;
}
.lightable-material th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
}
.lightable-material td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
border-top: 1px solid #eeeeee;
}
.lightable-material.lightable-hover tbody tr:hover {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody tr:nth-child(even) {
background-color: #f5f5f5;
}
.lightable-material.lightable-striped tbody td {
border: 0;
}
.lightable-material.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #ddd;
}
.lightable-material-dark {
min-width: 100%;
white-space: nowrap;
table-layout: fixed;
font-family: Roboto, sans-serif;
border: 1px solid #FFFFFF12;
border-collapse: collapse;
margin-bottom: 10px;
background-color: #363640;
}
.lightable-material-dark tfoot tr td {
border: 0;
}
.lightable-material-dark tfoot tr:first-child td {
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark th {
height: 56px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF60;
}
.lightable-material-dark td {
height: 52px;
padding-left: 16px;
padding-right: 16px;
color: #FFFFFF;
border-top: 1px solid #FFFFFF12;
}
.lightable-material-dark.lightable-hover tbody tr:hover {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody tr:nth-child(even) {
background-color: #FFFFFF12;
}
.lightable-material-dark.lightable-striped tbody td {
border: 0;
}
.lightable-material-dark.lightable-striped thead tr:last-child th {
border-bottom: 1px solid #FFFFFF12;
}
.lightable-paper {
width: 100%;
margin-bottom: 10px;
color: #444;
}
.lightable-paper tfoot tr td {
border: 0;
}
.lightable-paper tfoot tr:first-child td {
border-top: 1px solid #00000020;
}
.lightable-paper thead tr:last-child th {
color: #666;
vertical-align: bottom;
border-bottom: 1px solid #00000020;
line-height: 1.15em;
padding: 10px 5px;
}
.lightable-paper td {
vertical-align: middle;
border-bottom: 1px solid #00000010;
line-height: 1.15em;
padding: 7px 5px;
}
.lightable-paper.lightable-hover tbody tr:hover {
background-color: #F9EEC1;
}
.lightable-paper.lightable-striped tbody tr:nth-child(even) {
background-color: #00000008;
}
.lightable-paper.lightable-striped tbody td {
border: 0;
}
</style>




<style type="text/css">
body{
font-family: Helvetica;
font-size: 10pt;
}

h1{
font-size: 12pt;
}

h2,h3,h4,h5,h6{
font-size: 11pt;
}

a[href^="http"]:not([class="uri"])::after {
content: "";
}
@page {
size: 8.5in 11in;
}
@page:left {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
@page:right {
margin-left: 30mm;
margin-right: 30mm;
margin-top: 30mm;
margin-bottom: 30mm;
}
.title {
font-size: 18px;
color: Black;
text-align: center;
}
.author { 
font-size: 13px;
color: Black;
text-align: center;
}
.date{ 
font-size: 12px;
color: Black;
text-align: center;
}


.page-break {
page-break-before: always;
}
</style>

</head>

<body>

<div class="running-h1-title"></div>

<div class="running-h2-title"></div>



<div class="front-page">
<div id="header" class="title-page">
<h1 class="title">Safety Plan Peace 2024</h1>
<h2 class="author">Al Irvine</h2>
</div>
</div>

<div class="front-matter-container">
</div>

<div class="main">
<p><img src="data:image/png;base64,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" class="logo" alt="logo" /></p>
<p><br></p>
<div class="from">
<p>Al Irvine<br />
New Graph Environment Ltd.<br />
<a href="mailto:al@newgraphenvironment" class="email">al@newgraphenvironment</a><br />
250-777-1518<br />
Date Original: 2024-08-09<br />
Date Revised: 2024-09-08</p>
</div>
<p><br></p>
<p><br></p>
<div id="safety-plan---2024-073-sern-peace-fish-passage" class="section level1 unnumbered break-after-me">
<h1>Safety Plan - 2024-073-sern-peace-fish-passage</h1>
<p>The latest version of this pdf can be downloaded <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/safety_plan_sern-peace-fish-passage.pdf">here</a>.</p>
<p><br></p>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the six permitted electrofishing sites most of the time. Additionally, we may conduct fish passage (Phase 1) and habitat confirmation (Phase 2) assessments in the Carp and Crooked watershed groups as well. A summary of the potential sites for fish passage assessments, habitat confirmation assessments, and electrofishing is provided in Table <a href="#tab:tab-electrofishing-sites">4</a>, with kml (google earth) and gpx (garmin) files downloadable <a href="https://github.com/NewGraphEnvironment/safety_plan_peace_2024/raw/main/docs/sites_sern-peace-fish-passage_20240908_kml_gpx.zip">here</a>.</p>
<p><br></p>
<p>Georeferenced pdf maps can be accessed and downloaded <a href="https://hillcrestgeo.ca/outgoing/fishpassage/projects/parsnip/">here</a>.</p>
<p><br></p>
<div id="new-graph-employee-information" class="section level2 unnumbered">
<h2>New Graph Employee Information</h2>
<p>Al Irvine<br />
Vehicle: 2013 Toyota Tundra black w/flatdeck and yellow can-am quad<br />
Accommodation: 3396 Rosia Road, Prince George, BC V2K 4Y5</p>
<p><br></p>
<p>Lucy Schick<br />
Vehicle: 2006 Pontiac Vibe red<br />
Accommodation: 6596 Dawson Road, Prince George, BC V2K 5Y4</p>
<p><br></p>
</div>
<div id="crew-members" class="section level2 unnumbered">
<h2>Crew Members</h2>
<p>New Graph Employees Al Irvine and Lucy Schick will be joined by crews from McLoed Lake. All crew member information and emergency contacts can be found below.</p>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-crew">Table 1: </span>Crew members details and emergency contacts
</caption>
<thead>
<tr>
<th style="text-align:left;">
name
</th>
<th style="text-align:left;">
email
</th>
<th style="text-align:left;">
phone
</th>
<th style="text-align:left;">
satellite
</th>
<th style="text-align:left;">
emerg_name
</th>
<th style="text-align:left;">
emerg_email
</th>
<th style="text-align:left;">
emerg_phone
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Allan Irvine
</td>
<td style="text-align:left;">
<a href="mailto:al@newgraphenvironment.com" class="email">al@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-777-1518
</td>
<td style="text-align:left;">
must be contacted by inreach first. Cannot cold call
</td>
<td style="text-align:left;">
Tara Stark
</td>
<td style="text-align:left;">
<a href="mailto:tara@newgraphenvironment.com" class="email">tara@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
250-505-9854
</td>
</tr>
<tr>
<td style="text-align:left;">
Jillian Isadore
</td>
<td style="text-align:left;">
<a href="mailto:jillianmarie457@icloud.com" class="email">jillianmarie457@icloud.com</a>
</td>
<td style="text-align:left;">
778-349-8471
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Eugenia Isadore
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
 250-644-0418 
</td>
</tr>
<tr>
<td style="text-align:left;">
Tristan Salonas
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
–
</td>
</tr>
<tr>
<td style="text-align:left;">
Bianca Prince
</td>
<td style="text-align:left;">
<a href="mailto:biancaprince@hotmail.com" class="email">biancaprince@hotmail.com</a>
</td>
<td style="text-align:left;">
250-730-1480
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
John Demont
</td>
<td style="text-align:left;">
<a href="mailto:justjohndumont@icloud.com" class="email">justjohndumont@icloud.com</a>
</td>
<td style="text-align:left;">
250-720-9700
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
Nathan Prince
</td>
<td style="text-align:left;">
–
</td>
<td style="text-align:left;">
250-617-5930
</td>
</tr>
<tr>
<td style="text-align:left;">
Lucy Schick
</td>
<td style="text-align:left;">
<a href="mailto:lucy@newgraphenvironment.com" class="email">lucy@newgraphenvironment.com</a>
</td>
<td style="text-align:left;">
604-741-2032
</td>
<td style="text-align:left;">
807-790-9843
</td>
<td style="text-align:left;">
Sa Boothroyd
</td>
<td style="text-align:left;">
<a href="mailto:saboothroyd@gmail.com" class="email">saboothroyd@gmail.com</a>
</td>
<td style="text-align:left;">
604-740-7199
</td>
</tr>
</tbody>
</table>
<p><br></p>
</div>
<div id="equipment-checklists" class="section level2 unnumbered">
<h2>Equipment Checklists</h2>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:table-equipment">Table 2: </span>Personal Equipment Checklist
</caption>
<thead>
<tr>
<th style="text-align:left;">
Personal Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
GPS
</td>
<td style="text-align:left;">
food
</td>
</tr>
<tr>
<td style="text-align:left;">
Suncreen
</td>
<td style="text-align:left;">
gloves work
</td>
</tr>
<tr>
<td style="text-align:left;">
Bugspray
</td>
<td style="text-align:left;">
glasses safety
</td>
</tr>
<tr>
<td style="text-align:left;">
Polarized glasses
</td>
<td style="text-align:left;">
headlamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Bear Spray
</td>
<td style="text-align:left;">
hard hat
</td>
</tr>
<tr>
<td style="text-align:left;">
phone/camera
</td>
<td style="text-align:left;">
steel toed boots
</td>
</tr>
<tr>
<td style="text-align:left;">
battery pack booster for phone
</td>
<td style="text-align:left;">
clinometer
</td>
</tr>
<tr>
<td style="text-align:left;">
Hat
</td>
<td style="text-align:left;">
field vest (surveyors)
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit personal
</td>
<td style="text-align:left;">
note book
</td>
</tr>
<tr>
<td style="text-align:left;">
Waders
</td>
<td style="text-align:left;">
Extra clothes
</td>
</tr>
<tr>
<td style="text-align:left;">
Boots
</td>
<td style="text-align:left;">
rain gear
</td>
</tr>
<tr>
<td style="text-align:left;">
Ski poles
</td>
<td style="text-align:left;">
hand lens
</td>
</tr>
<tr>
<td style="text-align:left;">
water
</td>
<td style="text-align:left;">
range finder
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:equip-crew">Table 3: </span>Crew Equipment Checklist
</caption>
<thead>
<tr>
<th style="text-align:left;">
Crew Equipment Checklist
</th>
<th style="text-align:left;">
<ul>
<li></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left;">
Hand saw
</td>
<td style="text-align:left;">
pilon x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Linesman Gloves x 3
</td>
<td style="text-align:left;">
Measuring board
</td>
</tr>
<tr>
<td style="text-align:left;">
Backroads Mapbook
</td>
<td style="text-align:left;">
Scale
</td>
</tr>
<tr>
<td style="text-align:left;">
Locational maps
</td>
<td style="text-align:left;">
Permits
</td>
</tr>
<tr>
<td style="text-align:left;">
Background Documents
</td>
<td style="text-align:left;">
Fish ID book
</td>
</tr>
<tr>
<td style="text-align:left;">
radio handheld
</td>
<td style="text-align:left;">
Site Cards / Field Guide
</td>
</tr>
<tr>
<td style="text-align:left;">
Satelite communicator
</td>
<td style="text-align:left;">
Minnow Traps
</td>
</tr>
<tr>
<td style="text-align:left;">
Field Safety Plan
</td>
<td style="text-align:left;">
Catfood
</td>
</tr>
<tr>
<td style="text-align:left;">
first aid kit level 1
</td>
<td style="text-align:left;">
Flagging
</td>
</tr>
<tr>
<td style="text-align:left;">
First Aid binder stocked
</td>
<td style="text-align:left;">
Laptop w/basecamp
</td>
</tr>
<tr>
<td style="text-align:left;">
Throw bags
</td>
<td style="text-align:left;">
GPS cable
</td>
</tr>
<tr>
<td style="text-align:left;">
polaski
</td>
<td style="text-align:left;">
Lazer level
</td>
</tr>
<tr>
<td style="text-align:left;">
shovel
</td>
<td style="text-align:left;">
Assessment cards fish passage
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher backpack
</td>
<td style="text-align:left;">
UAV
</td>
</tr>
<tr>
<td style="text-align:left;">
fire extinguisher pressurized
</td>
<td style="text-align:left;">
Flow meter
</td>
</tr>
<tr>
<td style="text-align:left;">
Battery booster
</td>
<td style="text-align:left;">
ATV
</td>
</tr>
<tr>
<td style="text-align:left;">
Compressor 12V
</td>
<td style="text-align:left;">
bucket rigid x 2
</td>
</tr>
<tr>
<td style="text-align:left;">
Rubber boots (no-slip soles)
</td>
<td style="text-align:left;">
bucket foldable
</td>
</tr>
<tr>
<td style="text-align:left;">
Small BT Speaker (for bears)
</td>
<td style="text-align:left;">
clove oil kit w/ instructions
</td>
</tr>
<tr>
<td style="text-align:left;">
Oakton Multimeter
</td>
<td style="text-align:left;">
gloves leather
</td>
</tr>
<tr>
<td style="text-align:left;">
Backpack Electrofisher
</td>
<td style="text-align:left;">
sharpies
</td>
</tr>
<tr>
<td style="text-align:left;">
stop nets x 4
</td>
<td style="text-align:left;">
ATV gas
</td>
</tr>
<tr>
<td style="text-align:left;">
salt blocks
</td>
<td style="text-align:left;">
ATV lock
</td>
</tr>
<tr>
<td style="text-align:left;">
loose salt
</td>
<td style="text-align:left;">
UAV battery charger
</td>
</tr>
<tr>
<td style="text-align:left;">
dip nets x 2
</td>
<td style="text-align:left;">
wader disinfectant kit
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure hand
</td>
<td style="text-align:left;">
GPS batteries
</td>
</tr>
<tr>
<td style="text-align:left;">
tape measure eslon
</td>
<td style="text-align:left;">
ATV helmets
</td>
</tr>
</tbody>
</table></li>
</ul>
<p><br><br></p>
</div>
<div id="nearest-hospitals" class="section level2 unnumbered">
<h2>Nearest Hospitals</h2>
<div class="figure"><span style="display:block;" id="fig:hospital-1"></span>
<img src="data:image/png;base64,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" alt="University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000" width="100%" />
<p class="caption">
Figure 1: University Hospital of Northern British Columbia - 1475 Edmonton St., Prince George, BC V2M 1S2 - 250-565-2000
</p>
</div>
<p><br></p>
</div>
<div id="emergency-response-plan" class="section level2 unnumbered">
<h2>Emergency Response Plan</h2>
<p>New Graph’s detailed emergency response procedures can be found <a href="https://www.newgraphenvironment.com/hsp/plans-and-assessments.html#emergency-response-plan-erp-and-procedures">here</a>. These procedures should be reviewed and an emergency response plan should be completed for each job site. Our Emergency Responce Plan template can be downloaded <a href="https://github.com/NewGraphEnvironment/hsp/blob/master/data/form_templates/ERP_template.pdf">here</a>.</p>
<p><br></p>
</div>
<div id="driving" class="section level2 unnumbered">
<h2>Driving</h2>
<p>We will be driving on forest service roads where it is essential to exercise caution and adhere strictly to all radio use protocols to ensure our safety. Proper communication on these roads helps prevent accidents by keeping everyone informed about vehicle movements and road conditions. Please review the <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#resource-road-safety">resource road safety</a> and <a href="https://www.newgraphenvironment.com/hsp/safe-work-procedures-and-practices.html#radio-use">radio use</a> sections of our Health and Safety plan so that everyone stays safe.</p>
<p><br></p>
</div>
<div id="field-plan" class="section level2 unnumbered">
<h2>Field Plan</h2>
<p>The main goal of the fieldwork is baseline monitoring using electrofishing with crews from McLeod Lake. We will be at the 5 or 6 permitted electrofishing sites most of the time. In addition we may spend some time with fish passage assessments in areas of not only the Parsnip watershed group but also the Carp and Crooked watershed groups.</p>
<p>Field work methods will result in products feeding reporting formats such as <a href="https://www.newgraphenvironment.com/fish_passage_peace_2022_reporting/">here</a> for 2022 and <a href="https://www.newgraphenvironment.com/fish_passage_peace_2023_reporting/">here</a> for 2023. We generally follow procedures in:</p>
<ul>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">fish passage assessments</a> <span class="citation">(BC Ministry of Environment 2011)</span></p></li>
<li><p><a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">habitat confirmations</a> <span class="citation">(Fish Passage Technical Working Group 2011)</span>.</p></li>
</ul>
<p><br></p>
<p>Presence/absence of fish, species composition/density and distribution limits can be useful for prioritizing which crossings are a best fit for fish passage restoration and help inform follow up monitoring so electrofishing and minnowtrapping may be conducted. Standard Fish and Fish Habitat Inventory Standard Field Form <a href="https://www2.gov.bc.ca/gov/content/environment/natural-resource-stewardship/laws-policies-standards-guidance/inventory-standards/aquatic-ecosystems">site cards</a> are used to gather habitat data, and the Field Guide to these site cards can be found <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/sitecard20.pdf">here</a>.</p>
<p><br></p>
<p>We have PIT tagging equipment so we could consider <a href="https://www.youtube.com/watch?v=9CKZ9yaS5o8">tagging</a> fish captured at electrofishing sites to help us better understand population sizes and fish movement upstream and downstream of sites over the years.</p>
<p><br></p>
<p>We use digital field form using a product called <a href="https://merginmaps.com/?gclid=Cj0KCQjwxb2XBhDBARIsAOjDZ34oq-iMid3vRrgK1ZAkJ_yiz4aWY-LLF90PHiXzELbZIrxooV9vWKYaAgl2EALw_wcB">Mergin Maps</a> which syncs with QGIS. Please see our <a href="https://www.newgraphenvironment.com/fish_passage_guidebook/">Fish Passage Guidebook</a> for instructions on how to set up Mergin Maps and use our digital field forms. Please send me your usernames and we can begin to share projects/forms.</p>
<p><br></p>
<p>A guide to freshwater fish id such as <span class="citation">McPhail and Carveth (1993)</span> can be useful and can be downloaded <a href="https://a100.gov.bc.ca/pub/acat/documents/r13659/486FieldKeytoFreshwaterFishes1993Part1of2_1210014849226_8e248a8d30d97e6c45ef54a340babd2ffb57b14a3b16.pdf">here</a>.</p>
<!-- and an overview map of displaying potential sample locations is included as Figure 1. -->
<p><br></p>
<div id="check-in-procedures" class="section level3 unnumbered">
<h3>Check In Procedures</h3>
<p>Call, text or inreach Tara Stark (2505059854) each morning to share the plan for the day (i.e. name of roads and sites). Check in time is before 7 pm each evening although we regularly check in throughout the day (ex. at arrival to site, 1pm and 4pm) on the inreach or by text and report position/provide updates.</p>
<p><br></p>
<div id="procedures-for-failed-check-in---for-check-in-person" class="section level4 unnumbered">
<h4>Procedures for Failed Check-In - for Check in person</h4>
<p>Procedures are summarized in the following Figure. If phone call or inReach check-in is not received by 7pm send text to inreach units, call or text cell phones of field crew members. If no response please call accommodations then personal emergency contacts to see if they have heard anything. Wait 1 hour and text inreach, text or call cell phones and personal emergency contacts and accomodations again. Repeat after 2 hours (9 pm) - if no response then notify the RCMP of a missing persons in field.</p>
<p><br></p>
<div class="figure"><span style="display:block;" id="fig:flow-check-in-fail"></span>
<img src="data:image/png;base64,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" alt="Procedures for failed check-in" width="100%" />
<p class="caption">
Figure 2: Procedures for failed check-in
</p>
</div>
<p><br><br><br></p>
<!-- <br><br><br><br><br><br><br> -->
<div class="figure"><span style="display:block;" id="fig:map-prep"></span>
<img src="data:image/png;base64,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" alt="Map of potential sampling areas." width="100%" />
<p class="caption">
Figure 3: Map of potential sampling areas.
</p>
</div>
<p><br></p>
<table class="table table-condensed table-responsive" style="font-size: 8px; color: black; margin-left: auto; margin-right: auto;">
<caption style="font-size: initial !important;">
<span id="tab:tab-electrofishing-sites">Table 4: </span>Potential Phase 1 assessment, Phase 2 assessment, and Electrofishing Locations
</caption>
<thead>
<tr>
<th style="text-align:right;">
id
</th>
<th style="text-align:left;">
stream_name
</th>
<th style="text-align:right;">
utm_zone
</th>
<th style="text-align:right;">
utm_easting
</th>
<th style="text-align:right;">
utm_northing
</th>
<th style="text-align:left;">
watershed_group_code
</th>
<th style="text-align:left;">
pscis_assessment_comment
</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:right;">
125000
</td>
<td style="text-align:left;">
tributary to Parsnip River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
577541
</td>
<td style="text-align:right;">
6038215
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream continuosly for 350 m to beaver influenced wetland area where walking became difficult. Then stream was visited again upstream at 1.6 km upstream from crossing then again at approximately 2.5 km upstream of crossing. Undercut banks provide areas of deep cover ad Large woody debris is scattered througout. Overhanging vegetationalso provides cover througout. Pools observed were somewhat shallow but were preseetevery 20 - 30 m or so. Minnowtrapping conducted upstream and downstream of crossing. Electrofishing conducted downstream of the crossing. No fish captured upstream of the culvert. First beaver dam located approximately 330m upstream of the culvert.
</td>
</tr>
<tr>
<td style="text-align:right;">
125179
</td>
<td style="text-align:left;">
Unnamed tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
570307
</td>
<td style="text-align:right;">
6052836
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration with habitat for rearing and overwintering upstream. Surveyed upstream for 520 m with no barriers to fish passage present. Bull trout and rainbow recorded upstream. Some deep pools for overwintering and rearing. Large woody debris and undercut banks throughout. Sections of gravel suitable for spawning. Good flow. Surveyed downstream for 360 m. No barriers observed and none likely downstream of surveyed section due to gradients. Abundant large woody debris and gravels suitable for spawning.
</td>
</tr>
<tr>
<td style="text-align:right;">
125180
</td>
<td style="text-align:left;">
tributary to Missinka River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
569664
</td>
<td style="text-align:right;">
6053048
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed upstream of PSCIS crossing 125186 for a distance of 515 m. Good flow and abundant cover. Large woody debris and pools throughout. Frequet pockets of gravel suitable for spawning. Good candidate.
</td>
</tr>
<tr>
<td style="text-align:right;">
125231
</td>
<td style="text-align:left;">
tributary to Table River
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
549962
</td>
<td style="text-align:right;">
6065140
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
High priority candidate for restoration. Good habitat. Surveyed for 600m to new bridge (modelled crossing 16603641). Some deep pools and bounlders, udercut banks, gravels throughout. Abundant large wody debris throughout. Some debris steps from 30 - 70 cms high. No barriers. Rainbow trout known upstream (FIDQ 2020). Good candidate for rehabilitation.
</td>
</tr>
<tr>
<td style="text-align:right;">
125261
</td>
<td style="text-align:left;">
Fern Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
534600
</td>
<td style="text-align:right;">
6067770
</td>
<td style="text-align:left;">
PARS
</td>
<td style="text-align:left;">
Two additional culverts at 0.9m diameter.
</td>
</tr>
<tr>
<td style="text-align:right;">
198667
</td>
<td style="text-align:left;">
Tsatchuka Creek
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
500641
</td>
<td style="text-align:right;">
6089777
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Grate on inlet and beaver influenced wetland upstream. Inlet blocked by beaver debris with beaver trap on inlet. Potentially good candidate for leveler to maintain beaver activity without attempting to remove the animals. Ministry of Transportation chris_culvert_id: 1997066. 13:04:57
</td>
</tr>
<tr>
<td style="text-align:right;">
198668
</td>
<td style="text-align:left;">
Tributary to McLeod Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
501971
</td>
<td style="text-align:right;">
6087814
</td>
<td style="text-align:left;">
CARP
</td>
<td style="text-align:left;">
Abundant gravels, suitable for spawning upstream. Although flows are minimal, the streams does still have water. Models as having over 3 km of habitat upstream below 5%. Although no fish are recorded as present upstream it seems highly likely that this would be a fish bearing stream. Outlet drop is 80cm. Steep section of pipe at the inlet recorded as inlet drop. Ministry of Transportation chris_culvert_id: 1996852. 13:40:04
</td>
</tr>
<tr>
<td style="text-align:right;">
198692
</td>
<td style="text-align:left;">
Tributary to Kerry Lake
</td>
<td style="text-align:right;">
10
</td>
<td style="text-align:right;">
511735
</td>
<td style="text-align:right;">
6059316
</td>
<td style="text-align:left;">
CRKD
</td>
<td style="text-align:left;">
Nice little stream with decent flow for this time of year. Pockets of gravel throughout and healthy shrub and mixed riparian. Fish presence unknown, but seems likely due to proximity to Kerry lake with low gradients. 17:14:13
</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div id="references" class="section level1 unnumbered">
<h1>References</h1>
<div id="refs" class="references csl-bib-body hanging-indent" entry-spacing="0">
<div id="ref-fish_passage_assessments" class="csl-entry">
BC Ministry of Environment. 2011. <em>Field Assessment for Determining Fish Passage Status of Closed Bottom Structures</em>. Manual. Victoria, British Columbia: BC Ministry of Environment. <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/field-assessment-for-determining-fish-passage-status-of-cbs.pdf</a>.
</div>
<div id="ref-confirmation_checklist_2011" class="csl-entry">
Fish Passage Technical Working Group. 2011. <span>“A <span>Checklist</span> for <span>Fish Habitat Confirmation Prior</span> to the <span>Rehabilitation</span> Fo a <span>Stream Crossing</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/land-based-investment/forests-for-tomorrow/checklist-for-fish-habitat-confirmation-201112.pdf</a>.
</div>
<div id="ref-mcphail_carveth1993FieldKey" class="csl-entry">
McPhail, J. D., and R Carveth. 1993. <span>“Field <span>Key</span> to the <span>Freshwater Fishes</span> of <span>British Columbia</span>.”</span> <a href="https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf">https://www2.gov.bc.ca/assets/gov/environment/natural-resource-stewardship/nr-laws-policy/risc/field_key_to_freshwater_fishes_of_bc_field_size_water_resistant_version.pdf</a>.
</div>
</div>
</div>
</div>



<script>
// when the page is about to reload via servr, remember the scroll position
document.addEventListener('servr:reload', function(e) {
  sessionStorage.setItem('pagedown-scroll', window.scrollY);
});
</script>
</body>
</html>
